<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Trunk-Based Development on Henry Techie</title><link>https://namanh11611.github.io/tags/trunk-based-development/</link><description>Recent content in Trunk-Based Development on Henry Techie</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Sun, 08 Sep 2024 00:00:00 +0700</lastBuildDate><atom:link href="https://namanh11611.github.io/tags/trunk-based-development/index.xml" rel="self" type="application/rss+xml"/><item><title>Gitflow, GitHub Flow, GitLab Flow, Trunk-Based Development: Which Git Branching Strategy is Right for You?</title><link>https://namanh11611.github.io/p/git-branching-strategy/</link><pubDate>Sun, 08 Sep 2024 00:00:00 +0700</pubDate><guid>https://namanh11611.github.io/p/git-branching-strategy/</guid><description>&lt;img src="https://namanh11611.github.io/p/git-branching-strategy/strategy.webp" alt="Featured image of post Gitflow, GitHub Flow, GitLab Flow, Trunk-Based Development: Which Git Branching Strategy is Right for You?" /&gt;&lt;p&gt;&lt;em&gt;Photo by &lt;a class="link" href="https://unsplash.com/@felix_mittermeier?utm_content=creditCopyText&amp;amp;utm_medium=referral&amp;amp;utm_source=unsplash" target="_blank" rel="noopener"
&gt;Felix Mittermeier&lt;/a&gt; on &lt;a class="link" href="https://unsplash.com/photos/pieces-dechecs-sur-lechiquier-nAjil1z3eLk?utm_content=creditCopyText&amp;amp;utm_medium=referral&amp;amp;utm_source=unsplash" target="_blank" rel="noopener"
&gt;Unsplash&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Git Branching Strategy&lt;/strong&gt; refers to the way we &lt;strong&gt;create branches&lt;/strong&gt;, &lt;strong&gt;merge branches&lt;/strong&gt;, and decide which branches are used for releases.&lt;/p&gt;
&lt;p&gt;When starting a project, beyond setting up the environment and building a solid codebase, selecting the right &lt;strong&gt;Git Branching Strategy&lt;/strong&gt; is crucial. A wrong choice can lead to significant challenges. The right strategy helps the team &lt;strong&gt;manage and maintain source code effectively&lt;/strong&gt;, &lt;strong&gt;reduce conflict resolution time&lt;/strong&gt;, and ensure &lt;strong&gt;production code remains stable&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;Over time, various strategies have emerged. This article explores some popular &lt;strong&gt;Git Branching Strategies&lt;/strong&gt; like &lt;strong&gt;Gitflow&lt;/strong&gt;, &lt;strong&gt;GitHub Flow&lt;/strong&gt;, &lt;strong&gt;GitLab Flow&lt;/strong&gt;, and &lt;strong&gt;Trunk-Based Development&lt;/strong&gt;. Finally, we’ll discuss how to choose the right strategy for your project.&lt;/p&gt;
&lt;h1 id="gitflow"&gt;Gitflow
&lt;/h1&gt;&lt;p&gt;&lt;a class="link" href="https://nvie.com/posts/a-successful-git-branching-model" target="_blank" rel="noopener"
&gt;&lt;strong&gt;Gitflow&lt;/strong&gt;&lt;/a&gt;, introduced by &lt;a class="link" href="https://nvie.com/about" target="_blank" rel="noopener"
&gt;&lt;strong&gt;Vincent Driessen&lt;/strong&gt;&lt;/a&gt;, is well-suited for projects with clear and complex release cycles. &lt;strong&gt;Gitflow&lt;/strong&gt; uses multiple branch types to manage the development and release phases.&lt;/p&gt;
&lt;p&gt;&lt;img src="https://nvie.com/img/git-model@2x.png"
loading="lazy"
alt="Gitflow"
&gt;&lt;/p&gt;
&lt;p&gt;In this flow, there are two main branches: &lt;strong&gt;master&lt;/strong&gt; and &lt;strong&gt;develop&lt;/strong&gt;. The &lt;strong&gt;master&lt;/strong&gt; branch contains stable code ready for release, while &lt;strong&gt;develop&lt;/strong&gt; contains the latest changes for the next release. It’s the main branch for feature integration.&lt;/p&gt;
&lt;p&gt;Additionally, there are &lt;strong&gt;feature&lt;/strong&gt; branches that are &lt;code&gt;checkout&lt;/code&gt; from &lt;strong&gt;develop&lt;/strong&gt; and used to develop new features. Once completed, they are &lt;code&gt;merge&lt;/code&gt; back into &lt;strong&gt;develop&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;When ready for release, a branch is checked out from &lt;strong&gt;develop&lt;/strong&gt; to a &lt;strong&gt;release&lt;/strong&gt; branch with the corresponding version to prepare for the release. Bug fixes can be added as commits on this branch. Once finalized, the &lt;strong&gt;release&lt;/strong&gt; branch is &lt;code&gt;merge&lt;/code&gt; into both &lt;strong&gt;master&lt;/strong&gt; and &lt;strong&gt;develop&lt;/strong&gt; to keep the two main branches updated.&lt;/p&gt;
&lt;p&gt;Finally, there are &lt;strong&gt;hotfix&lt;/strong&gt; branches. When production code encounters a critical bug that needs an immediate fix, a &lt;strong&gt;hotfix&lt;/strong&gt; branch is &lt;code&gt;checkout&lt;/code&gt; from &lt;strong&gt;master&lt;/strong&gt; for the fix. Similar to &lt;strong&gt;release&lt;/strong&gt; branches, &lt;strong&gt;hotfix&lt;/strong&gt; branches must also be &lt;code&gt;merge&lt;/code&gt; into both &lt;strong&gt;master&lt;/strong&gt; and &lt;strong&gt;develop&lt;/strong&gt;.&lt;/p&gt;
&lt;h2 id="advantages"&gt;Advantages
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Provides a clear structure, ideal for large projects.&lt;/li&gt;
&lt;li&gt;Efficiently manages development and release phases with versioned &lt;strong&gt;release&lt;/strong&gt; branches.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Hotfix&lt;/strong&gt; branches allow quick fixes without disrupting ongoing development.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="disadvantages"&gt;Disadvantages
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Complex and requires multiple branches and merges. For example, each &lt;strong&gt;release&lt;/strong&gt; or &lt;strong&gt;hotfix&lt;/strong&gt; branch needs to be merged into both &lt;strong&gt;master&lt;/strong&gt; and &lt;strong&gt;develop&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;Unsuitable for projects requiring &lt;strong&gt;CI/CD&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;Challenging for small teams due to its cumbersome nature.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id="github-flow"&gt;GitHub Flow
&lt;/h1&gt;&lt;p&gt;&lt;a class="link" href="https://docs.github.com/en/get-started/using-github/github-flow" target="_blank" rel="noopener"
&gt;&lt;strong&gt;GitHub Flow&lt;/strong&gt;&lt;/a&gt; is a lightweight, simple strategy ideal for &lt;strong&gt;CI/CD&lt;/strong&gt; and commonly used in open-source projects or small teams.&lt;/p&gt;
&lt;p&gt;&lt;img src="https://namanh11611.github.io/p/git-branching-strategy/github_flow.webp"
width="3532"
height="3840"
srcset="https://namanh11611.github.io/p/git-branching-strategy/github_flow_hu_348aebd6a648b050.webp 480w, https://namanh11611.github.io/p/git-branching-strategy/github_flow_hu_14f09a141aeb2a76.webp 1024w"
loading="lazy"
alt="GitHub Flow"
class="gallery-image"
data-flex-grow="91"
data-flex-basis="220px"
&gt;&lt;/p&gt;
&lt;p&gt;Unlike Gitflow, it has a single main branch, &lt;strong&gt;main&lt;/strong&gt;, which contains thoroughly tested and stable code ready for production.&lt;/p&gt;
&lt;p&gt;Features are developed in &lt;strong&gt;feature&lt;/strong&gt; branches, tested, reviewed, and merged into &lt;strong&gt;main&lt;/strong&gt; via pull requests.&lt;/p&gt;
&lt;h2 id="advantages-1"&gt;Advantages
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Simple and easy to understand, making it quick to implement.&lt;/li&gt;
&lt;li&gt;Perfect for &lt;strong&gt;CI/CD&lt;/strong&gt; workflows, ensuring the &lt;strong&gt;main&lt;/strong&gt; branch is always deployable.&lt;/li&gt;
&lt;li&gt;Fewer branches mean reduced conflicts and merge errors.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="disadvantages-1"&gt;Disadvantages
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Lacks the structure of Gitflow.&lt;/li&gt;
&lt;li&gt;Unsuitable for large projects or those requiring support for multiple versions.&lt;/li&gt;
&lt;li&gt;Does not define clear processes for releases or bug fixes.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id="gitlab-flow"&gt;GitLab Flow
&lt;/h1&gt;&lt;p&gt;&lt;a class="link" href="https://about.gitlab.com/topics/version-control/what-is-gitlab-flow" target="_blank" rel="noopener"
&gt;&lt;strong&gt;GitLab Flow&lt;/strong&gt;&lt;/a&gt; combines elements of Gitflow and GitHub Flow. It introduces &lt;strong&gt;environment branches&lt;/strong&gt; like &lt;strong&gt;staging&lt;/strong&gt; and &lt;strong&gt;production&lt;/strong&gt;, making it suitable for &lt;strong&gt;CI/CD&lt;/strong&gt; and tightly integrated with GitLab’s &lt;strong&gt;CI/CD&lt;/strong&gt; tools.&lt;/p&gt;
&lt;p&gt;&lt;img src="https://namanh11611.github.io/p/git-branching-strategy/gitlab_flow.webp"
width="3840"
height="3321"
srcset="https://namanh11611.github.io/p/git-branching-strategy/gitlab_flow_hu_812c2952f8ae368d.webp 480w, https://namanh11611.github.io/p/git-branching-strategy/gitlab_flow_hu_b81493d4017cb025.webp 1024w"
loading="lazy"
alt="GitLab Flow"
class="gallery-image"
data-flex-grow="115"
data-flex-basis="277px"
&gt;&lt;/p&gt;
&lt;p&gt;Similar to GitHub Flow, GitLab Flow works directly with the primary branch, &lt;strong&gt;main&lt;/strong&gt;, which contains stable source code ready for release. This flow also includes feature branches for developing new features.&lt;/p&gt;
&lt;p&gt;When the code on the &lt;strong&gt;main&lt;/strong&gt; branch is ready for testing, we &lt;code&gt;merge&lt;/code&gt; it into the &lt;strong&gt;staging&lt;/strong&gt; branch. After testing and confirming it is ready for deployment, we &lt;code&gt;merge&lt;/code&gt; the code from the &lt;strong&gt;staging&lt;/strong&gt; branch into the &lt;strong&gt;production&lt;/strong&gt; branch. GitLab Flow often uses &lt;strong&gt;release&lt;/strong&gt; branches, such as &lt;strong&gt;release/v1&lt;/strong&gt; and &lt;strong&gt;release/v2&lt;/strong&gt;, to independently manage and deploy different versions of the application.&lt;/p&gt;
&lt;p&gt;However, when there is a bug in production, you need to merge the code into the &lt;strong&gt;main&lt;/strong&gt; branch first, then &lt;code&gt;merge&lt;/code&gt; or &lt;code&gt;cherry-pick&lt;/code&gt; it into other branches following the above process.&lt;/p&gt;
&lt;h2 id="advantages-2"&gt;Advantages
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Simpler than Gitflow, but more structured than GitHub Flow.&lt;/li&gt;
&lt;li&gt;Well-suited for &lt;strong&gt;CI/CD&lt;/strong&gt; projects with multiple environments.&lt;/li&gt;
&lt;li&gt;Supports independent management of different application versions using &lt;strong&gt;release&lt;/strong&gt; branches.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="disadvantages-2"&gt;Disadvantages
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Best suited for GitLab and its &lt;strong&gt;CI/CD&lt;/strong&gt; tools.&lt;/li&gt;
&lt;li&gt;Requires careful setup to leverage its full potential.&lt;/li&gt;
&lt;li&gt;Not ideal for projects without &lt;strong&gt;CI/CD&lt;/strong&gt; requirements.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id="trunk-based-development"&gt;Trunk-Based Development
&lt;/h1&gt;&lt;p&gt;For a detailed discussion, refer to my article: &lt;a class="link" href="../trunk-based-development" &gt;Trunk-Based Development - A Git Workflow to Reduce Merge Conflicts&lt;/a&gt;. &lt;strong&gt;Trunk-Based Development (TBD)&lt;/strong&gt; is a strategy where all developers work on a single main branch, typically &lt;strong&gt;main&lt;/strong&gt;. Changes are continuously and quickly committed to this branch, minimizing the lifespan of feature branches.&lt;/p&gt;
&lt;h2 id="advantages-3"&gt;Advantages
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Encourages &lt;strong&gt;CI&lt;/strong&gt; and minimizes merge conflicts.&lt;/li&gt;
&lt;li&gt;Ideal for Agile and DevOps projects requiring &lt;strong&gt;CD&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;Easy to manage and track the codebase.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="disadvantages-3"&gt;Disadvantages
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Higher risk of directly committing errors to the main branch.&lt;/li&gt;
&lt;li&gt;Requires robust code reviews and automation tests to maintain stability.&lt;/li&gt;
&lt;li&gt;Unsuitable for large, distributed teams.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id="choosing-the-right-strategy"&gt;Choosing the Right Strategy
&lt;/h1&gt;&lt;p&gt;There’s no one-size-fits-all solution. The choice of Git branching strategy depends on factors like project scale, team structure, and development requirements. Below are some suggestions:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Project Type&lt;/th&gt;
&lt;th&gt;Team Size&lt;/th&gt;
&lt;th&gt;Recommended Strategy&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Small to medium projects with continuous delivery&lt;/td&gt;
&lt;td&gt;Small, Medium&lt;/td&gt;
&lt;td&gt;GitHub Flow, TBD&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Scheduled and periodic releases&lt;/td&gt;
&lt;td&gt;Medium&lt;/td&gt;
&lt;td&gt;GitFlow, GitLab Flow&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;CI/CD projects with multiple environments&lt;/td&gt;
&lt;td&gt;Medium, Large&lt;/td&gt;
&lt;td&gt;GitLab Flow&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Long-term maintenance projects&lt;/td&gt;
&lt;td&gt;Large&lt;/td&gt;
&lt;td&gt;GitFlow&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Each strategy has its pros and cons. The key is selecting one that aligns with your team’s workflow and project requirements. Doing so optimizes productivity and minimizes risks in source code management.&lt;/p&gt;
&lt;h1 id="referrence"&gt;Referrence
&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class="link" href="https://nvie.com/posts/a-successful-git-branching-model" target="_blank" rel="noopener"
&gt;https://nvie.com/posts/a-successful-git-branching-model&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="link" href="https://docs.github.com/en/get-started/using-github/github-flow" target="_blank" rel="noopener"
&gt;https://docs.github.com/en/get-started/using-github/github-flow&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="link" href="https://about.gitlab.com/topics/version-control/what-is-gitlab-flow" target="_blank" rel="noopener"
&gt;https://about.gitlab.com/topics/version-control/what-is-gitlab-flow&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="link" href="https://www.gitkraken.com/learn/git/best-practices/git-branch-strategy" target="_blank" rel="noopener"
&gt;https://www.gitkraken.com/learn/git/best-practices/git-branch-strategy&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="link" href="https://www.geeksforgeeks.org/branching-strategies-in-git" target="_blank" rel="noopener"
&gt;https://www.geeksforgeeks.org/branching-strategies-in-git&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="link" href="https://www.abtasty.com/blog/git-branching-strategies" target="_blank" rel="noopener"
&gt;https://www.abtasty.com/blog/git-branching-strategies&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description></item><item><title>Trunk Based Development – a Git workflow to reduce the headache of resolving conflicts</title><link>https://namanh11611.github.io/p/trunk-based-development/</link><pubDate>Wed, 03 May 2023 02:07:00 +0700</pubDate><guid>https://namanh11611.github.io/p/trunk-based-development/</guid><description>&lt;img src="https://namanh11611.github.io/p/trunk-based-development/tbd.webp" alt="Featured image of post Trunk Based Development – a Git workflow to reduce the headache of resolving conflicts" /&gt;&lt;h1 id="case-study"&gt;Case study
&lt;/h1&gt;&lt;h2 id="the-first-story"&gt;The first story
&lt;/h2&gt;&lt;p&gt;At my previous company (let&amp;rsquo;s call it company A), the project source code was huge—just cloning it was 40GB, and after compiling and building, it reached nearly 100GB. Every time someone coded a feature, they would usually checkout a new branch like feature_x. For small features, it was fine, but for big features that changed dozens or even hundreds of files, merging into the main branch was a nightmare because you had to resolve conflicts from other feature branches that had been merged earlier.&lt;/p&gt;
&lt;h2 id="the-second-story"&gt;The second story
&lt;/h2&gt;&lt;p&gt;At another company (company B), due to the nature of the project, it was split into 5 small teams, each with about 3 developers. Each team was responsible for a few features in a sprint. At the start of the sprint, the dev lead would create a branch for each team, and after the sprint, all 5 branches would be merged. The same problem occurred: merging code resulted in a lot of conflicts, and teams had to spend time retesting their features to ensure no bugs appeared after merging.&lt;/p&gt;
&lt;h1 id="so-what-is-trunk-based-development"&gt;So what is Trunk Based Development?
&lt;/h1&gt;&lt;p&gt;In short, &lt;strong&gt;Trunk Based Development&lt;/strong&gt; (from now on, &lt;strong&gt;TBD&lt;/strong&gt;) is a &lt;strong&gt;source-control branching model&lt;/strong&gt; where all developers work on &lt;strong&gt;a single branch&lt;/strong&gt; called the &lt;strong&gt;trunk&lt;/strong&gt; (like the trunk of a tree), avoiding the creation of huge feature branches. The &lt;strong&gt;trunk&lt;/strong&gt; branch must always be ready for release at any time. In projects, people usually name the trunk branch &lt;strong&gt;master&lt;/strong&gt; or &lt;strong&gt;dev&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;TBD is divided into two smaller models, suitable for different team sizes. Let&amp;rsquo;s explore them.&lt;/p&gt;
&lt;h2 id="tbd-for-small-teams"&gt;TBD for small teams
&lt;/h2&gt;&lt;p&gt;&lt;img src="https://namanh11611.github.io/p/trunk-based-development/small.webp"
width="728"
height="329"
srcset="https://namanh11611.github.io/p/trunk-based-development/small_hu_d07dd481d2544561.webp 480w, https://namanh11611.github.io/p/trunk-based-development/small_hu_21c6b9f7018b9d10.webp 1024w"
loading="lazy"
alt="Small TBD"
class="gallery-image"
data-flex-grow="221"
data-flex-basis="531px"
&gt;&lt;/p&gt;
&lt;p&gt;In this model, the whole dev team pushes code directly to the trunk branch. However, this model carries a big risk for code quality, since code is pushed directly without review. To use this model, devs must have strong technical skills to ensure every line they push doesn&amp;rsquo;t introduce bugs for the team.&lt;/p&gt;
&lt;p&gt;Personally, I think this model is only suitable for teams of 5 or fewer.&lt;/p&gt;
&lt;h2 id="tbd-for-large-teams"&gt;TBD for large teams
&lt;/h2&gt;&lt;p&gt;&lt;img src="https://namanh11611.github.io/p/trunk-based-development/scaled.webp"
width="726"
height="366"
srcset="https://namanh11611.github.io/p/trunk-based-development/scaled_hu_3ab14709645f5b6e.webp 480w, https://namanh11611.github.io/p/trunk-based-development/scaled_hu_7ac301b49723d29f.webp 1024w"
loading="lazy"
alt="Scaled TBD"
class="gallery-image"
data-flex-grow="198"
data-flex-basis="476px"
&gt;&lt;/p&gt;
&lt;p&gt;With TBD for a large team, feature branches are still created, but the difference is they only exist for a short time—just a few commits before merging back to the trunk branch.&lt;/p&gt;
&lt;p&gt;For example, when assigned to code the Onboarding feature, with the usual Git flow, you might:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Create a &lt;strong&gt;feature/onboarding&lt;/strong&gt; branch&lt;/li&gt;
&lt;li&gt;Code the Welcome screen and commit&lt;/li&gt;
&lt;li&gt;Code the Register screen and commit&lt;/li&gt;
&lt;li&gt;Code the Login screen and commit&lt;/li&gt;
&lt;li&gt;After finishing, create a merge request and wait for review&lt;/li&gt;
&lt;li&gt;After review, merge &lt;strong&gt;feature/onboarding&lt;/strong&gt; into &lt;strong&gt;dev&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;With this process, a merge request can contain dozens of changed files, and reviewing that much code is a nightmare. Sometimes, when you create the merge request, there are conflicts with another feature that was merged into &lt;strong&gt;dev&lt;/strong&gt; earlier, and you have to spend time resolving conflicts.&lt;/p&gt;
&lt;p&gt;&lt;img src="https://namanh11611.github.io/p/trunk-based-development/lgtm.webp"
width="825"
height="396"
srcset="https://namanh11611.github.io/p/trunk-based-development/lgtm_hu_ec49110bea29bb1a.webp 480w, https://namanh11611.github.io/p/trunk-based-development/lgtm_hu_270d7c05e594211b.webp 1024w"
loading="lazy"
alt="LGTM"
class="gallery-image"
data-flex-grow="208"
data-flex-basis="500px"
&gt;&lt;/p&gt;
&lt;p&gt;For reviewers, sometimes the only way out of the nightmare is to stop dreaming—meaning the senior dev quickly leaves a short comment &lt;strong&gt;LGTM&lt;/strong&gt; (Look good to me), and the junior dev easily merges code into &lt;strong&gt;dev&lt;/strong&gt;. Or, even if the senior dev tries to review carefully, with so many changes, some bugs still slip through. In short, this process still risks letting bugs through.&lt;/p&gt;
&lt;p&gt;With TBD, the process is adjusted a bit:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Create &lt;strong&gt;feature/welcome_screen&lt;/strong&gt; branch&lt;/li&gt;
&lt;li&gt;Code the Welcome screen, commit, and create a merge request immediately&lt;/li&gt;
&lt;li&gt;While waiting for review, code the Register screen&lt;/li&gt;
&lt;li&gt;When the Welcome screen merge request is approved, checkout &lt;strong&gt;feature/register_screen&lt;/strong&gt; and create a new merge request&lt;/li&gt;
&lt;li&gt;Do the same for the Login screen&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Now, each merge request only contains a few changed files, making it much easier for the senior dev to review.&lt;/p&gt;
&lt;p&gt;And even if the release branch has a bug and needs a hotfix, devs don&amp;rsquo;t merge directly into the release branch as in other models—everything must be merged into the trunk branch.&lt;/p&gt;
&lt;h2 id="feature-flag"&gt;Feature flag
&lt;/h2&gt;&lt;p&gt;You might wonder: doesn&amp;rsquo;t this mean the &lt;strong&gt;dev&lt;/strong&gt; branch will be full of unfinished feature code? For example, the app will show the new Welcome screen UI, while Register and Login screens still have the old UI. So how can you ensure the trunk branch is always ready for release?&lt;/p&gt;
&lt;p&gt;The key is the &lt;strong&gt;Feature flag&lt;/strong&gt;. For each unfinished feature, you add a flag so that when it&amp;rsquo;s on, all the new feature code is active, and when it&amp;rsquo;s off, the app works as before. For example:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt; 1
&lt;/span&gt;&lt;span class="lnt"&gt; 2
&lt;/span&gt;&lt;span class="lnt"&gt; 3
&lt;/span&gt;&lt;span class="lnt"&gt; 4
&lt;/span&gt;&lt;span class="lnt"&gt; 5
&lt;/span&gt;&lt;span class="lnt"&gt; 6
&lt;/span&gt;&lt;span class="lnt"&gt; 7
&lt;/span&gt;&lt;span class="lnt"&gt; 8
&lt;/span&gt;&lt;span class="lnt"&gt; 9
&lt;/span&gt;&lt;span class="lnt"&gt;10
&lt;/span&gt;&lt;span class="lnt"&gt;11
&lt;/span&gt;&lt;span class="lnt"&gt;12
&lt;/span&gt;&lt;span class="lnt"&gt;13
&lt;/span&gt;&lt;span class="lnt"&gt;14
&lt;/span&gt;&lt;span class="lnt"&gt;15
&lt;/span&gt;&lt;span class="lnt"&gt;16
&lt;/span&gt;&lt;span class="lnt"&gt;17
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-java" data-lang="java"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ONBOARDING_FLAG&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;FLAG_ON&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;displayNewWelcomeScreen&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;displayOldWelcomeScreen&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ONBOARDING_FLAG&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;FLAG_ON&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;displayNewRegisterScreen&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;displayOldRegisterScreen&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ONBOARDING_FLAG&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;FLAG_ON&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;displayNewLoginScreen&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;displayOldLoginScreen&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;Sometimes, if you want to revert a feature, just turn off its flag. Quick and easy, right?&lt;/p&gt;
&lt;h1 id="advantages"&gt;Advantages
&lt;/h1&gt;&lt;h2 id="fewer-conflicts-less-code-review-time"&gt;Fewer conflicts, less code review time
&lt;/h2&gt;&lt;p&gt;As mentioned above, TBD requires everyone to quickly merge their code into the trunk branch, which helps reduce conflicts and code review time.&lt;/p&gt;
&lt;p&gt;In company B&amp;rsquo;s case study, after seeing the current model wasn&amp;rsquo;t effective, I suggested the dev lead try TBD. As expected, in each sprint, our team hardly had to spend time resolving conflicts anymore.&lt;/p&gt;
&lt;h2 id="cicd"&gt;CI/CD
&lt;/h2&gt;&lt;p&gt;TBD is very useful for CI/CD. Now you only need to set up and run CI/CD on a single branch. Every commit is quickly checked for coding conventions and unit tests, making it easy for the team to spot and fix errors in time.&lt;/p&gt;
&lt;h2 id="ab-testing"&gt;A/B Testing
&lt;/h2&gt;&lt;p&gt;With feature flags, it&amp;rsquo;s easy to turn features on and off, making it convenient for Product Managers to set up A/B Testing. This helps measure and accurately evaluate the effectiveness of new features.&lt;/p&gt;
&lt;p&gt;In company A&amp;rsquo;s first case study, we actually applied feature flags to many important features for A/B testing.&lt;/p&gt;
&lt;h2 id="fast-product-delivery"&gt;Fast product delivery
&lt;/h2&gt;&lt;p&gt;Since the code in the trunk branch is always ready for release, I think it&amp;rsquo;s quite suitable for startups. Whenever you want to release a new version, just checkout from the trunk branch, turn on the completed feature flags, turn off the unfinished ones, and build.&lt;/p&gt;
&lt;h1 id="disadvantages"&gt;Disadvantages
&lt;/h1&gt;&lt;h2 id="too-much-leftover-code"&gt;Too much leftover code
&lt;/h2&gt;&lt;p&gt;On the flip side, using &lt;strong&gt;feature flags&lt;/strong&gt; and too many if-else statements can make your code more complex. Sometimes, unclear if-else logic can make it even harder for reviewers to understand.&lt;/p&gt;
&lt;p&gt;And when a feature is released, you have to go back and remove the old code flow, like the &lt;code&gt;displayOldWelcomeScreen&lt;/code&gt;, &lt;code&gt;displayOldRegisterScreen&lt;/code&gt;, and &lt;code&gt;displayOldLoginScreen&lt;/code&gt; functions in the example above.&lt;/p&gt;
&lt;h2 id="not-suitable-for-teams-with-many-juniors"&gt;Not suitable for teams with many juniors
&lt;/h2&gt;&lt;p&gt;Constantly creating merge requests requires devs to be careful, ensuring every commit passes all coding convention checks and unit tests locally, and especially that there are no critical bugs. If a bug on the trunk branch prevents the app from opening, it blocks everyone else.&lt;/p&gt;
&lt;p&gt;If using feature flags, devs also need to test both the old and new flows to ensure both work correctly.&lt;/p&gt;
&lt;p&gt;So I think a team mostly made up of seniors is more suitable for this model.&lt;/p&gt;
&lt;h1 id="conclusion"&gt;Conclusion
&lt;/h1&gt;&lt;p&gt;TBD is a workflow I&amp;rsquo;ve applied at several companies and found it quite effective for my team&amp;rsquo;s situation. You can consider the pros and cons and try it with your team.&lt;/p&gt;
&lt;h1 id="reference"&gt;Reference
&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class="link" href="https://trunkbaseddevelopment.com/" target="_blank" rel="noopener"
&gt;https://trunkbaseddevelopment.com/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description></item></channel></rss>
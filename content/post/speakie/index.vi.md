---
title: "Chuy·ªán √°p d·ª•ng thu·∫≠t to√°n LeetCode v√†o ·ª©ng d·ª•ng h·ªçc ti·∫øng Anh Speakie"
description: "C√≥ m·ªôt v·∫•n ƒë·ªÅ anh em th∆∞·ªùng tranh c√£i l√¢u nay l√†: C√≥ ph·∫£i c√†y thu·∫≠t to√°n ch·ªâ ƒë·ªÉ chu·∫©n b·ªã cho v√≤ng coding interview ch·ª© ch·∫≥ng √°p d·ª•ng ƒë∆∞·ª£c m·∫•y trong c√¥ng vi·ªác? V·∫≠y th√¨ h√£y c√πng m√¨nh t√¨m hi·ªÉu xem thu·∫≠t to√°n LeetCode c√≥ th·ªÉ √°p d·ª•ng v√†o ·ª©ng d·ª•ng h·ªçc ti·∫øng Anh Speakie nh∆∞ th·∫ø n√†o nh√©!"
date: 2025-05-11T01:00:00+07:00
slug: speakie
image: speakie.webp
toc: true
categories: [Technical]
tags: [Algorithm, LeetCode, Speakie, Java]
---

C√≥ m·ªôt v·∫•n ƒë·ªÅ anh em th∆∞·ªùng tranh c√£i l√¢u nay l√†: *"C√≥ ph·∫£i **c√†y thu·∫≠t to√°n** ch·ªâ ƒë·ªÉ **chu·∫©n b·ªã cho v√≤ng coding interview** ch·ª© ch·∫≥ng **√°p d·ª•ng ƒë∆∞·ª£c m·∫•y trong c√¥ng vi·ªác**?"*. T·∫•t nhi√™n v·∫´n c√≥ nh·ªØng v√≠ d·ª• ngay tr∆∞·ªõc m·∫Øt ch√∫ng ta nh∆∞ c√°c **·ª©ng d·ª•ng g·ªçi xe** ch·∫≥ng h·∫°n, ch·∫Øc ch·∫Øn h·ªç ph·∫£i √°p d·ª•ng **thu·∫≠t to√°n t√¨m ƒë∆∞·ªùng**, m·ªôt thu·∫≠t to√°n kinh ƒëi·ªÉn m√† anh em ƒë√£ ƒë∆∞·ª£c h·ªçc t·ª´ h·ªìi sinh vi√™n. V·∫≠y nh∆∞ng c√¥ng vi·ªác vi·∫øt c√°c thu·∫≠t to√°n quan tr·ªçng ·∫•y d∆∞·ªùng nh∆∞ ch·ªâ d√†nh cho **s·ªë √≠t c√°c b√°c developer ·ªü level cao**, c√≤n ƒëa s·ªë anh em v·∫´n l√†m nh·ªØng vi·ªác ƒë∆°n gi·∫£n h∆°n, kh√¥ng bi·∫øt ƒë·∫øn bao gi·ªù m·ªõi c√≥ c∆° h·ªôi √°p d·ª•ng ki·∫øn th·ª©c m√† m√¨nh ƒë√£ v·∫•t v·∫£ c√†y cu·ªëc ƒë·ªÉ t√≠ch l≈©y. C√≥ ph·∫£i ch√∫ng ta ƒëang **ph√≠ ph·∫°m m·ªôt l∆∞·ª£ng l·ªõn th·ªùi gian** kh√¥ng?

V·∫≠y th√¨ b√†i vi·∫øt h√¥m nay s·∫Ω chia s·∫ª v·ªÅ v·∫•n ƒë·ªÅ m√† m√¨nh g·∫∑p ph·∫£i trong d·ª± √°n, v√† c√°ch m√† qu√° tr√¨nh luy·ªán **LeetCode** ƒë√£ gi√∫p m√¨nh gi·∫£i quy·∫øt n√≥ nh∆∞ th·∫ø n√†o. M√¨nh kh√¥ng c√≥ √Ω khoe khoang g√¨, v√¨ ƒë√¢y ch·ªâ l√† m·ªôt thu·∫≠t to√°n nh·ªè, kh√¥ng cao si√™u ƒë·∫øn m·ª©c **thay ƒë·ªïi th·∫ø gi·ªõi**. Ch·ªâ l√† k·ªÉ l·∫°i ƒë·ªÉ anh em th·∫•y: *"Oh, h√≥a ra c√†y thu·∫≠t to√°n c≈©ng c√≥ nh·ªØng l√∫c √°p d·ª•ng v√†o d·ª± √°n th·ª±c t·∫ø nh∆∞ v·∫≠y"* üòú

# B√†i to√°n ƒë·∫∑t ra

Chuy·ªán l√†, m√¨nh ƒëang x√¢y d·ª±ng m·ªôt ·ª©ng d·ª•ng h·ªçc ti·∫øng Anh giao ti·∫øp t√™n [**Speakie**](https://speakie.xyz/), ch·ªß y·∫øu ƒë·ªÉ gi·∫£i quy·∫øt pain point c·ªßa m√¨nh, ƒë√≥ l√† kh√¥ng b·∫≠t ra ƒë∆∞·ª£c c·∫£ c√¢u khi giao ti·∫øp, m√† m√¨nh th∆∞·ªùng b·ªã kh·ª±ng l·∫°i ƒë·ªÉ nghƒ© ng·ªØ ph√°p xem ƒë√∫ng ch∆∞a. V·∫≠y n√™n c√°c b√†i h·ªçc trong app ƒë∆∞·ª£c m√¨nh x√¢y d·ª±ng d·ª±a tr√™n c√°c **m·∫´u c√¢u giao ti·∫øp ph·ªï bi·∫øn** trong ƒë·ªùi s·ªëng.

> M√¨nh xin 5 gi√¢y d√†nh cho qu·∫£ng c√°o:
>
> Android: https://play.google.com/store/apps/details?id=com.areser.speakie
>
> iOS: https://apps.apple.com/app/speakie/id6593695505

V·∫≠y b√†i to√°n ƒë·∫∑t ra l√† khi user n√≥i m·ªôt c√¢u, m√¨nh ph·∫£i so s√°nh v·ªõi c√°c t·ª´ trong c√¢u m·∫´u, t·ª´ n√†o ƒë√∫ng th√¨ **t√¥ m√†u xanh**, t·ª´ n√†o sai th√¨ **t√¥ m√†u ƒë·ªè**. V√† ph·∫£i ƒë·∫£m b·∫£o t√¥ xanh ƒë∆∞·ª£c c√†ng nhi·ªÅu t·ª´ c√†ng t·ªët ƒë·ªÉ c√≤n khuy·∫øn kh√≠ch user.

> V√≠ d·ª•:
>
> **C√¢u m·∫´u:** Hello World! Welcome to my app Speakie.
>
> **C√¢u user n√≥i:** Hello Henry! Welcome to my world.
>
> ==> L√∫c n√†y, c√¢u m·∫´u s·∫Ω ƒë∆∞·ª£c t√¥ xanh c√°c t·ª´ "Hello", "Welcome", "to", "my".

M·ªôt ph∆∞∆°ng √°n ng√¢y th∆° ƒë·ªÉ gi·∫£i quy·∫øt l√† d√πng `Set` ƒë·ªÉ l∆∞u c√°c t·ª´ trong c√¢u user n√≥i, sau ƒë√≥ check t·ª´ng t·ª´ trong c√¢u m·∫´u, `Set` ch·ª©a t·ª´ n√†o th√¨ t√¥ xanh, kh√¥ng c√≥ th√¨ t√¥ ƒë·ªè. V·∫≠y nh∆∞ng c√°ch n√†y s·∫Ω kh√¥ng ƒë·∫£m b·∫£o th·ª© t·ª± xu·∫•t hi·ªán c·ªßa c√°c t·ª´. V√≠ d·ª• nh∆∞ t·ª´ "world" xu·∫•t hi·ªán kh√¥ng ƒë√∫ng th·ª© t·ª± nh∆∞ng n·∫øu √°p d·ª•ng c√°ch n√†y th√¨ n√≥ v·∫´n s·∫Ω ƒë∆∞·ª£c t√¥ xanh to√†n b·ªô.

Trong qu√° tr√¨nh l√†m, m√¨nh th·∫•y m·ªôt s·ªë app h·ªçc ti·∫øng Anh kh√° n·ªïi ti·∫øng c√≤n ƒëang m·∫Øc l·ªói sai nh∆∞ tr√™n, c√°c b·∫°n c√≥ th·ªÉ test b·∫±ng c√°ch c·ªë t√¨nh n√≥i sai th·ª© t·ª± s·∫Ω ph√°t hi·ªán ra üòâ

# LeetCode problem

Khi nghƒ© gi·∫£i ph√°p, m√¨nh nh·ªõ ngay ƒë·∫øn b√†i [Longest Common Subsequence](https://leetcode.com/problems/longest-common-subsequence). ƒê·ªÅ b√†i nh∆∞ sau:

> Cho 2 string `text1` v√† `text2`, return ƒë·ªô d√†i subsequence chung d√†i nh·∫•t c·ªßa ch√∫ng. N·∫øu kh√¥ng c√≥ subsequence chung, return 0.
>
> Subsequence c·ªßa string l√† m·ªôt string m·ªõi ƒë∆∞·ª£c t·∫°o t·ª´ string g·ªëc b·∫±ng c√°ch x√≥a m·ªôt v√†i k√Ω t·ª± (ho·∫∑c kh√¥ng x√≥a k√Ω t·ª± n√†o) m√† kh√¥ng l√†m thay ƒë·ªïi th·ª© t·ª± c·ªßa c√°c k√Ω t·ª± c√≤n l·∫°i.
>
> V√≠ d·ª•, "ace" l√† m·ªôt subsequence c·ªßa "abcde".

## Base solution

B√†i n√†y c·∫ßn √°p d·ª•ng **Quy ho·∫°ch ƒë·ªông** (Dynamic Programming) ƒë·ªÉ gi·∫£i. V√≠ d·ª• v·ªõi `text1` = "**XMJYAUZ**", `text2` = "**MZJAWXU**", ch√∫ng ta c·∫ßn t·∫°o 1 b·∫£ng 2 chi·ªÅu ƒë·ªÉ l∆∞u ƒë·ªô d√†i subsequence chung d√†i nh·∫•t c·ªßa 2 string khi duy·ªát t·ª´ ƒë·∫ßu ƒë·∫øn cu·ªëi nh∆∞ sau.

![Solution 2D Array](https://images.viblo.asia/aca21a7a-f510-4cd5-b3f6-22b33c64b7b8.png)

B·∫°n c√≥ th·ªÉ hi·ªÉu r·∫±ng:

* H√†ng 0 l√† khi `text1` empty, `text2` = "MZJAWXU", kh√¥ng c√≥ subsequence => return **0**
* H√†ng 1 l√† khi `text1` = "X", `text2` = "MZJAWXU", subsequence = "**X**" => return **1**
* H√†ng 2 l√† khi `text1` = "XM", `text2` = "MZJAWXU", subsequence = "**X**" ho·∫∑c "**M**" => return **1**
* H√†ng 3 l√† khi `text1` = "XMJ", `text2` = "MZJAWXU", subsequence = "**MJ**" => return **2**
* ...

T·ªïng qu√°t, khi x√©t k√Ω t·ª± th·ª© `i` c·ªßa `text1` v√† k√Ω t·ª± th·ª© `j` c·ªßa `text2`:

* N·∫øu `text1[i]` == `text2[j]` th√¨ `length[i][j]` = `length[i - 1][j - 1]` + 1
* N·∫øu `text1[i]` != `text2[j]` th√¨ `length[i][j]` = max(`length[i - 1][j]`,`length[i][j - 1]`)

To√†n b·ªô source code c·ªßa ch√∫ng ta nh∆∞ sau:

```java
public int longestCommonSubsequence(String text1, String text2) {
    int n1 = text1.length(), n2 = text2.length();
    int[][] length = new int[n1 + 1][n2 + 1];
    for (int i = 1; i <= n1; ++i) {
        for (int j = 1; j <= n2; ++j) {
            if (text1.charAt(i - 1) == text2.charAt(j - 1)) {
                length[i][j] = length[i - 1][j - 1] + 1;
            } else {
                length[i][j] = Math.max(length[i - 1][j], length[i][j - 1]);
            }
        }
    }
    return length[n1][n2];
}
```

## Space Optimization solution

C√°ch tr√™n l√† d·ªÖ hi·ªÉu nh·∫•t v√† b√°m s√°t v·ªõi ph·∫ßn ph√¢n t√≠ch c·ªßa ch√∫ng ta. Tuy nhi√™n, v·∫´n c√≤n m·ªôt c√°ch t·ªëi ∆∞u h∆°n v·ªÅ b·ªô nh·ªõ, b·∫°n c√≥ th·ªÉ ƒë·ªçc th√™m ·ªü ph·∫ßn [Solutions](https://leetcode.com/problems/longest-common-subsequence/solutions/351689/java-python-3-two-dp-codes-of-o-mn-o-min-m-n-spaces-w-picture-and-analysis/).

Khi duy·ªát row `i`, ch√∫ng ta ch·ªâ c·∫ßn c√°c gi√° tr·ªã t·ª´ row `i - 1` c√πng v·ªõi gi√° tr·ªã c·ªßa √¥ `length[i][j - 1]`. V√¨ v·∫≠y, thay v√¨ d√πng b·∫£ng 2 chi·ªÅu, ch√∫ng ta ch·ªâ c·∫ßn 1 array v·ªõi th√™m 2 bi·∫øn `prevRowCol`, `prevRow` nh∆∞ sau:

![Solution 1D Array](https://images.viblo.asia/2faf9d89-c5c2-4b52-a25c-4a7d02a4a93b.png)

```java
public int longestCommonSubsequence(String text1, String text2) {
    int n1 = text1.length(), n2 = text2.length();
    if (n1 < n2) {
        return longestCommonSubsequence(text2, text1);
    }
    int[] length = new int[n2 + 1];
    for (int i = 1; i <= n1; ++i) {
        for (int j = 1, prevRow = 0, prevRowCol = 0; j <= n2; ++j) {
            prevRowCol = prevRow;
            prevRow = length[j];
            if (text1.charAt(i - 1) == text2.charAt(j - 1)) {
                length[j] = prevRowCol + 1;
            } else {
                length[j] = Math.max(length[j - 1], prevRow);
            }
        }
    }
    return length[n2];
}
```

# √Åp d·ª•ng v√†o b√†i to√°n

B·∫°n th·∫•y s·ª± li√™n quan c·ªßa n√≥ v·ªõi b√†i to√°n ban ƒë·∫ßu ch·ª©? Ch√∫ng ta ch·ªâ c·∫ßn **thay c√°c k√Ω t·ª± b·∫±ng c√°c t·ª´** l√† s·∫Ω t√¨m ƒë∆∞·ª£c nh·ªØng **t·ª´ chung** trong c√¢u m·∫´u v√† c√¢u m√† user n√≥i. Tuy nhi√™n c√≥ m·ªôt v·∫•n ƒë·ªÅ l√† LeetCode problem tr√™n ch·ªâ ƒë∆∞a ra **ƒë·ªô d√†i c·ªßa subsequence**, trong khi ch√∫ng ta mu·ªën t√¨m c·ª• th·ªÉ xem **subsequence ƒë√≥ g·ªìm nh·ªØng t·ª´ n√†o** ƒë·ªÉ c√≤n t√¥ m√†u.

## Boolean array

√ù nghƒ© ban ƒë·∫ßu l√≥e ra trong ƒë·∫ßu m√¨nh l√† d√πng `Boolean array` c√≥ ƒë·ªô d√†i b·∫±ng c√¢u m·∫´u ƒë·ªÉ l∆∞u, t·ª´ n√†o xu·∫•t hi·ªán th√¨ set l√† `true`, t·ª´ n√†o kh√¥ng th√¨ set l√† `false`. Tuy nhi√™n v·∫•n ƒë·ªÅ ph√°t sinh l√† t·∫°i m·ªói th·ªùi ƒëi·ªÉm c√¢n nh·∫Øc `length[i][j]` = max(`length[i - 1][j]`,`length[i][j - 1]`), ch√∫ng ta c·∫ßn c√≥ **`Boolean array` c·ªßa c·∫£ 2 √¥ `[i - 1][j]` v√† `[i][j - 1]`** ƒë·ªÉ set **`Boolean array` cho √¥ `[i][j]`** theo √¥ c√≥ `length` l·ªõn h∆°n. ƒêi·ªÅu n√†y d·∫´n ƒë·∫øn ch√∫ng ta c·∫ßn th√™m m·ªôt array t∆∞∆°ng t·ª± nh∆∞ array `length` ·ªü tr√™n, nh∆∞ng thay v√¨ m·ªói ph·∫ßn t·ª≠ l√† m·ªôt s·ªë `int` th√¨ s·∫Ω l√† m·ªôt `Boolean array`. Nh∆∞ v·∫≠y n√≥ s·∫Ω l√† m·ªôt `Boolean array 2 chi·ªÅu`.

```java
// ƒê·ªÉ cho ƒë∆°n gi·∫£n, sample (c√¢u m·∫´u) v√† input (c√¢u user n√≥i) ƒë√£ ƒë∆∞·ª£c chuy·ªÉn
// t·ª´ c√¢u th√†nh list c√°c t·ª´, ch·ªØ hoa th√†nh ch·ªØ th∆∞·ªùng, b·ªè d·∫•u...
public void displaySampleSentence(String[] sample, String[] input) {
    int sampleLength = sample.length, inputLength = input.length;
    int[] length = new int[inputLength + 1];
    boolean[][] match = new boolean[inputLength + 1][sampleLength + 1];
    boolean[] prevRowMatch = new boolean[sampleLength + 1];
    boolean[] prevRowColMatch = new boolean[sampleLength + 1];
    
    for (int i = 1; i <= sampleLength; ++i) {
        for (int j = 1, prevRow = 0, prevRowCol = 0; j <= inputLength; ++j) {
            prevRowCol = prevRow;
            prevRow = length[j];
            prevRowColMatch = prevRowMatch;
            prevRowMatch = match[j];
            if (sample[i - 1].equals(input[j - 1])) {
                length[j] = prevRowCol + 1;
                match[j] = prevRowColMatch;
                match[j][i] = true;
            } else if (length[j - 1] >= prevRow) {
                length[j] = length[j - 1];
                match[j] = match[j - 1];
            }
        }
    }
    for (int i = 1; i <= sampleLength; ++i) {
        if (match[inputLength][i]) {
            // Display sample[i - 1] as green word
        } else {
            // Display sample[i - 1] as red word
        }
    }
}
```

## Integer v√† Bit manipulation

ƒê·ªÉ ƒë∆°n gi·∫£n v√† g·ªçn nh·∫π h∆°n, m√¨nh nghƒ© ƒë·∫øn vi·ªác d√πng m·ªôt s·ªë `int` thay cho `Boolean array`, v√† d√πng c√°c ph√©p to√°n v·ªõi **bit**, set bit = 1 thay cho bi·∫øn `true`, set bit = 0 thay cho bi·∫øn `false`. V·ªõi Android v√† iOS, `int` trong Dart d√πng bi·∫øn 64-bit. N·∫øu m·ªói bit t∆∞∆°ng ·ª©ng v·ªõi m·ªôt t·ª´, ch√∫ng ta c√≥ th·ªÉ l∆∞u ƒë∆∞·ª£c c√¢u g·ªìm t·ªëi ƒëa 64 t·ª´, v·∫≠y l√† qu√° ƒë·ªß cho app c·ªßa m√¨nh.

Nh·∫Øc l·∫°i m·ªôt ch√∫t v·ªÅ c√°c ph√©p to√°n v·ªõi bit. ƒê·ªÉ set 1 bit ·ªü v·ªã tr√≠ th·ª© `i` th√†nh `true`, ch√∫ng ta c√≥ th·ªÉ d√πng ph√©p to√°n `OR` v√† `SHIFT LEFT` nh∆∞ sau:

```java
match |= 1 << i;

// V√≠ d·ª• match = 1, i = 3
match  = 0001
1 << i = 1000
match | (1 << i) = 1001 // => match = 9
// Nh∆∞ v·∫≠y ch√∫ng ta ƒë√£ set bit th·ª© 3 t·ª´ ph·∫£i sang tr√°i (0th index)
// th√†nh gi√° tr·ªã 1 (TRUE)
```

ƒê·ªÉ get value c·ªßa bit th·ª© `i`, ch√∫ng ta d√πng ph√©p to√°n `SHIFT RIGHT` v√† `AND` nh∆∞ sau:

```java
int value = (match >> i) & 1;

// V√≠ d·ª• v·ªõi match = 25, i = 3
match      = 0001 1001
match >> i = 0000 0011
(match >> i) & 1 = 1
// Nh∆∞ v·∫≠y value c·ªßa bit th·ª© 3 t·ª´ ph·∫£i sang tr√°i (0th index) l√† 1 (TRUE)
```

√Åp d·ª•ng v√†o c√°ch gi·∫£i b√™n tr√™n, ch√∫ng ta c√≥:

```java
public void displaySampleSentence(String[] sample, String[] input) {
    int sampleLength = sample.length, inputLength = input.length;
    int[] length = new int[inputLength + 1];
    int[] match = new int[inputLength + 1];
    int prevRowMatch = 0, prevRowColMatch = 0;
    
    for (int i = 1; i <= sampleLength; ++i) {
        for (int j = 1, prevRow = 0, prevRowCol = 0; j <= inputLength; ++j) {
            prevRowCol = prevRow;
            prevRow = length[j];
            prevRowColMatch = prevRowMatch;
            prevRowMatch = match[j];
            if (sample[i - 1].equals(input[j - 1])) {
                length[j] = prevRowCol + 1;
                match[j] = prevRowColMatch;
                match[j][i] = true;
            } else if (length[j - 1] >= prevRow) {
                length[j] = length[j - 1];
                match[j] = match[j - 1];
            }
        }
    }
    for (int i = 1; i <= sampleLength; ++i) {
        if (match[inputLength][i]) {
            // Display sample[i - 1] as green word
        } else {
            // Display sample[i - 1] as red word
        }
    }
}
```

# L·ªùi k·∫øt

**Thu·∫≠t to√°n** v·∫´n l√† m·ªôt y·∫øu t·ªë n·ªÅn t·∫£ng trong ng√†nh l·∫≠p tr√¨nh n√†y. Qua th·ªùi gian, c√¥ng ngh·ªá n√†y c√≥ th·ªÉ l·∫°c h·∫≠u, c√¥ng ngh·ªá kia c√≥ th·ªÉ l√™n ng√¥i, nh∆∞ng thu·∫≠t to√°n th√¨ v·∫´n c√≤n ƒë√≥, tr∆° gan c√πng tu·∫ø nguy·ªát.

Qua v√≠ d·ª• th√∫ v·ªã n√†y, hy v·ªçng anh em th·∫•y h·ª©ng th√∫ h∆°n v·ªõi vi·ªác h·ªçc thu·∫≠t to√°n v√† √°p d·ª•ng trong c√°c b√†i to√°n th·ª±c t·∫ø.

# Reference

* https://leetcode.com/problems/longest-common-subsequence
* https://wikipedia.org/wiki/Longest_common_subsequence
* https://dart.dev/guides/language/numbers

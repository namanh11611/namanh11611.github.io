<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Flow on Henry Techie</title><link>https://namanh11611.github.io/vi/tags/flow/</link><description>Recent content in Flow on Henry Techie</description><generator>Hugo -- gohugo.io</generator><language>vi</language><lastBuildDate>Sun, 18 Aug 2024 06:00:00 +0700</lastBuildDate><atom:link href="https://namanh11611.github.io/vi/tags/flow/index.xml" rel="self" type="application/rss+xml"/><item><title>Kotlin Flow cheat sheet phần 3: SharedFlow và StateFlow</title><link>https://namanh11611.github.io/vi/p/kotlin-flow-cheat-sheet-3/</link><pubDate>Sun, 18 Aug 2024 06:00:00 +0700</pubDate><guid>https://namanh11611.github.io/vi/p/kotlin-flow-cheat-sheet-3/</guid><description>&lt;img src="https://namanh11611.github.io/p/kotlin-flow-cheat-sheet-3/cheat_sheet.webp" alt="Featured image of post Kotlin Flow cheat sheet phần 3: SharedFlow và StateFlow" />&lt;p>&lt;em>Photo by &lt;a class="link" href="https://unsplash.com/@anacruzbaeza?utm_content=creditCopyText&amp;amp;utm_medium=referral&amp;amp;utm_source=unsplash" target="_blank" rel="noopener"
>Ana Cruz&lt;/a> on &lt;a class="link" href="https://unsplash.com/photos/photographie-a-plat-de-papiers-dimprimante-blancs-S0qh0ONK-AE?utm_content=creditCopyText&amp;amp;utm_medium=referral&amp;amp;utm_source=unsplash" target="_blank" rel="noopener"
>Unsplash&lt;/a>&lt;/em>&lt;/p>
&lt;p>Tiếp nối serie &lt;strong>Kotlin cheat sheet&lt;/strong>, chúng ta cùng đi đến với cheat sheet cuối cùng dành cho &lt;strong>SharedFlow&lt;/strong> và &lt;strong>StateFlow&lt;/strong>.&lt;/p>
&lt;p>&lt;strong>SharedFlow&lt;/strong> và &lt;strong>StateFlow&lt;/strong> là hai loại flow đặc biệt trong Kotlin Flow, cung cấp các tính năng mạnh mẽ cho việc chia sẻ trạng thái và sự kiện giữa các thành phần khác nhau trong ứng dụng. Trong phần cuối của loạt bài viết này, chúng ta sẽ tìm hiểu sâu về cách sử dụng SharedFlow và StateFlow, những lợi ích của chúng, và cách tích hợp vào ứng dụng Android của bạn để xử lý luồng dữ liệu một cách hiệu quả và mượt mà hơn.&lt;/p>
&lt;p>Bạn có thể đọc toàn bộ serie tại đây:&lt;/p>
&lt;ul>
&lt;li>&lt;a class="link" href="../kotlin-coroutines-cheat-sheet" >Kotlin Coroutines cheat sheet nâng cao dành cho Android Engineer&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="../kotlin-flow-cheat-sheet-1" >Kotlin Flow cheat sheet phần 1: Channel&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="../kotlin-flow-cheat-sheet-2" >Kotlin Flow cheat sheet phần 2: Flow&lt;/a>&lt;/li>
&lt;li>Kotlin Flow cheat sheet phần 3: SharedFlow và StateFlow&lt;/li>
&lt;/ul>
&lt;h1 id="sharedflow">SharedFlow
&lt;/h1>&lt;h2 id="nguyên-tắc-chính">Nguyên tắc chính
&lt;/h2>&lt;ul>
&lt;li>Là một &lt;strong>hot stream&lt;/strong>.&lt;/li>
&lt;li>Có thể có nhiều receiver và tất cả chúng sẽ nhận được cùng một giá trị.&lt;/li>
&lt;li>Hữu ích khi bạn cần truyền các giá trị tới nhiều consumer hoặc muốn chia sẻ trạng thái/sự kiện giữa các phần khác nhau trong ứng dụng của mình.&lt;/li>
&lt;li>Không bao giờ hoàn thành cho đến khi chúng ta close toàn bộ scope.&lt;/li>
&lt;li>Có phiên bản có thể thay đổi &lt;code>MutableSharedFlow&lt;/code> cho phép chúng ta cập nhật state bằng cách emit các giá trị mới với suspend function &lt;code>emit&lt;/code>.&lt;/li>
&lt;li>Chúng ta cũng có thể sử dụng phiên bản non suspend &lt;code>tryEmit&lt;/code>.&lt;/li>
&lt;li>Hỗ trợ cấu hình replay và tràn buffer.&lt;/li>
&lt;li>Tất cả các phương thức của shared flow đều thread-safe và có thể được gọi một cách an toàn từ các coroutine đồng thời mà không cần đồng bộ hóa bên ngoài.&lt;/li>
&lt;/ul>
&lt;h2 id="các-tham-số-cấu-hình">Các tham số cấu hình
&lt;/h2>&lt;p>Kotlin đang cung cấp cho chúng ta một phương thức hữu ích để tạo &lt;code>MutableSharedFlow&lt;/code> và xác định cách chúng ta muốn buffer hoạt động:&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;span class="lnt">9
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="k">public&lt;/span> &lt;span class="k">fun&lt;/span> &lt;span class="p">&amp;lt;&lt;/span>&lt;span class="nc">T&lt;/span>&lt;span class="p">&amp;gt;&lt;/span> &lt;span class="nf">MutableSharedFlow&lt;/span>&lt;span class="p">(&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// số lượng giá trị được replayed cho subscriber mới
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">replay&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">Int&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="m">0&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// số lượng giá trị được lưu vào buffer ngoài `replay`
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">extraBufferCapacity&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">Int&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="m">0&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// hành động khi tràn buffer
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// Các giá trị: SUSPEND, DROP_OLDEST, DROP_LATEST
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">onBufferOverflow&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">BufferOverflow&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nc">BufferOverflow&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">SUSPEND&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">):&lt;/span> &lt;span class="n">MutableSharedFlow&lt;/span>&lt;span class="p">&amp;lt;&lt;/span>&lt;span class="n">T&lt;/span>&lt;span class="p">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="sharein">shareIn
&lt;/h2>&lt;ul>
&lt;li>Biến đổi &lt;code>Flow&lt;/code> thành &lt;code>SharedFlow&lt;/code>.&lt;/li>
&lt;li>Hữu ích khi chúng ta muốn biến một flow thành nhiều flow&lt;/li>
&lt;li>Yêu cầu coroutine scope làm tham số đầu tiên (scope) để bắt đầu coroutine và collect phần tử của flow.&lt;/li>
&lt;li>Tham số thứ hai &lt;code>started&lt;/code> xác định thời điểm SharedFlow sẽ bắt đầu listen giá trị do flow emit. Nó lấy một object &lt;code>SharingStarted&lt;/code>.&lt;/li>
&lt;li>Tham số thứ ba, &lt;code>replay&lt;/code>, (mặc định là 0) xác định số lượng giá trị được replay cho subscriber mới.&lt;/li>
&lt;/ul>
&lt;h3 id="sharingstarted-option">&lt;code>SharingStarted&lt;/code> option
&lt;/h3>&lt;ul>
&lt;li>&lt;code>SharingStarted.Eagerly&lt;/code>: bắt đầu listen các phần tử ngay lập tức và không bao giờ dừng lại cho đến khi scope bị cancel.&lt;/li>
&lt;li>&lt;code>SharingStarted.Lazily&lt;/code>: bắt đầu listen khi subscriber đầu tiên xuất hiện và không bao giờ dừng cho đến khi scope bị cancel.&lt;/li>
&lt;li>&lt;code>SharingStarted.WhileSubscribed()&lt;/code>: bắt đầu listen khi subscriber đầu tiên xuất hiện và dừng ngay khi subscriber cuối cùng biến mất. Chúng ta config delay (tính bằng mili giây) giữa thời điểm subscriber cuối cùng biến mất và thời điểm dừng coroutine bằng tham số &lt;code>stopTimeoutMillis&lt;/code>.&lt;/li>
&lt;/ul>
&lt;p>Lưu ý về &lt;code>WhileSubscribed&lt;/code>: nếu bạn mở một Intent mới từ màn hình của mình, chẳng hạn như ứng dụng máy ảnh, màn hình của bạn sẽ bị tạm dừng và do đó SharedFlow của bạn sẽ không còn subscriber nữa và sẽ ngừng emit. Khi quay lại màn hình ban đầu, bạn sẽ subscribe lại màn hình của mình và có thể chạy lại tác vụ bên trong flow của mình. Điều này có thể gây ra sự cố hoặc trigger lại một tác vụ không cần thiết.&lt;/p>
&lt;p>Lưu ý về &lt;code>SharingStarted.Eagerly&lt;/code> và &lt;code>SharingStarted.Lazily&lt;/code>: nếu bạn đang sử dụng &lt;code>ViewModelScope&lt;/code> hoặc &lt;code>LifecycleScope&lt;/code> thì &lt;code>SharedFlow&lt;/code> sẽ ngừng gửi các phần tử khi màn hình bị destroy.&lt;/p>
&lt;h2 id="biến-flow-thành-sharedflow">Biến flow thành SharedFlow
&lt;/h2>&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// từ một viewModel hoặc một class có lifeCycleScope
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="n">myFlow&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">shareIn&lt;/span>&lt;span class="p">(&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">scope&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">viewModelScope&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">started&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nc">SharingStarted&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">Lazily&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// từ một class không có lifeCycleScope (repository hoặc use case)
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">suspend&lt;/span> &lt;span class="k">fun&lt;/span> &lt;span class="nf">myFunction&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">coroutineScope&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">myFlow&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">shareIn&lt;/span>&lt;span class="p">(&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">scope&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">started&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nc">SharingStarted&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">Lazily&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="use-case-observe-database-thay-đổi-từ-nhiều-vị-trí">Use case: Observe database thay đổi từ nhiều vị trí
&lt;/h2>&lt;p>Nếu bạn sử dụng &lt;strong>Room&lt;/strong> cho cơ sở dữ liệu của mình thì bạn có thể đã biết rằng nó đã hỗ trợ Flow. Vì vậy, bạn có thể observe các thay đổi trong database của mình và nhận dữ liệu mới ngay khi có. Nhưng việc đọc dữ liệu từ disk có thể khá nặng. Nếu cần nhận dữ liệu ở nhiều màn hình, bạn có thể sử dụng &lt;code>SharedFlow&lt;/code> để tránh phải fetch dữ liệu cho mọi màn hình.&lt;/p>
&lt;p>Trong ví dụ này, mình sẽ trình bày cách để fetch một &lt;code>UserSettings&lt;/code> một lần nhưng vẫn nhận được update trên nhiều màn hình:&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// DAO đơn giản để fetch dữ liệu từ Room
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="nd">@Dao&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">interface&lt;/span> &lt;span class="nc">UserSettingsDao&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// fetch tất cả user settings từ database và emit một flow
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="nd">@Query&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;SELECT * FROM user_settings&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">fun&lt;/span> &lt;span class="nf">getAll&lt;/span>&lt;span class="p">():&lt;/span> &lt;span class="n">Flow&lt;/span>&lt;span class="p">&amp;lt;&lt;/span>&lt;span class="n">List&lt;/span>&lt;span class="p">&amp;lt;&lt;/span>&lt;span class="n">UserSettings&lt;/span>&lt;span class="p">&amp;gt;&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">class&lt;/span> &lt;span class="nc">UserSettingsRepository&lt;/span> &lt;span class="nd">@Inject&lt;/span> &lt;span class="k">constructor&lt;/span>&lt;span class="p">(&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">private&lt;/span> &lt;span class="k">val&lt;/span> &lt;span class="py">dao&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">UserSettingsDao&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// Chúng ta chỉ đọc từ DB một lần và tất cả receiver sẽ nhận được
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// data được tính toán ở đây.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">suspend&lt;/span> &lt;span class="k">fun&lt;/span> &lt;span class="nf">getAll&lt;/span>&lt;span class="p">():&lt;/span> &lt;span class="n">SharedFlow&lt;/span>&lt;span class="p">&amp;lt;&lt;/span>&lt;span class="n">List&lt;/span>&lt;span class="p">&amp;lt;&lt;/span>&lt;span class="n">UserSettings&lt;/span>&lt;span class="p">&amp;gt;&amp;gt;&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">coroutineScope&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">dao&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">getAll&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">shareIn&lt;/span>&lt;span class="p">(&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// truyền xuống scope
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">scope&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="k">this&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// chỉ bắt đầu emit khi chúng ta có receiver
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">started&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nc">SharingStarted&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">Lazily&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// replay phần tử mới nhất khi một receiver mới subscribe nó
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">replay&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="m">1&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h1 id="stateflow">StateFlow
&lt;/h1>&lt;h2 id="nguyên-tắc-chính-1">Nguyên tắc chính
&lt;/h2>&lt;ul>
&lt;li>Hoạt động tương tự như a &lt;code>SharedFlow&lt;/code> với tham số &lt;code>replay&lt;/code> được đặt thành 1.&lt;/li>
&lt;li>Luôn chỉ lưu trữ một giá trị.&lt;/li>
&lt;li>Giá trị được lưu trữ có thể được truy cập bằng thuộc tính &lt;code>value&lt;/code>.&lt;/li>
&lt;li>Chúng ta cần đặt giá trị ban đầu trong constructor.&lt;/li>
&lt;li>Sự thay thế hiện đại cho &lt;code>LiveData&lt;/code>.&lt;/li>
&lt;li>Sẽ không emit phần tử mới nếu nó bằng phần tử trước đó.&lt;/li>
&lt;/ul>
&lt;h2 id="thiết-lập-và-đọc-một-giá-trị">Thiết lập và đọc một giá trị
&lt;/h2>&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="k">val&lt;/span> &lt;span class="py">state&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">MutableStateFlow&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;A&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">// giá trị ban đầu là A
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="n">state&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="k">value&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="s2">&amp;#34;B&amp;#34;&lt;/span> &lt;span class="c1">// đặt giá trị thành B
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="n">state&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="k">value&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="s2">&amp;#34;B&amp;#34;&lt;/span> &lt;span class="c1">// giá trị này sẽ không emit phần tử mới vì giá trị đã là B
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="k">val&lt;/span> &lt;span class="py">myValue&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">state&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="k">value&lt;/span> &lt;span class="c1">// đọc giá trị từ state, ở đây là &amp;#34;B&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="statein">stateIn
&lt;/h2>&lt;ul>
&lt;li>Chuyển đổi một flow thành một &lt;code>StateFlow&lt;/code>.&lt;/li>
&lt;li>Cần xác định scope.&lt;/li>
&lt;li>Có 2 loại, một loại suspend và một loại không suspend&lt;/li>
&lt;/ul>
&lt;h3 id="statein-suspend">stateIn suspend
&lt;/h3>&lt;ul>
&lt;li>suspend cho đến khi phần tử đầu tiên của flow được emit và giá trị mới được tính toán&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="k">suspend&lt;/span> &lt;span class="k">fun&lt;/span> &lt;span class="nf">myFunction&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">coroutineScope&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">myFlow&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">stateIn&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">this&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="statein-not-suspend">stateIn not suspend
&lt;/h3>&lt;ul>
&lt;li>Yêu cầu một giá trị ban đầu trong tham số &lt;code>initialValue&lt;/code> của nó.&lt;/li>
&lt;li>Tham số thứ hai của nó là &lt;code>started&lt;/code> và mong đợi một phần tử &lt;code>SharingStarted&lt;/code>.&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="n">myFlow&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">stateIn&lt;/span>&lt;span class="p">(&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">scope&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">viewModelScope&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">started&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nc">SharingStarted&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">Lazily&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">initValue&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="s2">&amp;#34;A&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="use-case-emit-data-từ-viewmodel-sang-view">Use case: Emit data từ viewModel sang view
&lt;/h2>&lt;p>Đoạn code về cách chuyển flow thành &lt;code>StateFlow&lt;/code> để emit state từ view model sang view mà đang observe:&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;span class="lnt">30
&lt;/span>&lt;span class="lnt">31
&lt;/span>&lt;span class="lnt">32
&lt;/span>&lt;span class="lnt">33
&lt;/span>&lt;span class="lnt">34
&lt;/span>&lt;span class="lnt">35
&lt;/span>&lt;span class="lnt">36
&lt;/span>&lt;span class="lnt">37
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="k">class&lt;/span> &lt;span class="nc">MyViewModel&lt;/span> &lt;span class="nd">@Inject&lt;/span> &lt;span class="k">constructor&lt;/span>&lt;span class="p">(&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">private&lt;/span> &lt;span class="k">val&lt;/span> &lt;span class="py">fetchDataUseCase&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">FetchDataUseCase&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">)&lt;/span> &lt;span class="p">:&lt;/span> &lt;span class="n">ViewModel&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">val&lt;/span> &lt;span class="py">myState&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">StateFlow&lt;/span>&lt;span class="p">&amp;lt;&lt;/span>&lt;span class="n">MyState&lt;/span>&lt;span class="p">&amp;gt;&lt;/span> &lt;span class="p">=&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">fetchDataUseCase&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">dataState&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">.&lt;/span>&lt;span class="n">map&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">when&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="k">it&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">is&lt;/span> &lt;span class="nc">FetchDataUseCase&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nc">FetchDataState&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">Loading&lt;/span> &lt;span class="o">-&amp;gt;&lt;/span> &lt;span class="nc">MyState&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">Loading&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">is&lt;/span> &lt;span class="nc">FetchDataUseCase&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nc">FetchDataState&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">Success&lt;/span> &lt;span class="o">-&amp;gt;&lt;/span> &lt;span class="nc">MyState&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">Success&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">it&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="k">data&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">is&lt;/span> &lt;span class="nc">FetchDataUseCase&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nc">FetchDataState&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">Error&lt;/span> &lt;span class="o">-&amp;gt;&lt;/span> &lt;span class="nc">MyState&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">Error&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">it&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">message&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// chuyển flow thành state flow
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="p">.&lt;/span>&lt;span class="n">stateIn&lt;/span>&lt;span class="p">(&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// đặt scope thành viewModel vì vậy chúng ta sẽ stop
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// listening khi viewModel bị destroy
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">scope&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">viewModelScope&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">started&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nc">SharingStarted&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">WhileSubscribed&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="m">5&lt;/span>&lt;span class="n">_000&lt;/span>&lt;span class="p">),&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">initialValue&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nc">MyState&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">Loading&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">sealed&lt;/span> &lt;span class="k">interface&lt;/span> &lt;span class="nc">MyState&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">data&lt;/span> &lt;span class="k">object&lt;/span> &lt;span class="nc">Loading&lt;/span> &lt;span class="p">:&lt;/span> &lt;span class="n">MyState&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">data&lt;/span> &lt;span class="k">class&lt;/span> &lt;span class="nc">Success&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">val&lt;/span> &lt;span class="py">data&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">List&lt;/span>&lt;span class="p">&amp;lt;&lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="p">&amp;gt;)&lt;/span> &lt;span class="p">:&lt;/span> &lt;span class="n">MyState&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">data&lt;/span> &lt;span class="k">class&lt;/span> &lt;span class="nc">Error&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">val&lt;/span> &lt;span class="py">message&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">String&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">:&lt;/span> &lt;span class="n">MyState&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nd">@Composable&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">fun&lt;/span> &lt;span class="nf">MyScreen&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">viewModel&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">MyViewModel&lt;/span>&lt;span class="p">())&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">val&lt;/span> &lt;span class="py">state&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">viewModel&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">myState&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">collectAsStateWithLifecycle&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">when&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">state&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">is&lt;/span> &lt;span class="nc">MyState&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">Loading&lt;/span> &lt;span class="o">-&amp;gt;&lt;/span> &lt;span class="c1">// show loading view
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">is&lt;/span> &lt;span class="nc">MyState&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">Success&lt;/span> &lt;span class="o">-&amp;gt;&lt;/span> &lt;span class="c1">// show success view
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">is&lt;/span> &lt;span class="nc">MyState&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">Error&lt;/span> &lt;span class="o">-&amp;gt;&lt;/span> &lt;span class="c1">// show error view
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>Cảm ơn bạn đã đồng hành cùng mình đến hết serie Kotlin cheat sheet này. Hy vọng những kiến thức hữu ích này sẽ giúp bạn tự tin hơn khi làm việc với Kotlin Coroutines và Flow.&lt;/p>
&lt;h1 id="reference">Reference
&lt;/h1>&lt;ul>
&lt;li>&lt;a class="link" href="https://medium.com/@galou.minisini/advanced-kotlin-flow-cheat-sheet-for-android-engineer-cb8157d4f848" target="_blank" rel="noopener"
>https://medium.com/@galou.minisini/advanced-kotlin-flow-cheat-sheet-for-android-engineer-cb8157d4f848&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>Kotlin Flow cheat sheet phần 2: Flow</title><link>https://namanh11611.github.io/vi/p/kotlin-flow-cheat-sheet-2/</link><pubDate>Sun, 18 Aug 2024 05:00:00 +0700</pubDate><guid>https://namanh11611.github.io/vi/p/kotlin-flow-cheat-sheet-2/</guid><description>&lt;img src="https://namanh11611.github.io/p/kotlin-flow-cheat-sheet-2/cheat_sheet.webp" alt="Featured image of post Kotlin Flow cheat sheet phần 2: Flow" />&lt;p>&lt;em>Photo by &lt;a class="link" href="https://unsplash.com/@anacruzbaeza?utm_content=creditCopyText&amp;amp;utm_medium=referral&amp;amp;utm_source=unsplash" target="_blank" rel="noopener"
>Ana Cruz&lt;/a> on &lt;a class="link" href="https://unsplash.com/photos/photographie-a-plat-de-papiers-dimprimante-blancs-S0qh0ONK-AE?utm_content=creditCopyText&amp;amp;utm_medium=referral&amp;amp;utm_source=unsplash" target="_blank" rel="noopener"
>Unsplash&lt;/a>&lt;/em>&lt;/p>
&lt;p>Tiếp nối serie Kotlin cheat sheet, chúng ta cùng đi đến với cheat sheet tiếp theo dành cho &lt;strong>Flow&lt;/strong>.&lt;/p>
&lt;p>&lt;strong>Kotlin Flow&lt;/strong> là một API mạnh mẽ giúp quản lý luồng dữ liệu bất đồng bộ một cách rõ ràng và dễ dàng. Trong phần 2 này, chúng ta sẽ khám phá Flow từ cơ bản đến nâng cao, tìm hiểu cách tạo, chuyển đổi và thu thập các luồng dữ liệu, cũng như các best practice để áp dụng trong dự án Android của bạn.&lt;/p>
&lt;p>Bạn có thể đọc toàn bộ serie tại đây:&lt;/p>
&lt;ul>
&lt;li>&lt;a class="link" href="../kotlin-coroutines-cheat-sheet" >Kotlin Coroutines cheat sheet nâng cao dành cho Android Engineer&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="../kotlin-flow-cheat-sheet-1" >Kotlin Flow cheat sheet phần 1: Channel&lt;/a>&lt;/li>
&lt;li>Kotlin Flow cheat sheet phần 2: Flow&lt;/li>
&lt;li>&lt;a class="link" href="../kotlin-flow-cheat-sheet-3" >Kotlin Flow cheat sheet phần 3: SharedFlow và StateFlow&lt;/a>&lt;/li>
&lt;/ul>
&lt;h1 id="flow">Flow
&lt;/h1>&lt;h2 id="nguyên-tắc-chính">Nguyên tắc chính
&lt;/h2>&lt;ul>
&lt;li>Là một &lt;strong>cold stream&lt;/strong>.&lt;/li>
&lt;li>Hỗ trợ sẵn structured concurrency.&lt;/li>
&lt;li>Tác vụ cuối cùng của flow được gọi là tác vụ &lt;strong>terminal&lt;/strong> (&lt;code>collect&lt;/code>, &lt;code>first&lt;/code>… ).&lt;/li>
&lt;li>Một flow có thể có các tác vụ trung gian để sửa đổi flow (&lt;code>map&lt;/code>, &lt;code>onEach&lt;/code>, &lt;code>flatMapLastest&lt;/code>… ).&lt;/li>
&lt;li>Terminal operation là suspend và yêu cầu một scope.&lt;/li>
&lt;li>Các Exception chưa được bắt sẽ ngay lập tức cancel một flow và &lt;code>collect&lt;/code> sẽ throw lại Exception đó.&lt;/li>
&lt;li>Theo mặc định, context của flow sẽ lấy từ context mà &lt;code>collect&lt;/code> được gọi.&lt;/li>
&lt;/ul>
&lt;h2 id="kết-hợp-các-flow-với-nhau">Kết hợp các flow với nhau
&lt;/h2>&lt;p>&lt;code>merge&lt;/code>, &lt;code>combine&lt;/code> và &lt;code>zip&lt;/code> là các hàm trung gian cho phép chúng ta kết hợp 2 (hoặc nhiều) flow thành 1. Vậy điểm khác biệt chính giữa 3 hàm đó là gì?&lt;/p>
&lt;h3 id="merge">merge
&lt;/h3>&lt;ul>
&lt;li>&lt;strong>Không sửa đổi&lt;/strong> bất kỳ phần tử nào.&lt;/li>
&lt;li>Các phần tử được &lt;strong>emit ngay khi chúng được tạo ra&lt;/strong>, chúng ta không đợi flow khác để tạo ra giá trị.&lt;/li>
&lt;li>Sử dụng nó khi bạn có &lt;strong>nhiều nguồn event sẽ tạo ra cùng một action&lt;/strong>.&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>flowA emit: 1&lt;/p>
&lt;p>flowB emit: 2&lt;/p>
&lt;p>flowA emit: 3&lt;/p>
&lt;p>merge(flowA, flowB) tạo ra 1, 2, 3&lt;/p>&lt;/blockquote>
&lt;h3 id="zip">zip
&lt;/h3>&lt;ul>
&lt;li>&lt;strong>Kết hợp&lt;/strong> các phần tử từ các flow khác nhau để &lt;strong>tạo ra giá trị mới&lt;/strong>.&lt;/li>
&lt;li>Chúng ta cần một hàm để &lt;strong>xác định&lt;/strong> cách các phần tử được &lt;strong>kết hợp&lt;/strong> với nhau.&lt;/li>
&lt;li>Chúng ta cần &lt;strong>đợi mỗi flow emit một giá trị&lt;/strong> để có thể tạo cặp.&lt;/li>
&lt;li>Các phần tử chỉ có thể là &lt;strong>một phần của một cặp&lt;/strong>.&lt;/li>
&lt;li>Các phần tử còn lại &lt;strong>không có cặp sẽ bị mất&lt;/strong>.&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>flowA emit: 1&lt;/p>
&lt;p>flowB emit: 2&lt;/p>
&lt;p>flowA emit: 4&lt;/p>
&lt;p>flowA.zip(flowB) {fA, fB -&amp;gt; fA + fB } tạo ra 3 (1+2 = 3, còn 4 từ flowA sẽ bị loại bỏ)&lt;/p>&lt;/blockquote>
&lt;h3 id="combine">combine
&lt;/h3>&lt;ul>
&lt;li>&lt;strong>Kết hợp&lt;/strong> các phần tử từ các flow khác nhau để &lt;strong>tạo ra giá trị mới&lt;/strong>.&lt;/li>
&lt;li>Chúng ta cần một hàm &lt;strong>xác định&lt;/strong> cách các phần tử được &lt;strong>kết hợp&lt;/strong> với nhau.&lt;/li>
&lt;li>Chúng ta cần &lt;strong>đợi flow chậm hơn&lt;/strong> emit giá trị lần đầu tiên trước khi tạo phần tử mới.&lt;/li>
&lt;li>Khi một flow tạo ra một phần tử mới, nó sẽ &lt;strong>thay thế phần tử trước đó&lt;/strong> và &lt;strong>một giá trị mới sẽ được emit ngay lập tức&lt;/strong> (chúng ta không đợi mỗi flow emit một phần tử mới).&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>flowA emit: 1&lt;/p>
&lt;p>flowB emit: 2&lt;/p>
&lt;p>flowA emit: 3&lt;/p>
&lt;p>flowA.combines(flowB) { fA, fB -&amp;gt; fA + fB } tạo ra 3 (1+2 = 3) rồi 5 (3+2 = 5, trong đó phần tử 3 đã thay thế cho 1 trước đó)&lt;/p>&lt;/blockquote>
&lt;h2 id="sự-khác-biệt-giữa-fold-và-scan">Sự khác biệt giữa fold và scan
&lt;/h2>&lt;p>Cả &lt;code>fold&lt;/code> và &lt;code>scan&lt;/code> &lt;strong>kết hợp tất cả các giá trị&lt;/strong> do một flow emit thành &lt;strong>một phần tử&lt;/strong> bằng cách áp dụng thao tác kết hợp các giá trị lại với nhau.&lt;/p>
&lt;ul>
&lt;li>&lt;code>fold&lt;/code> là một tác vụ &lt;strong>terminal&lt;/strong>. Nó suspend cho đến khi flow hoàn thành và tạo ra giá trị cuối cùng&lt;/li>
&lt;li>&lt;code>scan&lt;/code> là một tác vụ trung gian và tạo ra tất cả các giá trị trung gian&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="k">val&lt;/span> &lt;span class="py">myflow&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">flowOf&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="m">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="m">2&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="m">3&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="m">4&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">myFlow&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">fold&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="m">0&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="n">acc&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">newElement&lt;/span> &lt;span class="o">-&amp;gt;&lt;/span> &lt;span class="n">acc&lt;/span> &lt;span class="p">+&lt;/span> &lt;span class="n">newElement&lt;/span> &lt;span class="p">}&lt;/span> &lt;span class="c1">// tạo ra 10
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">myFlow&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">scan&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="m">0&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="n">acc&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">newElement&lt;/span> &lt;span class="o">-&amp;gt;&lt;/span> &lt;span class="n">acc&lt;/span> &lt;span class="p">+&lt;/span> &lt;span class="n">newElement&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// tạo ra 1, 3 (1+2), 6 (3+3), 10 (6+4)
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="flatmapconcat-flatmapmerge-và-flatmaplatest">flatMapConcat, flatMapMerge và flatMapLatest
&lt;/h2>&lt;ul>
&lt;li>Chúng đều là những tác vụ trung gian&lt;/li>
&lt;li>Chúng biến đổi các phần tử được emit bởi flow ban đầu bằng cách áp dụng một flow khác lên phần tử đó và trả về một flow khác&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="n">myFlowA&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">flatMapConcat&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="n">fA&lt;/span> &lt;span class="o">-&amp;gt;&lt;/span> &lt;span class="n">myFlowB&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">fA&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">}&lt;/span> &lt;span class="c1">// giá trị trả về do flow B tạo ra
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="flatmapconcat">flatMapConcat
&lt;/h3>&lt;ul>
&lt;li>Chuyển đổi từng giá trị được emit thành một flow và nối các flow kết quả &lt;strong>một cách tuần tự&lt;/strong>.&lt;/li>
&lt;li>Emit hoàn toàn các giá trị từ inner flow đầu tiên trước khi bắt đầu flow tiếp theo.&lt;/li>
&lt;li>Use Case: khi bạn cần xử lý các flow bên trong &lt;strong>theo thứ tự&lt;/strong>, không bị chồng chéo.&lt;/li>
&lt;/ul>
&lt;h3 id="flatmapmerge">flatMapMerge
&lt;/h3>&lt;ul>
&lt;li>Chuyển đổi từng giá trị được emit thành một flow và hợp nhất các flow kết quả &lt;strong>một cách đồng thời&lt;/strong>.&lt;/li>
&lt;li>Emit các giá trị từ tất cả các inner flow khi chúng có sẵn, có khả năng không theo thứ tự.&lt;/li>
&lt;li>Use Case: khi bạn muốn xử lý đồng thời các flow bên trong và &lt;strong>không quan tâm đến thứ tự&lt;/strong> của các giá trị được emit.&lt;/li>
&lt;/ul>
&lt;h3 id="flatmaplatest">flatMapLatest
&lt;/h3>&lt;ul>
&lt;li>Chuyển đổi từng giá trị được emit thành một flow, &lt;strong>hủy các flow trước đó&lt;/strong> khi một giá trị mới đã được emit, và &lt;strong>emit các giá trị từ flow mới nhất&lt;/strong>.&lt;/li>
&lt;li>Chỉ flow mới nhất được hoạt động và các giá trị của nó được emit. Các flow trước đó bị hủy bỏ.&lt;/li>
&lt;li>Use Case: khi bạn chỉ quan tâm đến &lt;strong>giá trị mới nhất&lt;/strong> và muốn hủy các thao tác trước đó.&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;span class="lnt">30
&lt;/span>&lt;span class="lnt">31
&lt;/span>&lt;span class="lnt">32
&lt;/span>&lt;span class="lnt">33
&lt;/span>&lt;span class="lnt">34
&lt;/span>&lt;span class="lnt">35
&lt;/span>&lt;span class="lnt">36
&lt;/span>&lt;span class="lnt">37
&lt;/span>&lt;span class="lnt">38
&lt;/span>&lt;span class="lnt">39
&lt;/span>&lt;span class="lnt">40
&lt;/span>&lt;span class="lnt">41
&lt;/span>&lt;span class="lnt">42
&lt;/span>&lt;span class="lnt">43
&lt;/span>&lt;span class="lnt">44
&lt;/span>&lt;span class="lnt">45
&lt;/span>&lt;span class="lnt">46
&lt;/span>&lt;span class="lnt">47
&lt;/span>&lt;span class="lnt">48
&lt;/span>&lt;span class="lnt">49
&lt;/span>&lt;span class="lnt">50
&lt;/span>&lt;span class="lnt">51
&lt;/span>&lt;span class="lnt">52
&lt;/span>&lt;span class="lnt">53
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="k">data&lt;/span> &lt;span class="k">class&lt;/span> &lt;span class="nc">User&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">val&lt;/span> &lt;span class="py">id&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">Int&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="k">val&lt;/span> &lt;span class="py">name&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">String&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">data&lt;/span> &lt;span class="k">class&lt;/span> &lt;span class="nc">UserDetails&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">val&lt;/span> &lt;span class="py">userId&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">Int&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="k">val&lt;/span> &lt;span class="py">address&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">String&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">fun&lt;/span> &lt;span class="nf">fetchUserData&lt;/span>&lt;span class="p">():&lt;/span> &lt;span class="n">Flow&lt;/span>&lt;span class="p">&amp;lt;&lt;/span>&lt;span class="n">User&lt;/span>&lt;span class="p">&amp;gt;&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">flow&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">emit&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">User&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="m">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s2">&amp;#34;Alice&amp;#34;&lt;/span>&lt;span class="p">))&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">delay&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="m">500&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">emit&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">User&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="m">2&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s2">&amp;#34;Bob&amp;#34;&lt;/span>&lt;span class="p">))&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">delay&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="m">500&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">emit&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">User&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="m">3&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s2">&amp;#34;Charlie&amp;#34;&lt;/span>&lt;span class="p">))&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">fun&lt;/span> &lt;span class="nf">fetchUserDetails&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">userId&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">Int&lt;/span>&lt;span class="p">):&lt;/span> &lt;span class="n">Flow&lt;/span>&lt;span class="p">&amp;lt;&lt;/span>&lt;span class="n">UserDetails&lt;/span>&lt;span class="p">&amp;gt;&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">flow&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">delay&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="m">1000&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1">// Giả lập network delay
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">emit&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">UserDetails&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">userId&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s2">&amp;#34;&lt;/span>&lt;span class="si">$userId&lt;/span>&lt;span class="s2">&amp;#39;s address&amp;#34;&lt;/span>&lt;span class="p">))&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// flatMapConcat
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="n">fetchUserData&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">.&lt;/span>&lt;span class="n">flatMapConcat&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="n">user&lt;/span> &lt;span class="o">-&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">fetchUserDetails&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">user&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">id&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">.&lt;/span>&lt;span class="n">collect&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="n">userDetails&lt;/span> &lt;span class="o">-&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;flatMapConcat: &lt;/span>&lt;span class="si">${userDetails}&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// Mỗi thông tin user được trả về tuần tự.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// flatMapConcat: UserDetails(userId=1, address=1&amp;#39;s address)
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// flatMapConcat: UserDetails(userId=2, address=2&amp;#39;s address)
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// flatMapConcat: UserDetails(userId=3, address=3&amp;#39;s address)
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// flatMapMerge
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="n">fetchUserData&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">.&lt;/span>&lt;span class="n">flatMapMerge&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="n">user&lt;/span> &lt;span class="o">-&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">fetchUserDetails&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">user&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">id&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">.&lt;/span>&lt;span class="n">collect&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="n">userDetails&lt;/span> &lt;span class="o">-&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;flatMapMerge: &lt;/span>&lt;span class="si">${userDetails}&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// Thông tin user có thể bị xen kẽ do trả về đồng thời.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// flatMapMerge: UserDetails(userId=1, address=1&amp;#39;s address)
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// flatMapMerge: UserDetails(userId=2, address=2&amp;#39;s address)
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// flatMapMerge: UserDetails(userId=3, address=3&amp;#39;s address)
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// flatMapLatest
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="n">fetchUserData&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">.&lt;/span>&lt;span class="n">flatMapLatest&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="n">user&lt;/span> &lt;span class="o">-&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">fetchUserDetails&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">user&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">id&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">.&lt;/span>&lt;span class="n">collect&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="n">userDetails&lt;/span> &lt;span class="o">-&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;flatMapLatest: &lt;/span>&lt;span class="si">${userDetails}&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// Chỉ thông tin của user cuối cùng được trả về
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// do user mới sẽ cancel fetch trước đó.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// flatMapLatest: UserDetails(userId=3, address=3&amp;#39;s address)
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="chuyển-đổi-function-thành-flow">Chuyển đổi function thành Flow
&lt;/h2>&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="k">val&lt;/span> &lt;span class="py">function&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="k">suspend&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// đây là biểu thức lambda suspend
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// định nghĩa hàm ở đây
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">function&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">asFlow&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>Hoặc&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="k">suspend&lt;/span> &lt;span class="k">fun&lt;/span> &lt;span class="nf">myFunction&lt;/span>&lt;span class="p">():&lt;/span> &lt;span class="n">Flow&lt;/span>&lt;span class="p">&amp;lt;&lt;/span>&lt;span class="n">T&lt;/span>&lt;span class="p">&amp;gt;&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// định nghĩa hàm ở đây
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">::&lt;/span>&lt;span class="n">myFunction&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">asFlow&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="tạo-flow-tạo-ra-các-phần-tử-trước-khi-chúng-ta-subscribe">Tạo flow tạo ra các phần tử trước khi chúng ta subscribe
&lt;/h2>&lt;p>Hàm &lt;code>channelFlow&lt;/code> tạo ra sự kết hợp giữa flow và channel. Nó tạo ra một hot stream data nhưng cũng implement Flow interface.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="k">val&lt;/span> &lt;span class="py">myChannelFlow&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">channelFlow&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">val&lt;/span> &lt;span class="py">myData&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="c1">// fetch dữ liệu tại đây
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">send&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">myData&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">suspend&lt;/span> &lt;span class="k">fun&lt;/span> &lt;span class="nf">fetchData&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">myData&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">first&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="sửa-đổi-context-của-flow">Sửa đổi context của Flow
&lt;/h2>&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="n">myFlow&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">flowOn&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nc">Dispatchers&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">IO&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// Hoặc
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">myFlow&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">flowOn&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">CoroutineName&lt;/span>&lt;span class="p">(&lt;/span> &lt;span class="s2">&amp;#34;NewName&amp;#34;&lt;/span> &lt;span class="p">))&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="tránh-lồng-nhau-khi-khởi-chạy-flow">Tránh lồng nhau khi khởi chạy flow
&lt;/h2>&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// thay vì
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="n">viewModelScope&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">launch&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">myFlow&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">collect&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// làm như này
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="n">myFlow&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">launchIn&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">viewModelScope&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>Cảm ơn các bạn đã đọc đến đây, cùng chờ đón những phần tiếp theo nhé.&lt;/p>
&lt;h1 id="reference">Reference
&lt;/h1>&lt;ul>
&lt;li>&lt;a class="link" href="https://medium.com/@galou.minisini/advanced-kotlin-flow-cheat-sheet-for-android-engineer-cb8157d4f848" target="_blank" rel="noopener"
>https://medium.com/@galou.minisini/advanced-kotlin-flow-cheat-sheet-for-android-engineer-cb8157d4f848&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>Kotlin Flow cheat sheet phần 1: Channel</title><link>https://namanh11611.github.io/vi/p/kotlin-flow-cheat-sheet-1/</link><pubDate>Sun, 18 Aug 2024 04:00:00 +0700</pubDate><guid>https://namanh11611.github.io/vi/p/kotlin-flow-cheat-sheet-1/</guid><description>&lt;img src="https://namanh11611.github.io/p/kotlin-flow-cheat-sheet-1/cheat_sheet.webp" alt="Featured image of post Kotlin Flow cheat sheet phần 1: Channel" />&lt;p>&lt;em>Photo by &lt;a class="link" href="https://unsplash.com/@anacruzbaeza?utm_content=creditCopyText&amp;amp;utm_medium=referral&amp;amp;utm_source=unsplash" target="_blank" rel="noopener"
>Ana Cruz&lt;/a> on &lt;a class="link" href="https://unsplash.com/photos/photographie-a-plat-de-papiers-dimprimante-blancs-S0qh0ONK-AE?utm_content=creditCopyText&amp;amp;utm_medium=referral&amp;amp;utm_source=unsplash" target="_blank" rel="noopener"
>Unsplash&lt;/a>&lt;/em>&lt;/p>
&lt;p>Sau khi làm việc với &lt;strong>Kotlin Flows&lt;/strong> một thời gian, có thể bạn đã quen với các khái niệm cơ bản. Nhưng nếu chưa bao giờ sử dụng &lt;code>Channel&lt;/code>, bạn sẽ không biết sự khác nhau giữa &lt;code>merge&lt;/code>, &lt;code>combine&lt;/code> và &lt;code>zip&lt;/code>, hoặc có thể bạn chưa hiểu rõ &lt;code>SharedFlow&lt;/code> và &lt;code>StateFlow&lt;/code> cũng như cách sử dụng chúng.&lt;/p>
&lt;p>Cheat sheet này hệ thống lại những kiến thức quan trọng mà mình đã góp nhặt được trong quá trình làm việc với &lt;strong>Kotlin Flow&lt;/strong>. Nó được thiết kế để trở thành một tài liệu tham khảo hữu ích, giúp bạn giải quyết các tình huống phức tạp.&lt;/p>
&lt;p>Trong phần 1, chúng ta sẽ tìm hiểu chi tiết về Channel, cách thức hoạt động, và cách ứng dụng trong các trường hợp thực tế để giao tiếp giữa các coroutine một cách an toàn và hiệu quả.&lt;/p>
&lt;p>Bạn có thể đọc toàn bộ serie tại đây:&lt;/p>
&lt;ul>
&lt;li>&lt;a class="link" href="../kotlin-coroutines-cheat-sheet" >Kotlin Coroutines cheat sheet nâng cao dành cho Android Engineer&lt;/a>&lt;/li>
&lt;li>Kotlin Flow cheat sheet phần 1: Channel&lt;/li>
&lt;li>&lt;a class="link" href="../kotlin-flow-cheat-sheet-2" >Kotlin Flow cheat sheet phần 2: Flow&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="../kotlin-flow-cheat-sheet-3" >Kotlin Flow cheat sheet phần 3: SharedFlow và StateFlow&lt;/a>&lt;/li>
&lt;/ul>
&lt;h1 id="hot-streams-và-cold-streams">Hot streams và Cold streams
&lt;/h1>&lt;h2 id="hot-streams">Hot streams
&lt;/h2>&lt;ul>
&lt;li>Ví dụ: &lt;code>channel&lt;/code>, &lt;code>Collections&lt;/code> (&lt;code>List&lt;/code>, &lt;code>Set&lt;/code>… ).&lt;/li>
&lt;li>&lt;strong>Bắt đầu ngay lập tức:&lt;/strong> bắt đầu emit các giá trị bất kể có subscriber hay không.&lt;/li>
&lt;li>&lt;strong>Lưu các phần tử:&lt;/strong> chúng không cần phải tính toán lại và tất cả subscriber đều nhận được cùng một chuỗi giá trị.&lt;/li>
&lt;/ul>
&lt;h2 id="cold-streams">Cold streams
&lt;/h2>&lt;ul>
&lt;li>Ví dụ: &lt;code>Sequence&lt;/code>, &lt;code>Flow&lt;/code>&lt;/li>
&lt;li>&lt;strong>Bắt đầu theo yêu cầu:&lt;/strong> cold streams chỉ bắt đầu emit các giá trị khi subscriber chủ động đăng ký stream đó. Nguồn dữ liệu là lazy.&lt;/li>
&lt;li>&lt;strong>Phát độc lập:&lt;/strong> mỗi subscriber nhận được chuỗi giá trị độc lập của riêng mình. Không có phần tử nào được lưu trữ.&lt;/li>
&lt;/ul>
&lt;h1 id="channel">Channel
&lt;/h1>&lt;h2 id="nguyên-tắc-chính">Nguyên tắc chính
&lt;/h2>&lt;ul>
&lt;li>Là một &lt;strong>hot stream&lt;/strong>.&lt;/li>
&lt;li>Đảm bảo &lt;strong>không có xung đột&lt;/strong> (không có vấn đề với trạng thái chia sẻ) và &lt;strong>công bằng&lt;/strong> nên rất hữu ích khi các &lt;strong>coroutine&lt;/strong> khác nhau cần &lt;strong>liên lạc với nhau&lt;/strong>.&lt;/li>
&lt;li>Hỗ trợ &lt;strong>bất kỳ số lượng&lt;/strong> sender và receiver.&lt;/li>
&lt;li>Mỗi giá trị gửi tới channel chỉ &lt;strong>được nhận một lần&lt;/strong>.&lt;/li>
&lt;li>Nếu có nhiều receiver subscribe cùng lúc, các phần tử sẽ được &lt;strong>phân bổ công bằng&lt;/strong> giữa các receiver. (Hàng đợi &lt;strong>FIFO&lt;/strong> của receiver).&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>Channel có 3 receiver, subscribe theo thứ tự:
Receiver1, Receiver2, Receiver3.&lt;/p>
&lt;p>Tất cả receiver đã subscribe channel.&lt;/p>
&lt;p>Channel emit ra 4 giá trị: &amp;ldquo;A&amp;rdquo;, &amp;ldquo;B&amp;rdquo;, &amp;ldquo;C&amp;rdquo; rồi &amp;ldquo;D&amp;rdquo;.&lt;/p>
&lt;p>Receiver1 nhận được &amp;ldquo;A&amp;rdquo; và &amp;ldquo;D&amp;rdquo;&lt;/p>
&lt;p>Receiver2 nhận được &amp;ldquo;B&amp;rdquo;&lt;/p>
&lt;p>Receiver3 nhận được &amp;ldquo;C&amp;rdquo;&lt;/p>&lt;/blockquote>
&lt;ul>
&lt;li>Chúng có 2 suspend function là &lt;code>send&lt;/code> và &lt;code>receive&lt;/code>.&lt;/li>
&lt;li>&lt;code>receive&lt;/code> bị suspend nếu &lt;strong>không có phần tử nào&lt;/strong> trong channel và sẽ đợi một phần tử sẵn sàng để tiếp tục.&lt;/li>
&lt;li>&lt;code>send&lt;/code> bị suspend nếu channel &lt;strong>đạt đến capacity&lt;/strong>.&lt;/li>
&lt;li>Chúng ta cũng có thể sử dụng phiên bản &lt;strong>không bị suspend&lt;/strong> là &lt;code>trySend&lt;/code> và &lt;code>tryReceive&lt;/code>, chúng trả về một &lt;code>ChannelResult&lt;/code> (cho chúng ta biết thao tác có thành công hay không).&lt;/li>
&lt;li>Chúng cần được &lt;strong>close thủ công&lt;/strong> sau khi chúng ta gửi xong dữ liệu hoặc khi xảy ra Exception: &lt;code>myChannel.close()&lt;/code>. Nếu không, receive sẽ đợi các phần tử mãi mãi.&lt;/li>
&lt;/ul>
&lt;h2 id="các-loại-channel-capacity">Các loại channel capacity
&lt;/h2>&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="k">val&lt;/span> &lt;span class="py">myChannel&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">Channel&lt;/span>&lt;span class="p">&amp;lt;&lt;/span>&lt;span class="n">Int&lt;/span>&lt;span class="p">&amp;gt;(&lt;/span>&lt;span class="n">capacity&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="m">3&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// hoặc
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">val&lt;/span> &lt;span class="py">myChannel&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">produce&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">capacity&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="m">3&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// emit các giá trị ở đây
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;ul>
&lt;li>&lt;code>Channel.UNLIMITED&lt;/code>: buffer không giới hạn và &lt;code>send&lt;/code> không bao giờ bị suspend.&lt;/li>
&lt;li>&lt;code>Channel.BUFFERED&lt;/code>: buffer capacity là 64. Giá trị mặc định này có thể được override bằng thuộc tính hệ thống &lt;code>kotlinx.coroutines.channels.defaultBuffer&lt;/code> trong JVM.&lt;/li>
&lt;li>&lt;code>Channel.RENDEZVOUS&lt;/code>: (behavior mặc định) buffer capacity là 0. Receiver sẽ chỉ nhận được dữ liệu nếu nó đã subscribe với sender khi dữ liệu được emit.&lt;/li>
&lt;li>&lt;code>Channel.CONFLATED&lt;/code>: buffer capacity là 1. Mỗi phần tử mới sẽ thay thế phần tử trước đó.&lt;/li>
&lt;li>Giá trị &lt;code>int&lt;/code>bất kỳ: buffer sẽ có capacity bằng giá trị được set.&lt;/li>
&lt;/ul>
&lt;h2 id="xử-lý-lỗi-tràn-buffer">Xử lý lỗi tràn buffer
&lt;/h2>&lt;p>Các channel có một tham số &lt;code>onBufferOverflow&lt;/code> kiểm soát những gì xảy ra khi buffer đầy. Có 3 lựa chọn:&lt;/p>
&lt;ul>
&lt;li>&lt;code>BufferOverflow.SUSPEND&lt;/code>: (behavior mặc định) tạm dừng phương thức &lt;code>send&lt;/code> khi buffer đầy.&lt;/li>
&lt;li>&lt;code>BufferOverflow.DROP_OLDEST&lt;/code>: loại bỏ phần tử cũ nhất khi buffer đầy.&lt;/li>
&lt;li>&lt;code>BufferOverflow.DROP_LATEST&lt;/code>: loại bỏ phần tử mới nhất khi buffer đầy.&lt;/li>
&lt;/ul>
&lt;h2 id="tạo-channel-tự-động-close">Tạo Channel tự động close
&lt;/h2>&lt;p>Coroutine builder &lt;code>produce&lt;/code> sẽ close channel bất cứ khi nào builder coroutine kết thúc (finish, stop hoặc cancel).&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="k">suspend&lt;/span> &lt;span class="k">fun&lt;/span> &lt;span class="nf">myFunction&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">coroutineScope&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">val&lt;/span> &lt;span class="py">channel&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">produce&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// emit các giá trị ở đây và không cần gọi close() khi kết thúc
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="tự-động-dọn-dẹp-nếu-một-phần-tử-không-thể-xử-lý">Tự động dọn dẹp nếu một phần tử không thể xử lý
&lt;/h2>&lt;p>Nếu channel đã bị close, cancel hoặc khi &lt;code>send&lt;/code>, &lt;code>receive&lt;/code>, &lt;code>hastNext&lt;/code> có lỗi&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="k">val&lt;/span> &lt;span class="py">myChannel&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">Channel&lt;/span>&lt;span class="p">(&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">capacity&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">onUnderliveredElement&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="cm">/* các tác vụ dọn dẹp ở đây */&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="use-case-trigger-một-refresh">Use case: trigger một refresh
&lt;/h2>&lt;p>Trong Android, trường hợp sử dụng phổ biến cho các channel là trigger khi một screen được refresh (pull to refresh hoặc button retry). Đoạn code bên dưới trình bày cách fetch data từ API khi chúng ta subscribe flow lần đầu tiên hoặc khi trigger một refresh.&lt;/p>
&lt;p>Rất nhiều người sử dụng &lt;code>SharedFlow&lt;/code> để trigger refresh và nó hoạt động ổn, nhưng đó không phải là giải pháp tốt nhất vì &lt;code>SharedFlow&lt;/code> được thiết kế để có nhiều receiver.&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;span class="lnt">30
&lt;/span>&lt;span class="lnt">31
&lt;/span>&lt;span class="lnt">32
&lt;/span>&lt;span class="lnt">33
&lt;/span>&lt;span class="lnt">34
&lt;/span>&lt;span class="lnt">35
&lt;/span>&lt;span class="lnt">36
&lt;/span>&lt;span class="lnt">37
&lt;/span>&lt;span class="lnt">38
&lt;/span>&lt;span class="lnt">39
&lt;/span>&lt;span class="lnt">40
&lt;/span>&lt;span class="lnt">41
&lt;/span>&lt;span class="lnt">42
&lt;/span>&lt;span class="lnt">43
&lt;/span>&lt;span class="lnt">44
&lt;/span>&lt;span class="lnt">45
&lt;/span>&lt;span class="lnt">46
&lt;/span>&lt;span class="lnt">47
&lt;/span>&lt;span class="lnt">48
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// Đây là phiên bản đơn giản hóa để minh họa cách chúng ta có thể sử dụng channel.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// Trong trường hợp sử dụng thực tế, chúng ta sẽ yêu cầu một số logic bổ sung để tránh
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// làm mới nếu dữ liệu đã được tải chẳng hạn.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">interface&lt;/span> &lt;span class="nc">ApiService&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">suspend&lt;/span> &lt;span class="k">fun&lt;/span> &lt;span class="nf">fetchData&lt;/span>&lt;span class="p">():&lt;/span> &lt;span class="n">List&lt;/span>&lt;span class="p">&amp;lt;&lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="p">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">class&lt;/span> &lt;span class="nc">FetchDataUseCase&lt;/span> &lt;span class="nd">@Inject&lt;/span> &lt;span class="k">constructor&lt;/span> &lt;span class="p">(&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">private&lt;/span> &lt;span class="k">val&lt;/span> &lt;span class="py">apiService&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">ApiService&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// tạo một channel có buffer là 1 và sẽ loại bỏ dữ liệu mới nhất
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// vì vậy nếu chúng ta trigger refresh nhiều lần liên tiếp
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// chúng ta sẽ chỉ giữ phần tử đầu tiên.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">private&lt;/span> &lt;span class="k">val&lt;/span> &lt;span class="py">refreshChannel&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">Channel&lt;/span>&lt;span class="p">&amp;lt;&lt;/span>&lt;span class="n">Unit&lt;/span>&lt;span class="p">&amp;gt;(&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">capacity&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="m">1&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">onBufferOverflow&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nc">BufferOverflow&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">DROP_LATEST&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// viewModel có thể receive flow này để build UI state
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="k">val&lt;/span> &lt;span class="py">dataState&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">Flow&lt;/span>&lt;span class="p">&amp;lt;&lt;/span>&lt;span class="n">FetchDataState&lt;/span>&lt;span class="p">&amp;gt;&lt;/span> &lt;span class="p">=&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">refreshChannel&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// convert channel thành flow
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="p">.&lt;/span>&lt;span class="n">consumeAsFlow&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// emit một phần tử khi bắt đầu fetch data ngay khi chúng ta subscribe flow
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="p">.&lt;/span>&lt;span class="n">onStart&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="n">emit&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">Unit&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">.&lt;/span>&lt;span class="n">map&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="n">fetchData&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">fun&lt;/span> &lt;span class="nf">refresh&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// Chúng ta sử dụng trySend ở đây để không phải tạo suspend function
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// và vì vậy chúng ta không cần scope để gọi nó.
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="c1">// Phương thức này có thể được gọi từ viewModel để trigger refresh
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="n">refreshChannel&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">trySend&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">Unit&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">private&lt;/span> &lt;span class="k">suspend&lt;/span> &lt;span class="k">fun&lt;/span> &lt;span class="nf">fetchData&lt;/span>&lt;span class="p">():&lt;/span> &lt;span class="n">FetchDataState&lt;/span> &lt;span class="p">=&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">try&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">val&lt;/span> &lt;span class="py">data&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">apiService&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">fetchData&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nc">FetchDataState&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">Success&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">data&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span> &lt;span class="k">catch&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">e&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">Exception&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nc">FetchDataState&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">Error&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">e&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">message&lt;/span> &lt;span class="o">?:&lt;/span> &lt;span class="s2">&amp;#34;An error occurred&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">sealed&lt;/span> &lt;span class="k">interface&lt;/span> &lt;span class="nc">FetchDataState&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">data&lt;/span> &lt;span class="k">object&lt;/span> &lt;span class="nc">Loading&lt;/span> &lt;span class="p">:&lt;/span> &lt;span class="n">FetchDataState&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">data&lt;/span> &lt;span class="k">class&lt;/span> &lt;span class="nc">Success&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">val&lt;/span> &lt;span class="py">data&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">List&lt;/span>&lt;span class="p">&amp;lt;&lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="p">&amp;gt;)&lt;/span> &lt;span class="p">:&lt;/span> &lt;span class="n">FetchDataState&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">data&lt;/span> &lt;span class="k">class&lt;/span> &lt;span class="nc">Error&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">val&lt;/span> &lt;span class="py">message&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">String&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">:&lt;/span> &lt;span class="n">FetchDataState&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>Cảm ơn các bạn đã đọc đến đây, cùng chờ đón những phần tiếp theo nhé.&lt;/p>
&lt;h1 id="reference">Reference
&lt;/h1>&lt;ul>
&lt;li>&lt;a class="link" href="https://medium.com/@galou.minisini/advanced-kotlin-flow-cheat-sheet-for-android-engineer-cb8157d4f848" target="_blank" rel="noopener"
>https://medium.com/@galou.minisini/advanced-kotlin-flow-cheat-sheet-for-android-engineer-cb8157d4f848&lt;/a>&lt;/li>
&lt;/ul></description></item></channel></rss>
[{"content":"As you may know, all Dart code runs in isolates, starting from the default main isolate. When developing Flutter applications, handling heavy tasks like image processing or complex calculations on the main isolate can cause lag and stutter. Although Flutter provides Future and Stream, they are still processed on the main isolate. The Isolate API was created to solve this problem, allowing us to offload heavy tasks to background workers and restore the app\u0026rsquo;s smoothness. In this article, I will explain how to use Isolate and provide best practices for working with it.\nWhat is an Isolate? Dart is a single-threaded language. When you use async and await, it actually runs concurrently. If a time-consuming task runs on the main thread, it will block the entire UI. Isolate is the solution for parallelism.\nAn Isolate is an independent execution thread in Dart. Each isolate has its own Heap memory, ensuring that no isolate can access another\u0026rsquo;s memory, which helps the app run smoothly without shared state.\nLet\u0026rsquo;s jump into code for a clearer picture. Here‚Äôs a simple example of creating an Isolate:\n1 2 3 4 5 6 7 8 9 10 import \u0026#39;dart:isolate\u0026#39;; void main() { Isolate.spawn(isolateMethod, \u0026#34;Hello World from Main Isolate\u0026#34;); print(\u0026#39;Main isolate\u0026#39;); } void isolateMethod(String message) { print(\u0026#39;New isolate: $message\u0026#39;); } In the example above, the main() function runs on the main isolate, often called the UI isolate. We create a new isolate by calling Isolate.spawn(), which executes the isolateMethod(). These worker isolates cannot access the UI.\nCommunication Between Isolates To exchange data between isolates, Dart provides two classes: SendPort and ReceivePort, which allow isolates to communicate via messages. Read the following code; I‚Äôll explain it in detail below.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 void main() async { final mainReceivePort = ReceivePort(); final isolate = await Isolate.spawn(twoWayIsolate, mainReceivePort.sendPort); // Receive SendPort from the worker isolate mainReceivePort.listen((message) { if (message is SendPort) { print(\u0026#39;Main: SendPort\u0026#39;); message.send(\u0026#39;Hello\u0026#39;); } else { print(\u0026#39;Main received: $message\u0026#39;); // Output: Hello to Henry isolate.kill(); } }); } void twoWayIsolate(SendPort mainSendPort) { final receivePort = ReceivePort(); // Send the worker isolate\u0026#39;s SendPort back to main mainSendPort.send(receivePort.sendPort); receivePort.listen((message) { if (message is String) { print(\u0026#39;Worker received: $message\u0026#39;); // Output: Hello final newMessage = \u0026#39;$message to Henry\u0026#39;; mainSendPort.send(newMessage); } }); } In this example, we set up two-way communication between the main isolate and the worker isolate:\n1 2 // Send the worker isolate\u0026#39;s SendPort back to main mainSendPort.send(receivePort.sendPort); As soon as the main isolate receives a SendPort message, it sends a greeting to the worker isolate:\n1 message.send(\u0026#39;Hello\u0026#39;); The worker isolate responds by sending a greeting back to the main isolate:\n1 2 final newMessage = \u0026#39;$message to Henry\u0026#39;; mainSendPort.send(newMessage); As you can see, SendPort.send() is responsible for sending messages, while listening for messages is done via ReceivePort.listen().\nUsing compute for Simple Tasks Flutter provides the compute function to run a function in a new isolate with just one line of code:\n1 2 3 4 5 6 7 8 9 10 11 12 13 Future\u0026lt;void\u0026gt; fetchData() async { final result = await compute(_heavyProcessing, 1000000); print(\u0026#39;Result: $result\u0026#39;); } // This function will run in its own isolate int _heavyProcessing(int iterations) { int sum = 0; for (int i = 0; i \u0026lt; iterations; i++) { sum += i; } return sum; } The advantage of compute is that it automatically manages the isolate, which is destroyed as soon as it finishes.\nHowever, there are limitations: compute only accepts one parameter. If you need more, you must package them into a Map or List. Also, compute cannot do two-way communication like Isolate.spawn in the previous example.\nBest Practices Only use isolates for CPU-intensive tasks For network requests, you can use a regular HTTP client. Only use isolates for CPU-heavy tasks like image processing.\n1 2 3 4 5 // DO compute(imageProcessing, imageData); // DON\u0026#39;T compute(networkRequest, url); Avoid creating isolates continuously Creating new isolates repeatedly consumes CPU and memory, and initializing an isolate is relatively slow, taking about 30ms each time. Therefore, using a Worker Pool helps reuse existing isolates.\nUse simple data types when passing through ports Since isolates do not share memory, data passed between isolates must be serialized/deserialized. Using complex data types increases conversion time and memory usage when copying data.\n1 2 3 4 5 // Recommended sendPort.send({\u0026#39;id\u0026#39;: 1, \u0026#39;value\u0026#39;: 42}); // Not recommended sendPort.send(MyComplexClass()); Stop isolates when not needed When using Isolate.spawn, it does not automatically release resources when unused. Leaving isolates running in the background wastes CPU/memory and can cause memory leaks. Use Isolate.kill to stop them when done.\n1 isolate.kill(priority: Isolate.immediate); Conclusion Isolate is a powerful tool for handling heavy tasks in Flutter without affecting the UI. Although it has some complexity, by using it correctly with compute and supporting libraries, you can create smooth apps even when handling complex business logic.\nReference Concurrency in Dart Isolates ","date":"2025-05-25T00:00:00+07:00","image":"https://namanh11611.github.io/p/isolate/isolate_hu_a30cdda4656af448.webp","permalink":"https://namanh11611.github.io/p/isolate/","title":"Isolate in Flutter: The Savior for Heavy Tasks"},{"content":" Tired of academic articles? Today, let\u0026rsquo;s enjoy a detective-style article for a change of pace.\nCase Introduction Key appears everywhere in Flutter, from StatefulWidget to StatelessWidget. It seems so close yet so far, familiar yet mysterious. Although Flutter developers often work with Widget, Key‚Äîthe silent player behind all power transfers‚Äîrarely gets attention.\nToday, the Flutter Vietnam detective team will take you deep into the corners of the Flutter gang, decoding the role of Key in optimizing performance for Flutter apps, and exploring best practices for using them.\nSearching for the Mastermind The definition of Key in the documentation states:\nA Key is an identifier for Widgets, Elements and SemanticsNodes.\nA new widget will only be used to update an existing element if its key is the same as the key of the current widget associated with the element.\nTranslation:\nKey is an identifier for Widget, Element, and SemanticsNodes.\nA new widget will only be used to update an existing element if its key matches the key of the current widget associated with that element.\nAs you know, in Flutter, everything is a Widget. This Widget gang includes familiar faces like Row, Column, Container\u0026hellip; But these Widgets are just henchmen; according to our intelligence, the gang is run by a notorious boss: Element.\nHe manipulates all Widgets, from calling initState, build, dispose of Widgets to managing the Widget Tree. Element is also a crucial link between Widget and RenderObject‚Äîthe one that draws the UI on the screen‚Äîto create masterpieces.\nHowever, today we\u0026rsquo;re not taking down the boss or the whole gang, just remember that Element orchestrates everything. The fish isn\u0026rsquo;t big enough yet to cast the net. The goal of this case is to investigate Key and the four masters.\nKey When you rebuild a Flutter app, do you know what happens in the shadows? Element decides which Widgets to keep, replace, or remove. This is where Key starts to show its power.\nIn the Widget world, whenever changes occur, Widgets aren\u0026rsquo;t just updated but are destroyed and reborn. Key is the identity card that helps Widgets retain their identity during rebirth. After the Widget tree is rebuilt, Element uses Widget type and Key to decide whether the Element should be rebuilt. If Widget types differ, the Element is destroyed and recreated. Rebuilding the boss is much more expensive than rebuilding the henchmen Widgets. This can cause unwanted performance issues and sometimes make your app lag.\nIf Widget types are the same, Element compares the Key. If the Key matches, Element only updates the widget. Otherwise, Element is deactivated, meaning it\u0026rsquo;s temporarily removed from the Element tree and may be reattached later.\nThere are two main types of Key: LocalKey and GlobalKey. LocalKey is further divided into UniqueKey, ValueKey, and ObjectKey. Let\u0026rsquo;s unmask each one.\nUniqueKey ‚Äì The Untraceable Assassin A mysterious figure, appearing and disappearing, never showing up twice with the same value. It creates unique values to help Flutter distinguish between two Widgets even if they have the same type. Use it when you don\u0026rsquo;t want to reuse any Widget, ensuring the Widget is completely rebuilt.\nFirst, let\u0026rsquo;s create an Item widget that simply displays a Text, but we\u0026rsquo;ll use StatefulWidget so you can clearly see the init and rebuild process.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Item extends StatefulWidget { final String text; const Item({super.key, required this.text}); @override State\u0026lt;Item\u0026gt; createState() =\u0026gt; _ItemState(); } class _ItemState extends State\u0026lt;Item\u0026gt; { @override void initState() { super.initState(); debugPrint(\u0026#39;[_ItemState.initState] key = ${widget.key}, text = ${widget.text}\u0026#39;); } @override Widget build(BuildContext context) { debugPrint(\u0026#39;[_ItemState.build] key = ${widget.key}, text = ${widget.text}\u0026#39;); return Text(widget.text); } } Next, create a ListView containing those Item widgets, without passing any Key to the items.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 final names = [\u0026#39;Henry\u0026#39;, \u0026#39;Techie\u0026#39;, \u0026#39;Nam\u0026#39;, \u0026#39;Anh\u0026#39;, \u0026#39;Nguyen\u0026#39;]; class HomePage extends StatefulWidget { const HomePage({super.key}); @override State\u0026lt;HomePage\u0026gt; createState() =\u0026gt; _HomePageState(); } class _HomePageState extends State\u0026lt;HomePage\u0026gt; { int _counter = 0; void _incrementCounter() { setState(() { _counter++; }); } @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar(title: Text(\u0026#39;Demo Key\u0026#39;)), body: ListView.builder( itemCount: _counter, itemBuilder: (context, index) =\u0026gt; Item( text: names[index], ), ), floatingActionButton: FloatingActionButton( onPressed: _incrementCounter, child: Icon(Icons.add), ), ); } } Check the log: when you click the FloatingActionButton to create each item, only the newest widget calls initState, others just rebuild. Here\u0026rsquo;s the log when creating the 5th item:\n1 2 3 4 5 6 [_ItemState.build] key = null, text = Henry [_ItemState.build] key = null, text = Techie [_ItemState.build] key = null, text = Nam [_ItemState.build] key = null, text = Anh [_ItemState.initState] key = null, text = Nguyen [_ItemState.build] key = null, text = Nguyen Now, let\u0026rsquo;s assign the UniqueKey assassin. Add UniqueKey to Item:\n1 2 3 4 5 6 7 body: ListView.builder( itemCount: _counter, itemBuilder: (context, index) =\u0026gt; Item( key: UniqueKey(), text: names[index], ), ), Everything changes: when clicking FloatingActionButton to create each item, all widgets are recreated. Even the Key value changes each time. Here\u0026rsquo;s the log for the 5th item; not only item 5 but all items 1 to 4 are also re-initialized:\n1 2 3 4 5 6 7 8 9 10 [_ItemState.initState] key = [#c24b5], text = Henry [_ItemState.build] key = [#c24b5], text = Henry [_ItemState.initState] key = [#02979], text = Techie [_ItemState.build] key = [#02979], text = Techie [_ItemState.initState] key = [#0a0db], text = Nam [_ItemState.build] key = [#0a0db], text = Nam [_ItemState.initState] key = [#23d4d], text = Anh [_ItemState.build] key = [#23d4d], text = Anh [_ItemState.initState] key = [#614a4], text = Nguyen [_ItemState.build] key = [#614a4], text = Nguyen ValueKey ‚Äì The Reliable Butcher A simple-minded but highly effective worker, ValueKey is perfect when you have a clear identifier value, such as a String or int. This butcher helps Element know which Widget to keep based solely on that identifier, allowing you to reuse Widgets when the Key value doesn\u0026rsquo;t change.\nLet\u0026rsquo;s update the previous ListView example to ReorderableListView. Since ReorderableListView requires each item to have a Key, we\u0026rsquo;ll start with Item using ValueKey.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 body: ReorderableListView( onReorder: (oldIndex, newIndex) { setState(() { if (newIndex \u0026gt; oldIndex) newIndex -= 1; final item = names.removeAt(oldIndex); names.insert(newIndex, item); }); }, children: names .map((item) =\u0026gt; Item( key: ValueKey(item), text: item, )) .toList(), ), Now, whenever you drag to reorder items, you\u0026rsquo;ll see the items being rebuilt:\n1 2 3 4 5 [_ItemState.build] key = [\u0026lt;\u0026#39;Henry\u0026#39;\u0026gt;], text = Henry [_ItemState.build] key = [\u0026lt;\u0026#39;Techie\u0026#39;\u0026gt;], text = Techie [_ItemState.build] key = [\u0026lt;\u0026#39;Nam\u0026#39;\u0026gt;], text = Nam [_ItemState.build] key = [\u0026lt;\u0026#39;Anh\u0026#39;\u0026gt;], text = Anh [_ItemState.build] key = [\u0026lt;\u0026#39;Nguyen\u0026#39;\u0026gt;], text = Nguyen What if you change the value of an item after dragging by updating the onReorder function? For example, when dragging \u0026lsquo;Henry\u0026rsquo;, change its value to \u0026lsquo;Henry Changed\u0026rsquo;:\n1 2 3 4 5 6 7 onReorder: (oldIndex, newIndex) { setState(() { if (newIndex \u0026gt; oldIndex) newIndex -= 1; final item = \u0026#39;${names.removeAt(oldIndex)} Changed\u0026#39;; names.insert(newIndex, item); }); }, The value changes, so the ValueKey changes, and the item is recreated:\n1 2 [_ItemState.initState] key = [\u0026lt;\u0026#39;Henry Changed\u0026#39;\u0026gt;], text = Henry Changed [_ItemState.build] key = [\u0026lt;\u0026#39;Henry Changed\u0026#39;\u0026gt;], text = Henry Changed ObjectKey ‚Äì The Strategic Advisor Unlike ValueKey, this one is a master strategist, holding a complex object. ObjectKey relies on object reference. Two Keys are considered equal only if they reference the same object.\nSimilar to the ValueKey example, let\u0026rsquo;s update it to use ObjectKey instead.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class _HomePageState extends State\u0026lt;HomePage\u0026gt; { final List\u0026lt;Person\u0026gt; people = [ Person(name: \u0026#34;Henry\u0026#34;), Person(name: \u0026#34;Techie\u0026#34;), Person(name: \u0026#34;Nam\u0026#34;), Person(name: \u0026#34;Anh\u0026#34;), Person(name: \u0026#34;Nguyen\u0026#34;), ]; @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar(title: Text(\u0026#39;Demo Key\u0026#39;)), body: ReorderableListView( onReorder: (oldIndex, newIndex) { setState(() { if (newIndex \u0026gt; oldIndex) newIndex -= 1; final item = people.removeAt(oldIndex); people.insert(newIndex, item); }); }, children: people .map((item) =\u0026gt; Item( key: ObjectKey(item), text: item.name, )) .toList(), ), ); } } class Person { final String name; Person({required this.name}); } GlobalKey ‚Äì The Powerful Butler In the gang, GlobalKey is the strongest. It knows everything in the Widget Tree. Not only does it store identity, but it also manages the entire state and allows direct access to State. This brings flexibility but can be easily abused.\nThe most common example is using GlobalKey to control and validate the state of a Form.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class GlobalKeyExample extends StatelessWidget { final GlobalKey\u0026lt;FormState\u0026gt; formKey = GlobalKey\u0026lt;FormState\u0026gt;(); @override Widget build(BuildContext context) { return Form( key: formKey, child: Column( children: [ TextFormField(validator: (value) =\u0026gt; value!.isEmpty ? \u0026#39;Required\u0026#39; : null), ElevatedButton( onPressed: () { if (formKey.currentState!.validate()) { print(\u0026#39;Form is valid!\u0026#39;); } }, child: Text(\u0026#39;Submit\u0026#39;), ), ], ), ); } } Best Practices for Using Key Key is not just a tool, but a treasure for controlling your app. Understanding and using Key correctly not only optimizes performance but also ensures your app\u0026rsquo;s logic remains stable and accurate. Overusing it can make your code unnecessarily complex, so use it only when needed. Remember, in the ever-changing world of Flutter, Key is the key to smooth apps you develop!\n","date":"2025-05-12T00:00:00+07:00","image":"https://namanh11611.github.io/p/key/key_hu_11b7192910d2897a.webp","permalink":"https://namanh11611.github.io/p/key/","title":"Investigation Case: Decoding the Mystery of Key in Flutter"},{"content":"Photo by Patrick Hendry on Unsplash\nIn the previous article Stack and Heap Memory in Java, I mentioned Memory Leaks as a cause of java.lang.OutOfMemoryError. Today, let\u0026rsquo;s dive into specific examples that cause Memory Leaks to learn how to prevent and fix them. Let\u0026rsquo;s get started and diagnose each case like an IT doctor!\nStatic Reference to Context Sometimes, by mistake, you might declare an Activity or Context as a static variable. This keeps a reference to the Activity or Context in that static variable, preventing the Garbage Collector from reclaiming memory and leading to a memory leak. You can read more about how the Garbage Collector works in this article.\n1 2 3 4 5 6 7 8 9 class MemoryLeakExample { companion object { var context: Context? = null // Static reference to Context } fun initialize(context: Context) { this.context = context } } 1 2 3 object MySingleton { var context: Context? = null } To fix this, use applicationContext instead of the Activity context.\n1 2 3 4 5 6 7 8 9 class MemorySafeExample { companion object { var context: Context? = null } fun initialize(context: Context) { this.context = context.applicationContext // Use applicationContext instead of Activity context } } Or, if you must store context in a singleton/static, use WeakReference:\n1 2 3 4 5 6 7 8 9 object MySingleton { private var weakContext: WeakReference\u0026lt;Context\u0026gt;? = null fun setContext(context: Context) { weakContext = WeakReference(context.applicationContext) } fun getContext(): Context? = weakContext?.get() } Inner Class (Non-Static) Inner classes always carry an implicit reference to the outer class. So, if a Handler, Runnable, etc. in an inner class continues to exist after the Activity is destroyed, it can cause a memory leak.\n1 2 3 4 5 6 7 8 9 10 11 class MainActivity : AppCompatActivity() { private val handler = Handler(Looper.getMainLooper()) override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) handler.postDelayed({ // Code that refers to activity }, 1000) } } To fix this, use WeakReference or a static inner class:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 class MainActivity : AppCompatActivity() { private val handler = Handler(Looper.getMainLooper()) override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) val weakActivity = WeakReference(this) handler.postDelayed({ weakActivity.get()?.let { // Safe usage of activity } }, 1000) } } Forgetting to Unregister Listener Forgetting to unregister a listener or BroadcastReceiver after an Activity/Fragment is destroyed can prevent the activity from being reclaimed by the Garbage Collector.\n1 2 3 4 5 6 7 8 9 10 11 class MainActivity : AppCompatActivity() { private lateinit var receiver: BroadcastReceiver override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) receiver = BroadcastReceiver { context, intent -\u0026gt; } registerReceiver(receiver, IntentFilter(\u0026#34;com.example.MY_ACTION\u0026#34;)) } // Forgot to unregister receiver } Always remember to unregister listeners/receivers in onDestroy():\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 class MainActivity : AppCompatActivity() { private lateinit var receiver: BroadcastReceiver override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) receiver = BroadcastReceiver { context, intent -\u0026gt; } registerReceiver(receiver, IntentFilter(\u0026#34;com.example.MY_ACTION\u0026#34;)) } override fun onDestroy() { super.onDestroy() unregisterReceiver(receiver) // Unregister when activity is destroyed } } Long-Running Async Task or Thread Background tasks like coroutine, thread, or Runnable that continue running after the Activity is destroyed and still hold a reference to the old Activity are also a common cause of memory leaks.\nSome solutions for this case:\nCancel coroutine/async tasks in onDestroy() Use lifecycleScope/viewModelScope to automatically cancel tasks when the lifecycle ends Conclusion Besides remembering and applying the best practices above, you can also use tools like LeakCanary or Memory Profiler in Android Studio to monitor and debug memory leaks. Understanding and avoiding memory leaks will help your Android app save RAM and run more smoothly.\n","date":"2025-05-11T11:00:00+07:00","image":"https://namanh11611.github.io/p/memory-leak/memory_leak_hu_93e7dea74cbe6edb.webp","permalink":"https://namanh11611.github.io/p/memory-leak/","title":"IT Doctor Diagnoses Common Memory Leak Cases in Android"},{"content":"There\u0026rsquo;s a long-standing debate: \u0026ldquo;Is grinding algorithms only for coding interviews and not really useful in real work?\u0026rdquo; Of course, there are obvious examples like ride-hailing apps, which must use pathfinding algorithms‚Äîa classic algorithm we learned in college. But writing such important algorithms seems to be the job of a small number of senior developers, while most of us do simpler tasks, not knowing when we\u0026rsquo;ll get to use the knowledge we\u0026rsquo;ve worked so hard to acquire. Are we wasting a lot of time?\nSo today\u0026rsquo;s article will share a problem I encountered in a project, and how practicing LeetCode helped me solve it. I\u0026rsquo;m not bragging‚Äîthis is just a small algorithm, nothing world-changing. I just want to show that: \u0026ldquo;Oh, so grinding algorithms can sometimes be applied to real projects!\u0026rdquo; üòú\nThe Problem I\u0026rsquo;m building an English speaking app called Speakie, mainly to solve my own pain point: I can\u0026rsquo;t speak full sentences in conversation, often pausing to think about grammar. So the lessons in the app are based on common conversational sentence patterns.\nQuick ad break:\nAndroid: https://play.google.com/store/apps/details?id=com.areser.speakie\niOS: https://apps.apple.com/app/speakie/id6593695505\nThe problem: when a user says a sentence, I need to compare it to the sample sentence, coloring correct words green and incorrect words red. And I want to color as many words green as possible to encourage the user.\nExample:\nSample sentence: Hello World! Welcome to my app Speakie.\nUser\u0026rsquo;s sentence: Hello Henry! Welcome to my world.\n==\u0026gt; The sample sentence should have \u0026ldquo;Hello\u0026rdquo;, \u0026ldquo;Welcome\u0026rdquo;, \u0026ldquo;to\u0026rdquo;, \u0026ldquo;my\u0026rdquo; colored green.\nA naive solution is to use a Set to store the user\u0026rsquo;s words, then check each word in the sample‚Äîif it\u0026rsquo;s in the set, color it green, otherwise red. But this doesn\u0026rsquo;t preserve word order. For example, if \u0026ldquo;world\u0026rdquo; appears out of order, this method would still color it green.\nWhile working, I noticed some popular English learning apps still make this mistake‚Äîyou can test by intentionally saying words out of order üòâ\nLeetCode problem Thinking of a solution, I immediately remembered the Longest Common Subsequence problem. The problem:\nGiven two strings text1 and text2, return the length of their longest common subsequence. If there is no common subsequence, return 0.\nA subsequence of a string is a new string formed from the original by deleting some (or no) characters without changing the order of the remaining characters.\nFor example, \u0026ldquo;ace\u0026rdquo; is a subsequence of \u0026ldquo;abcde\u0026rdquo;.\nBase solution This problem requires Dynamic Programming. For example, with text1 = \u0026ldquo;XMJYAUZ\u0026rdquo;, text2 = \u0026ldquo;MZJAWXU\u0026rdquo;, we create a 2D array to store the length of the longest common subsequence as we iterate:\nYou can understand:\nRow 0: text1 is empty, text2 = \u0026ldquo;MZJAWXU\u0026rdquo;, no subsequence =\u0026gt; 0 Row 1: text1 = \u0026ldquo;X\u0026rdquo;, text2 = \u0026ldquo;MZJAWXU\u0026rdquo;, subsequence = \u0026ldquo;X\u0026rdquo; =\u0026gt; 1 Row 2: text1 = \u0026ldquo;XM\u0026rdquo;, text2 = \u0026ldquo;MZJAWXU\u0026rdquo;, subsequence = \u0026ldquo;X\u0026rdquo; or \u0026ldquo;M\u0026rdquo; =\u0026gt; 1 Row 3: text1 = \u0026ldquo;XMJ\u0026rdquo;, text2 = \u0026ldquo;MZJAWXU\u0026rdquo;, subsequence = \u0026ldquo;MJ\u0026rdquo; =\u0026gt; 2 \u0026hellip; In general, for character i of text1 and j of text2:\nIf text1[i] == text2[j], then length[i][j] = length[i - 1][j - 1] + 1 If text1[i] != text2[j], then length[i][j] = max(length[i - 1][j], length[i][j - 1]) Full source code:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 public int longestCommonSubsequence(String text1, String text2) { int n1 = text1.length(), n2 = text2.length(); int[][] length = new int[n1 + 1][n2 + 1]; for (int i = 1; i \u0026lt;= n1; ++i) { for (int j = 1; j \u0026lt;= n2; ++j) { if (text1.charAt(i - 1) == text2.charAt(j - 1)) { length[i][j] = length[i - 1][j - 1] + 1; } else { length[i][j] = Math.max(length[i - 1][j], length[i][j - 1]); } } } return length[n1][n2]; } Space Optimization solution The above is the most understandable and matches our analysis. However, there\u0026rsquo;s a more memory-efficient way‚Äîsee Solutions.\nWhen iterating row i, we only need values from row i - 1 and the value of length[i][j - 1]. So instead of a 2D array, we just need 1 array and two variables prevRowCol, prevRow:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 public int longestCommonSubsequence(String text1, String text2) { int n1 = text1.length(), n2 = text2.length(); if (n1 \u0026lt; n2) { return longestCommonSubsequence(text2, text1); } int[] length = new int[n2 + 1]; for (int i = 1; i \u0026lt;= n1; ++i) { for (int j = 1, prevRow = 0, prevRowCol = 0; j \u0026lt;= n2; ++j) { prevRowCol = prevRow; prevRow = length[j]; if (text1.charAt(i - 1) == text2.charAt(j - 1)) { length[j] = prevRowCol + 1; } else { length[j] = Math.max(length[j - 1], prevRow); } } } return length[n2]; } Applying to the problem See the connection to our original problem? We just replace characters with words to find the common words in the sample and user sentences. However, the LeetCode problem only gives the length of the subsequence, while we want to know which words are in the subsequence to color them.\nBoolean array My first thought was to use a Boolean array with the length of the sample sentence, marking true for words that appear and false for those that don\u0026rsquo;t. But the problem is, at each step when considering length[i][j] = max(length[i - 1][j], length[i][j - 1]), we need the Boolean arrays of both [i - 1][j] and [i][j - 1] to set the Boolean array for [i][j] according to the larger length. This means we need another array similar to length, but each element is a Boolean array‚Äîa 2D Boolean array.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 // For simplicity, sample (the sample sentence) and input (the user\u0026#39;s sentence) have been // converted from sentences to lists of words, all lowercase, no accents... public void displaySampleSentence(String[] sample, String[] input) { int sampleLength = sample.length, inputLength = input.length; int[] length = new int[inputLength + 1]; boolean[][] match = new boolean[inputLength + 1][sampleLength + 1]; boolean[] prevRowMatch = new boolean[sampleLength + 1]; boolean[] prevRowColMatch = new boolean[sampleLength + 1]; for (int i = 1; i \u0026lt;= sampleLength; ++i) { for (int j = 1, prevRow = 0, prevRowCol = 0; j \u0026lt;= inputLength; ++j) { prevRowCol = prevRow; prevRow = length[j]; prevRowColMatch = prevRowMatch; prevRowMatch = match[j]; if (sample[i - 1].equals(input[j - 1])) { length[j] = prevRowCol + 1; match[j] = prevRowColMatch; match[j][i] = true; } else if (length[j - 1] \u0026gt;= prevRow) { length[j] = length[j - 1]; match[j] = match[j - 1]; } } } for (int i = 1; i \u0026lt;= sampleLength; ++i) { if (match[inputLength][i]) { // Display sample[i - 1] as green word } else { // Display sample[i - 1] as red word } } } Integer and Bit manipulation To make it simpler and lighter, I thought of using an int instead of a Boolean array, and using bitwise operations‚Äîset bit = 1 for true, bit = 0 for false. On Android and iOS, Dart\u0026rsquo;s int uses 64 bits. If each bit represents a word, we can store up to 64 words‚Äîmore than enough for my app.\nA quick reminder about bitwise operations. To set the i-th bit to true, use OR and SHIFT LEFT:\n1 2 3 4 5 6 7 match |= 1 \u0026lt;\u0026lt; i; // Example: match = 1, i = 3 match = 0001 1 \u0026lt;\u0026lt; i = 1000 match | (1 \u0026lt;\u0026lt; i) = 1001 // =\u0026gt; match = 9 // So we\u0026#39;ve set the 3rd bit from the right (0th index) to 1 (TRUE) To get the value of the i-th bit, use SHIFT RIGHT and AND:\n1 2 3 4 5 6 7 int value = (match \u0026gt;\u0026gt; i) \u0026amp; 1; // Example: match = 25, i = 3 match = 0001 1001 match \u0026gt;\u0026gt; i = 0000 0011 (match \u0026gt;\u0026gt; i) \u0026amp; 1 = 1 // So the value of the 3rd bit from the right (0th index) is 1 (TRUE) Applying this to the above solution, we have:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 public void displaySampleSentence(String[] sample, String[] input) { int sampleLength = sample.length, inputLength = input.length; int[] length = new int[inputLength + 1]; int[] match = new int[inputLength + 1]; int prevRowMatch = 0, prevRowColMatch = 0; for (int i = 1; i \u0026lt;= sampleLength; ++i) { for (int j = 1, prevRow = 0, prevRowCol = 0; j \u0026lt;= inputLength; ++j) { prevRowCol = prevRow; prevRow = length[j]; prevRowColMatch = prevRowMatch; prevRowMatch = match[j]; if (sample[i - 1].equals(input[j - 1])) { length[j] = prevRowCol + 1; match[j] = prevRowColMatch; match[j][i] = true; } else if (length[j - 1] \u0026gt;= prevRow) { length[j] = length[j - 1]; match[j] = match[j - 1]; } } } for (int i = 1; i \u0026lt;= sampleLength; ++i) { if (match[inputLength][i]) { // Display sample[i - 1] as green word } else { // Display sample[i - 1] as red word } } } L·ªùi k·∫øt Algorithms are still a foundational element in this programming field. Over time, technologies may become outdated or rise in popularity, but algorithms remain, standing the test of time.\nThrough this interesting example, I hope you\u0026rsquo;ll be more excited about learning algorithms and applying them to real-world problems.\nReference https://leetcode.com/problems/longest-common-subsequence https://wikipedia.org/wiki/Longest_common_subsequence https://dart.dev/guides/language/numbers ","date":"2025-05-11T01:00:00+07:00","image":"https://namanh11611.github.io/p/speakie/speakie_hu_c0af73856384bc9a.webp","permalink":"https://namanh11611.github.io/p/speakie/","title":"Applying LeetCode Algorithms to the Speakie English Learning App"},{"content":"Photo by 7 on Unsplash\nRecently, I\u0026rsquo;ve spent time building apps like Habit Tree and Speakie (you can see more at Areser), or occasionally working on some outsource projects for clients. Every time I start a new project, I spend a whole day setting up architecture, routing, auth, state management\u0026hellip; for the app. So, from real needs, I thought about building a lightweight Flutter base project to start as quickly as possible. And that\u0026rsquo;s why Flutter MVVM Riverpod Starter was born.\nCheck it out here: https://github.com/namanh11611/flutter_mvvm_riverpod\nüöÄ Why choose this starter? My goal is to create a lightweight template, but powerful enough for indie hackers and solo developers. That\u0026rsquo;s why I didn\u0026rsquo;t choose Clean Architecture‚Äîit\u0026rsquo;s too bulky for my target users. Think about it: for projects done solo or with a small team of 2-3 people, 99.99% of the time you won\u0026rsquo;t need an Abstract Repository for multiple implementations. Andrea‚Äîa well-known Flutter developer‚Äîalso mentioned this in Flutter App Architecture: The Repository Pattern.\nAfter weighing the options, I chose the MVVM (Model - View - ViewModel) architecture, simply using ViewModel to separate logic from UI.\nI also chose Riverpod, a state management solution for flexible state handling. I know most of you use BloC more, but I\u0026rsquo;m not judging which is better‚Äîit\u0026rsquo;s just that Riverpod lets me write shorter code than BloC.\nNext is the Backend. I know most solo developers will integrate Firebase, but it has one issue\u0026hellip; EXPENSIVE (when your project starts to scale). So I chose Supabase, similar to Firebase but CHEAPER. I\u0026rsquo;ve already integrated setup code and some authentication functions.\nIf you want to monetize your app, you can\u0026rsquo;t miss RevenueCat, which helps manage in-app purchases and subscriptions.\nThere\u0026rsquo;s also Dark/Light Theme, Localization, routing, local storage, analytics, crashlytics\u0026hellip; all ready to go.\nüìö Libraries Used Purpose Libraries State flutter_riverpod, riverpod_annotation Auth \u0026amp; Backend supabase_flutter, google_sign_in, sign_in_with_apple Navigation go_router UI/UX google_fonts, flutter_svg, shimmer, lottie Storage shared_preferences, sqflite HTTP dio, connectivity_plus Utils uuid, envied, easy_localization Monetization purchases_flutter, in_app_purchase Analytics firebase_analytics, firebase_crashlytics üèó Project Architecture For project architecture, I chose Feature-first (layer folders inside feature folders). For each feature like authentication, onboarding\u0026hellip; I create a folder inside features. Then inside that folder, I create layer folders like model, repository, ui.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 lib/ ‚îú‚îÄ‚îÄ constants/ # Constants, global config ‚îú‚îÄ‚îÄ environment/ # Environment variables ‚îú‚îÄ‚îÄ extensions/ # Extension/helper methods ‚îú‚îÄ‚îÄ features/ # Feature modules by folder ‚îÇ ‚îú‚îÄ‚îÄ authentication/ ‚îÇ ‚îú‚îÄ‚îÄ model/ ‚îÇ ‚îú‚îÄ‚îÄ repository/ ‚îÇ ‚îú‚îÄ‚îÄ ui/ ‚îÇ ‚îú‚îÄ‚îÄ onboarding/ ‚îÇ ‚îú‚îÄ‚îÄ home/ ‚îÇ ‚îú‚îÄ‚îÄ profile/ ‚îÇ ‚îú‚îÄ‚îÄ premium/ ‚îú‚îÄ‚îÄ routing/ # Route config with go_router ‚îú‚îÄ‚îÄ theme/ # UI config ‚îî‚îÄ‚îÄ utils/ # Common utilities You\u0026rsquo;ll notice there are no layers like domain or data.\nUsually with Clean Architecture, your domain would have model, abstract repository, use case, but now, without needing abstract repository and use case, I can simplify it to just model.\nAs for data, for features that only need to access remote or local data, I\u0026rsquo;ll call functions directly in the repository. For features needing both types of data, I\u0026rsquo;ll consider creating a data source if necessary.\nüéâ Conclusion The vibe coding movement is growing, but I still want to vibe code with control. With this base project, I can guide AI to code the way I want. If it goes off track, I can quickly adjust.\nAs mentioned from the start, this project is for indie hackers and solo developers who want to launch an MVP quickly, helping you focus on business logic instead of spending all day setting up and writing boilerplate. So it might not be suitable for your team if you have many members and need a base project with standard Clean Architecture.\nIf you find it useful, don\u0026rsquo;t hesitate to give me a star!\nGitHub Link: https://github.com/namanh11611/flutter_mvvm_riverpod\n","date":"2025-05-11T00:00:00+07:00","image":"https://namanh11611.github.io/p/flutter-mvvm-riverpod/fmr_hu_aa453045b1a5aee8.webp","permalink":"https://namanh11611.github.io/p/flutter-mvvm-riverpod/","title":"Flutter MVVM Riverpod Starter: Build Apps Lightning Fast for Vibe Coders"},{"content":"Photo by Frames For Your Heart on Unsplash\nIn the programming world, Builder Pattern is known as one of the popular design patterns in the Creational Pattern group, helping to create complex objects in a flexible and readable way. You may have encountered it in your code but not noticed. In older programming languages, implementing the Builder Pattern could be lengthy and complicated, but newer languages have made it much easier. Today, let\u0026rsquo;s explore the journey of Builder Pattern from 60 lines of Java code to just 1 line in Kotlin.\nWhat is the Builder Pattern? In software development, there are many classes that need to be initialized with various properties. For example, a House class might have properties like wall, door, window, roof, garage\u0026hellip;\nNormally, to initialize an instance of this class, you might write:\n1 House myHouse = new House(4, 2, 4, 1, 1); Reading this code, you might wonder what 4 and 2 mean. If you use a regular constructor or setters for each property, you may encounter issues like:\nHard to read and easy to confuse: Calling a constructor with many parameters without knowing their meaning can be confusing. Prone to errors: If the order of parameters is wrong, the compiler may not catch it if the parameters have the same type. Lack of flexibility: If some properties are optional, you\u0026rsquo;ll need many overloaded constructors or setters, making the code messy. Risk of creating objects in an invalid state: If not all necessary setters are called, the object may lack required data. That\u0026rsquo;s why the Builder Pattern was created to solve these problems by moving the code for initializing properties out of the class and into another class called the Builder. You can see the illustration below:\nSeparating the code into HouseBuilder allows you to create objects step by step, clearly and flexibly. You can choose which properties to set and which to skip.\nLet\u0026rsquo;s look at the implementation in Java next.\nJava: Full Builder Pattern Leaving houses aside, let\u0026rsquo;s look at another classic example: the User class.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 public class User { private final String name; private final int age; private final String address; private final boolean isVerified; private final boolean isDeleted; private User(Builder builder) { this.name = builder.name; this.age = builder.age; this.address = builder.address; this.isVerified = builder.isVerified; this.isDeleted = builder.isDeleted; } public static class Builder { private String name; private int age; private String address; private boolean isVerified; private boolean isDeleted; public Builder setName(String name) { this.name = name; return this; } public Builder setAge(int age) { this.age = age; return this; } public Builder setAddress(String address) { this.address = address; return this; } public Builder setVerified(boolean verified) { this.isVerified = verified; return this; } public Builder setDeleted(boolean deleted) { this.isDeleted = deleted; return this; } public User build() { return new User(this); } } } User user = new User.Builder() .setName(\u0026#34;Henry Techie\u0026#34;) .setAge(30) .setAddress(\u0026#34;Hanoi\u0026#34;) .setVerified(true) .setDeleted(false) .build(); As you can see, it takes 60 lines of code to set up the Builder Design Pattern in Java. For classes with more properties, the boilerplate code increases.\nSimplified in Kotlin With Kotlin and other modern languages (Python, Swift, Dart\u0026hellip;), things are simplified thanks to Named Arguments.\nKotlin natively supports named arguments and default values, so you don\u0026rsquo;t need to implement the Builder Pattern manually:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 data class User( val name: String, val age: Int, val address: String = \u0026#34;\u0026#34;, val isVerified: Boolean = false, val isDeleted: Boolean = false ) val user = User( name = \u0026#34;Henry Techie\u0026#34;, age = 30, address = \u0026#34;Hanoi\u0026#34; ) val user = User( name = \u0026#34;Henry Techie\u0026#34;, age = 30, isVerified = true ) Tada\u0026hellip; No need for a builder class, no need for 60 lines of setters. Just 1 line of code to create an object with flexible parameters. You can declare or skip address, isVerified, and isDeleted as you wish.\nConclusion From the full Builder Pattern in Java to data class and named arguments in Kotlin, we\u0026rsquo;ve witnessed a wonderful simplification. That\u0026rsquo;s why I said Builder Pattern appears in every breath of our code, you just haven\u0026rsquo;t noticed it yet.\nHave a great weekend!\n","date":"2025-05-10T00:00:00+07:00","image":"https://namanh11611.github.io/p/design-pattern-builder/builder_hu_4a815514bb6ed862.webp","permalink":"https://namanh11611.github.io/p/design-pattern-builder/","title":"Design Pattern: The Journey of Builder Pattern - from 60 lines of Java to 1 line of Kotlin"},{"content":"Photo by AltumCode on Unsplash\nWill AI Replace Developers Soon? Many people have asked me whether AI is about to replace developers. My answer, as of now, is NO. There still needs to be someone to verify the code that AI produces.\nHowever, the tech industry evolves rapidly. Technologies that are hot today might become obsolete tomorrow. For example, six years ago when I graduated, coding for Android was primarily done using Java. But now, if you only know Java without Kotlin, it‚Äôs incredibly difficult to find a job.\nSo, will AI replace developers in the next 5 years or 10 years? I can‚Äôt say for certain.\nAI is Changing the Way We Work That said, it‚Äôs clear that AI is transforming how we work.\nIn the past, a developer‚Äôs primary job was to convert requirements and designs into code. Tech leads and seniors would spend additional time in meetings to clarify requirements, but junior developers spent most of their time coding. It could take months or even years to deliver a product.\nRecently, I‚Äôve been working on a new personal project. Today marks day 10, but with the help of Cursor, the code I‚Äôve written or directly modified accounts for just 5%.\nIn the past, using ChatGPT, you could only generate small components and then copy them into your project. Even then, you‚Äôd need to spend a lot of time fixing them to fit. But with Cursor, it‚Äôs different. It understands the project context. By providing it with a base project and some pre-written files, it can replicate 99% of the format, and the code is almost ready to use with little or no modifications.\nCursor acts as an AI Agent: after generating code, it even creates new files, runs the project to check for errors, and fixes them automatically before asking me to review the changes.\nMy role now resembles that of a technical lead: I define tasks for Cursor, review its output, and ask it to fix anything suboptimal. Once I‚Äôm satisfied, I merge the code.\nBut to review AI-generated code, you must understand what each line means and identify what isn‚Äôt optimized so you can instruct it to make corrections. Blindly applying AI-generated solutions can be risky. If bugs arise later, you may not know how to fix them.\nThe Reality Currently, a barrier to adoption in large companies is their hesitation to use AI due to data security concerns. Additionally, their codebases are vast, and using general AI tools to train on them can be token-intensive. AI has limitations in the number of tokens it can retain.\nFor me, AI isn‚Äôt much help in my company projects. However, for small companies or indie hackers, these barriers are less significant, creating opportunities to accelerate software development. Imagine cutting down the time to build an MVP from months to just weeks, or even days.\nThe numbers don‚Äôt lie‚Äîtraffic to StackOverflow is declining. Developers are now asking AI for help more often than they use Google.\nReturning to the question at the start: if a team once required 3 seniors and 7 juniors, but after adopting AI, productivity improves and the team now only needs 3 seniors and 4 juniors, hasn‚Äôt AI effectively replaced 3 juniors? More accurately, those who effectively leverage AI are taking over the roles of those who don‚Äôt.\nConclusion As the new year begins, I‚Äôm reflecting on my work so that future me can look back on this. During the First Industrial Revolution, machines replaced humans in tedious manual labor, freeing us to focus our intellect on other tasks. Let‚Äôs see where AI will take us in the next 5 years or 10 years.\n","date":"2025-01-01T00:00:00+07:00","image":"https://namanh11611.github.io/p/ai-change-work/ai_change_work_hu_736745160d46174b.webp","permalink":"https://namanh11611.github.io/p/ai-change-work/","title":"AI is Changing How Software Engineers Work"},{"content":"Photo by Dillon Shook on Unsplash\nHave you ever struggled to choose one of the seven types of providers in Riverpod for specific use cases in your project? For instance, the documentation explains that both NotifierProvider and StateNotifierProvider are used when:\nA complex state object that is immutable except through an interface.\nOn the other hand, ChangeNotifierProvider are not recommended for scalable applications.\nWhat is going on??? The author really knows how to make developers feel confused‚Ä¶\nBut now, Remi Rousselet has introduced a new way to use Riverpod with code generation, making developers\u0026rsquo; lives a bit easier.\nSyntax In simple terms, code generation in Riverpod allows us to declare providers using the @riverpod annotation, and most of the code is automatically generated using Dart\u0026rsquo;s built-in build_runner tool.\nInstead of defining providers as before:\n1 2 3 4 final fetchUserProvider = FutureProvider.autoDispose.family\u0026lt;User, int\u0026gt;((ref, userId) async { final json = await http.get(\u0026#39;api/user/$userId\u0026#39;); return User.fromJson(json); }); Now, you only need to write:\n1 2 3 4 5 @riverpod Future\u0026lt;User\u0026gt; fetchUser(FetchUserRef ref, {required int userId}) async { final json = await http.get(\u0026#39;api/user/$userId\u0026#39;); return User.fromJson(json); } Instead of deliberating over which of the seven providers to use, you can now use the following table to quickly choose the appropriate provider for your use case:\nFunctional (Can‚Äôt perform side-effects using public methods) Class-Based (Can perform side-effects using public methods) Sync Async - Future Async - Stream keepAlive In this new approach, all providers are auto-dispose by default, meaning their state is destroyed when no listeners observe them. This is the opposite of the old approach (where you had to explicitly add autoDispose, and the default was no dispose).\nTo disable auto-dispose and keep your provider alive, use:\n1 @Riverpod(keepAlive: true) Parameters As seen in the earlier example, adding parameters to a provider is now as straightforward as adding parameters to a regular function. There‚Äôs no need to use family like in the old approach.\nFor functional providers, parameters are added directly to the function:\n1 2 3 4 5 6 7 8 @riverpod String example( ExampleRef ref, int param1, { String param2 = \u0026#39;foo\u0026#39;, }) { return \u0026#39;Hello $param1 \u0026amp; param2\u0026#39;; } For class-based providers, parameters are added to the build method:\n1 2 3 4 5 6 7 8 9 10 11 12 @riverpod class Example extends _$Example { @override String build( int param1, { String param2 = \u0026#39;foo\u0026#39;, }) { return \u0026#39;Hello $param1 \u0026amp; param2\u0026#39;; } // Add methods to mutate the state } Advantages Currently, using code generation or the old approach is optional. If you‚Äôre considering why you should switch, here are some reasons provided by the author:\nBetter syntax, more readable/flexible, and with a reduced learning curve. No need to worry about the type of provider. Write your logic, and Riverpod will pick the most suitable provider for you. The syntax no longer looks like we\u0026rsquo;re defining a \u0026ldquo;dirty global variable\u0026rdquo;. Instead we are defining a custom function/class. Passing parameters to providers is now unrestricted. Instead of being limited to using .family and passing a single positional parameter, you can now pass any parameter. This includes named parameters, optional ones, and even default values. Stateful hot-reload of the code written in Riverpod. Better debugging, through the generation of extra metadata that the debugger then picks up. Some Riverpod features will be available only with code generation. Disadvantages However, when applied to real-world projects, there are some drawbacks to consider.\nCurrently, as code generation is relatively new, few projects have adopted it, making it hard to find reference source code. For the most part, you‚Äôll rely on Riverpod‚Äôs documentation during development.\nIn this AI-driven era, developers often use tools to generate code. With limited adoption, most tools generate Riverpod code in the old style. But don‚Äôt worry! Android Studio has the Flutter Riverpod Snippets plugin, which helps you write code faster. Just type riverpod, and it will suggest the four main provider types.\nThese drawbacks are temporary. As code generation becomes more popular, these issues will be resolved. So there‚Äôs no need to worry too much.\nReference https://riverpod.dev/docs/concepts/about_code_generation ","date":"2024-10-11T00:00:00+07:00","image":"https://namanh11611.github.io/p/riverpod/riverpod_hu_8b01baf5f1bca1ab.webp","permalink":"https://namanh11611.github.io/p/riverpod/","title":"Using Code Generation Providers in Flutter Riverpod to Simplify Life"},{"content":"Photo by Etienne Girardet on Unsplash\nIn Android, performing heavy tasks like network requests or database operations on the main thread can cause the app to freeze or crash. To ensure smoother app performance, these tasks should be executed on a background thread to avoid blocking the main thread. For instance, when a user clicks the Submit button on the main thread, the network request will be processed on a background thread, and the result will be sent back to the main thread. Android provides tools such as Looper, MessageQueue, and Handler to manage concurrent tasks and handle message passing between threads.\nWait a second! Isn‚Äôt Kotlin Coroutines already solving these problems? That‚Äôs true; nowadays, Kotlin Coroutines are widely used for such use cases. However, in certain projects, for example Android Automotive, the trio of Looper, MessageQueue, and Handler is still essential.\nIn this article, I‚Äôll explain the role and responsibilities of each component and how they interact with one another. Since these components are closely intertwined, you might need to refer back to earlier sections to fully grasp the concepts. Take your time!\nLooper Looper is a class that manages the message loop for a thread, with each thread having exactly one Looper. If we dive into the Android SDK code, we can see the Looper class defined as follows:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 public final class Looper { // Looper contains the MessageQueue final MessageQueue mQueue; // The relationship between Looper and Thread is one-to-one final Thread mThread; public static void prepare() { prepare(true); } private static void prepare(boolean quitAllowed) { // Each thread can have only one Looper if (sThreadLocal.get() != null) { throw new RuntimeException(\u0026#34;Only one Looper may be created per thread\u0026#34;); } sThreadLocal.set(new Looper(quitAllowed)); } private Looper(boolean quitAllowed) { mQueue = new MessageQueue(quitAllowed); mThread = Thread.currentThread(); } } By default, threads are not associated with any message loop. To create a message loop, we need to call the Looper.prepare() method, as shown above. Then, we invoke the Looper.loop() method to process messages until the loop stops.\nHere‚Äôs an example of a Looper implementation:\n1 2 3 4 5 6 class LooperExampleThread extends Thread { public void run() { Looper.prepare(); Looper.loop(); } } MessageQueue MessageQueue is a data structure that holds a list of Message and Runnable objects to be processed. It operates on a FIFO (First-In-First-Out) basis. You can access the MessageQueue of the current thread using the Looper.myQueue() method.\nIn the Looper code above, you‚Äôll notice that each Looper has exactly one MessageQueue:\n1 2 3 4 public final class Looper { // Looper contains the MessageQueue final MessageQueue mQueue; } Messages are not added directly to the MessageQueue. Instead, they are added through a Handler. The Looper continuously extracts and processes messages from the queue.\nHandler Handler is a class used to send and process Message and Runnable objects linked to a thread‚Äôs MessageQueue. Each Handler is associated with a specific thread and its MessageQueue.\nWhen creating a Handler, you must pass a Looper to its constructor. Here‚Äôs an example of a typical constructor:\n1 public Handler(@NonNull Looper looper) {} The MessageQueue we mentioned earlier belongs to the Looper passed here, and messages will be executed on the same thread as that Looper.\nSome commonly used methods of Handler include:\npost(Runnable) postAtTime(java.lang.Runnable, long) postDelayed(Runnable, Object, long) sendEmptyMessage(int) sendMessage(Message) sendMessageAtTime(Message, long) sendMessageDelayed(Message, long) Handler serves two main purposes:\nScheduling tasks to run in the future. You can use methods like ...AtTime or ...Delayed. Executing tasks on a different thread from the current one. As mentioned earlier, you can specify the desired thread by passing its Looper when initializing the Handler. Communication Between Components When a Message or Runnable is sent via a Handler, it is added to the MessageQueue. The Looper continuously checks the MessageQueue for new messages. Upon finding a message, the Looper extracts it from the queue and forwards it to the corresponding Handler for processing. The Handler processes the message on the thread it is associated with. Here‚Äôs an illustrative code example:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class ProcessingThread extends Thread { public Handler mHandler; public void run() { Looper.prepare(); // Looper.myLooper() return the Looper object // associated with the current thread mHandler = new Handler(Looper.myLooper()) { public void handleMessage(Message msg) { // Process received messages } }; Looper.loop(); } } // ClientThread has a reference to the mHandler object // of ProcessingThread class ClientThread extends Thread { private void sendMessageExample() { Message msg = Message.obtain(mHandler, 1); msg.obj = \u0026#34;New message\u0026#34;; mHandler.sendMessage(msg); } private void sendRunnableExample() { mHandler.post(new Runnable() { @Override public void run() { // Task executed on ProcessingThread } }); } } HandlerThread In practice, developers rarely create and manage threads and Loopers manually. Android provides HandlerThread, a special type of thread with a built-in Looper property. You can retrieve its Looper using the getLooper() method.\n1 2 3 4 HandlerThread thread = new HandlerThread(\u0026#34;ProcessingThread\u0026#34;); thread.start(); Looper looper = thread.getLooper(); Handler handler = new Handler(looper); Main Thread The Main thread (UI thread) in Android already has a built-in Looper, which can be accessed via Looper.getMainLooper(). A common example is creating a Handler to delay a task on the UI thread, as follows:\n1 2 3 4 5 6 7 Handler handler = new Handler(Looper.getMainLooper()); handler.postDelayed(new Runnable() { @Override public void run() { // Delayed task } }, 3000); Conclusion Looper, MessageQueue, and Handler are essential components of Android‚Äôs asynchronous processing system. They work together to facilitate efficient and safe inter-thread communication. Understanding their operations can help you build robust Android applications. Thank you for reading!\nReference https://developer.android.com/reference/android/os/Looper https://developer.android.com/reference/android/os/MessageQueue https://developer.android.com/reference/android/os/Handler ","date":"2024-10-10T00:00:00+07:00","image":"https://namanh11611.github.io/p/looper-message-queue-handler/looper_message_queue_handler_hu_c79f168ed1c6e942.webp","permalink":"https://namanh11611.github.io/p/looper-message-queue-handler/","title":"All About Looper, MessageQueue, and Handler in Android"},{"content":"Photo by Felix Mittermeier on Unsplash\nGit Branching Strategy refers to the way we create branches, merge branches, and decide which branches are used for releases.\nWhen starting a project, beyond setting up the environment and building a solid codebase, selecting the right Git Branching Strategy is crucial. A wrong choice can lead to significant challenges. The right strategy helps the team manage and maintain source code effectively, reduce conflict resolution time, and ensure production code remains stable.\nOver time, various strategies have emerged. This article explores some popular Git Branching Strategies like Gitflow, GitHub Flow, GitLab Flow, and Trunk-Based Development. Finally, we‚Äôll discuss how to choose the right strategy for your project.\nGitflow Gitflow, introduced by Vincent Driessen, is well-suited for projects with clear and complex release cycles. Gitflow uses multiple branch types to manage the development and release phases.\nIn this flow, there are two main branches: master and develop. The master branch contains stable code ready for release, while develop contains the latest changes for the next release. It‚Äôs the main branch for feature integration.\nAdditionally, there are feature branches that are checkout from develop and used to develop new features. Once completed, they are merge back into develop.\nWhen ready for release, a branch is checked out from develop to a release branch with the corresponding version to prepare for the release. Bug fixes can be added as commits on this branch. Once finalized, the release branch is merge into both master and develop to keep the two main branches updated.\nFinally, there are hotfix branches. When production code encounters a critical bug that needs an immediate fix, a hotfix branch is checkout from master for the fix. Similar to release branches, hotfix branches must also be merge into both master and develop.\nAdvantages Provides a clear structure, ideal for large projects. Efficiently manages development and release phases with versioned release branches. Hotfix branches allow quick fixes without disrupting ongoing development. Disadvantages Complex and requires multiple branches and merges. For example, each release or hotfix branch needs to be merged into both master and develop. Unsuitable for projects requiring CI/CD. Challenging for small teams due to its cumbersome nature. GitHub Flow GitHub Flow is a lightweight, simple strategy ideal for CI/CD and commonly used in open-source projects or small teams.\nUnlike Gitflow, it has a single main branch, main, which contains thoroughly tested and stable code ready for production.\nFeatures are developed in feature branches, tested, reviewed, and merged into main via pull requests.\nAdvantages Simple and easy to understand, making it quick to implement. Perfect for CI/CD workflows, ensuring the main branch is always deployable. Fewer branches mean reduced conflicts and merge errors. Disadvantages Lacks the structure of Gitflow. Unsuitable for large projects or those requiring support for multiple versions. Does not define clear processes for releases or bug fixes. GitLab Flow GitLab Flow combines elements of Gitflow and GitHub Flow. It introduces environment branches like staging and production, making it suitable for CI/CD and tightly integrated with GitLab‚Äôs CI/CD tools.\nSimilar to GitHub Flow, GitLab Flow works directly with the primary branch, main, which contains stable source code ready for release. This flow also includes feature branches for developing new features.\nWhen the code on the main branch is ready for testing, we merge it into the staging branch. After testing and confirming it is ready for deployment, we merge the code from the staging branch into the production branch. GitLab Flow often uses release branches, such as release/v1 and release/v2, to independently manage and deploy different versions of the application.\nHowever, when there is a bug in production, you need to merge the code into the main branch first, then merge or cherry-pick it into other branches following the above process.\nAdvantages Simpler than Gitflow, but more structured than GitHub Flow. Well-suited for CI/CD projects with multiple environments. Supports independent management of different application versions using release branches. Disadvantages Best suited for GitLab and its CI/CD tools. Requires careful setup to leverage its full potential. Not ideal for projects without CI/CD requirements. Trunk-Based Development For a detailed discussion, refer to my article: Trunk-Based Development - A Git Workflow to Reduce Merge Conflicts. Trunk-Based Development (TBD) is a strategy where all developers work on a single main branch, typically main. Changes are continuously and quickly committed to this branch, minimizing the lifespan of feature branches.\nAdvantages Encourages CI and minimizes merge conflicts. Ideal for Agile and DevOps projects requiring CD. Easy to manage and track the codebase. Disadvantages Higher risk of directly committing errors to the main branch. Requires robust code reviews and automation tests to maintain stability. Unsuitable for large, distributed teams. Choosing the Right Strategy There‚Äôs no one-size-fits-all solution. The choice of Git branching strategy depends on factors like project scale, team structure, and development requirements. Below are some suggestions:\nProject Type Team Size Recommended Strategy Small to medium projects with continuous delivery Small, Medium GitHub Flow, TBD Scheduled and periodic releases Medium GitFlow, GitLab Flow CI/CD projects with multiple environments Medium, Large GitLab Flow Long-term maintenance projects Large GitFlow Each strategy has its pros and cons. The key is selecting one that aligns with your team‚Äôs workflow and project requirements. Doing so optimizes productivity and minimizes risks in source code management.\nReferrence https://nvie.com/posts/a-successful-git-branching-model https://docs.github.com/en/get-started/using-github/github-flow https://about.gitlab.com/topics/version-control/what-is-gitlab-flow https://www.gitkraken.com/learn/git/best-practices/git-branch-strategy https://www.geeksforgeeks.org/branching-strategies-in-git https://www.abtasty.com/blog/git-branching-strategies ","date":"2024-09-08T00:00:00+07:00","image":"https://namanh11611.github.io/p/git-branching-strategy/strategy_hu_855be4ab8416aaa9.webp","permalink":"https://namanh11611.github.io/p/git-branching-strategy/","title":"Gitflow, GitHub Flow, GitLab Flow, Trunk-Based Development: Which Git Branching Strategy is Right for You?"},{"content":"Photo by Ana Cruz on Unsplash\nTi·∫øp n·ªëi serie Kotlin cheat sheet, ch√∫ng ta c√πng ƒëi ƒë·∫øn v·ªõi cheat sheet cu·ªëi c√πng d√†nh cho SharedFlow v√† StateFlow.\nSharedFlow v√† StateFlow l√† hai lo·∫°i flow ƒë·∫∑c bi·ªát trong Kotlin Flow, cung c·∫•p c√°c t√≠nh nƒÉng m·∫°nh m·∫Ω cho vi·ªác chia s·∫ª tr·∫°ng th√°i v√† s·ª± ki·ªán gi·ªØa c√°c th√†nh ph·∫ßn kh√°c nhau trong ·ª©ng d·ª•ng. Trong ph·∫ßn cu·ªëi c·ªßa lo·∫°t b√†i vi·∫øt n√†y, ch√∫ng ta s·∫Ω t√¨m hi·ªÉu s√¢u v·ªÅ c√°ch s·ª≠ d·ª•ng SharedFlow v√† StateFlow, nh·ªØng l·ª£i √≠ch c·ªßa ch√∫ng, v√† c√°ch t√≠ch h·ª£p v√†o ·ª©ng d·ª•ng Android c·ªßa b·∫°n ƒë·ªÉ x·ª≠ l√Ω lu·ªìng d·ªØ li·ªáu m·ªôt c√°ch hi·ªáu qu·∫£ v√† m∆∞·ª£t m√† h∆°n.\nB·∫°n c√≥ th·ªÉ ƒë·ªçc to√†n b·ªô serie t·∫°i ƒë√¢y:\nKotlin Coroutines cheat sheet n√¢ng cao d√†nh cho Android Engineer Kotlin Flow cheat sheet ph·∫ßn 1: Channel Kotlin Flow cheat sheet ph·∫ßn 2: Flow Kotlin Flow cheat sheet ph·∫ßn 3: SharedFlow v√† StateFlow SharedFlow Nguy√™n t·∫Øc ch√≠nh L√† m·ªôt hot stream. C√≥ th·ªÉ c√≥ nhi·ªÅu receiver v√† t·∫•t c·∫£ ch√∫ng s·∫Ω nh·∫≠n ƒë∆∞·ª£c c√πng m·ªôt gi√° tr·ªã. H·ªØu √≠ch khi b·∫°n c·∫ßn truy·ªÅn c√°c gi√° tr·ªã t·ªõi nhi·ªÅu consumer ho·∫∑c mu·ªën chia s·∫ª tr·∫°ng th√°i/s·ª± ki·ªán gi·ªØa c√°c ph·∫ßn kh√°c nhau trong ·ª©ng d·ª•ng c·ªßa m√¨nh. Kh√¥ng bao gi·ªù ho√†n th√†nh cho ƒë·∫øn khi ch√∫ng ta close to√†n b·ªô scope. C√≥ phi√™n b·∫£n c√≥ th·ªÉ thay ƒë·ªïi MutableSharedFlow cho ph√©p ch√∫ng ta c·∫≠p nh·∫≠t state b·∫±ng c√°ch emit c√°c gi√° tr·ªã m·ªõi v·ªõi suspend function emit. Ch√∫ng ta c≈©ng c√≥ th·ªÉ s·ª≠ d·ª•ng phi√™n b·∫£n non suspend tryEmit. H·ªó tr·ª£ c·∫•u h√¨nh replay v√† tr√†n buffer. T·∫•t c·∫£ c√°c ph∆∞∆°ng th·ª©c c·ªßa shared flow ƒë·ªÅu thread-safe v√† c√≥ th·ªÉ ƒë∆∞·ª£c g·ªçi m·ªôt c√°ch an to√†n t·ª´ c√°c coroutine ƒë·ªìng th·ªùi m√† kh√¥ng c·∫ßn ƒë·ªìng b·ªô h√≥a b√™n ngo√†i. C√°c tham s·ªë c·∫•u h√¨nh Kotlin ƒëang cung c·∫•p cho ch√∫ng ta m·ªôt ph∆∞∆°ng th·ª©c h·ªØu √≠ch ƒë·ªÉ t·∫°o MutableSharedFlow v√† x√°c ƒë·ªãnh c√°ch ch√∫ng ta mu·ªën buffer ho·∫°t ƒë·ªông:\n1 2 3 4 5 6 7 8 9 public fun \u0026lt;T\u0026gt; MutableSharedFlow( // s·ªë l∆∞·ª£ng gi√° tr·ªã ƒë∆∞·ª£c replayed cho subscriber m·ªõi replay: Int = 0, // s·ªë l∆∞·ª£ng gi√° tr·ªã ƒë∆∞·ª£c l∆∞u v√†o buffer ngo√†i `replay` extraBufferCapacity: Int = 0, // h√†nh ƒë·ªông khi tr√†n buffer // C√°c gi√° tr·ªã: SUSPEND, DROP_OLDEST, DROP_LATEST onBufferOverflow: BufferOverflow = BufferOverflow.SUSPEND ): MutableSharedFlow\u0026lt;T\u0026gt; shareIn Bi·∫øn ƒë·ªïi Flow th√†nh SharedFlow. H·ªØu √≠ch khi ch√∫ng ta mu·ªën bi·∫øn m·ªôt flow th√†nh nhi·ªÅu flow Y√™u c·∫ßu coroutine scope l√†m tham s·ªë ƒë·∫ßu ti√™n (scope) ƒë·ªÉ b·∫Øt ƒë·∫ßu coroutine v√† collect ph·∫ßn t·ª≠ c·ªßa flow. Tham s·ªë th·ª© hai started x√°c ƒë·ªãnh th·ªùi ƒëi·ªÉm SharedFlow s·∫Ω b·∫Øt ƒë·∫ßu listen gi√° tr·ªã do flow emit. N√≥ l·∫•y m·ªôt object SharingStarted. Tham s·ªë th·ª© ba, replay, (m·∫∑c ƒë·ªãnh l√† 0) x√°c ƒë·ªãnh s·ªë l∆∞·ª£ng gi√° tr·ªã ƒë∆∞·ª£c replay cho subscriber m·ªõi. SharingStarted option SharingStarted.Eagerly: b·∫Øt ƒë·∫ßu listen c√°c ph·∫ßn t·ª≠ ngay l·∫≠p t·ª©c v√† kh√¥ng bao gi·ªù d·ª´ng l·∫°i cho ƒë·∫øn khi scope b·ªã cancel. SharingStarted.Lazily: b·∫Øt ƒë·∫ßu listen khi subscriber ƒë·∫ßu ti√™n xu·∫•t hi·ªán v√† kh√¥ng bao gi·ªù d·ª´ng cho ƒë·∫øn khi scope b·ªã cancel. SharingStarted.WhileSubscribed(): b·∫Øt ƒë·∫ßu listen khi subscriber ƒë·∫ßu ti√™n xu·∫•t hi·ªán v√† d·ª´ng ngay khi subscriber cu·ªëi c√πng bi·∫øn m·∫•t. Ch√∫ng ta config delay (t√≠nh b·∫±ng mili gi√¢y) gi·ªØa th·ªùi ƒëi·ªÉm subscriber cu·ªëi c√πng bi·∫øn m·∫•t v√† th·ªùi ƒëi·ªÉm d·ª´ng coroutine b·∫±ng tham s·ªë stopTimeoutMillis. L∆∞u √Ω v·ªÅ WhileSubscribed: n·∫øu b·∫°n m·ªü m·ªôt Intent m·ªõi t·ª´ m√†n h√¨nh c·ªßa m√¨nh, ch·∫≥ng h·∫°n nh∆∞ ·ª©ng d·ª•ng m√°y ·∫£nh, m√†n h√¨nh c·ªßa b·∫°n s·∫Ω b·ªã t·∫°m d·ª´ng v√† do ƒë√≥ SharedFlow c·ªßa b·∫°n s·∫Ω kh√¥ng c√≤n subscriber n·ªØa v√† s·∫Ω ng·ª´ng emit. Khi quay l·∫°i m√†n h√¨nh ban ƒë·∫ßu, b·∫°n s·∫Ω subscribe l·∫°i m√†n h√¨nh c·ªßa m√¨nh v√† c√≥ th·ªÉ ch·∫°y l·∫°i t√°c v·ª• b√™n trong flow c·ªßa m√¨nh. ƒêi·ªÅu n√†y c√≥ th·ªÉ g√¢y ra s·ª± c·ªë ho·∫∑c trigger l·∫°i m·ªôt t√°c v·ª• kh√¥ng c·∫ßn thi·∫øt.\nL∆∞u √Ω v·ªÅ SharingStarted.Eagerly v√† SharingStarted.Lazily: n·∫øu b·∫°n ƒëang s·ª≠ d·ª•ng ViewModelScope ho·∫∑c LifecycleScope th√¨ SharedFlow s·∫Ω ng·ª´ng g·ª≠i c√°c ph·∫ßn t·ª≠ khi m√†n h√¨nh b·ªã destroy.\nBi·∫øn flow th√†nh SharedFlow 1 2 3 4 5 6 7 8 9 10 11 12 13 14 // t·ª´ m·ªôt viewModel ho·∫∑c m·ªôt class c√≥ lifeCycleScope myFlow.shareIn( scope = viewModelScope started = SharingStarted.Lazily ) // t·ª´ m·ªôt class kh√¥ng c√≥ lifeCycleScope (repository ho·∫∑c use case) suspend fun myFunction() = coroutineScope { myFlow.shareIn( scope = this, started = SharingStarted.Lazily ) } Use case: Observe database thay ƒë·ªïi t·ª´ nhi·ªÅu v·ªã tr√≠ N·∫øu b·∫°n s·ª≠ d·ª•ng Room cho c∆° s·ªü d·ªØ li·ªáu c·ªßa m√¨nh th√¨ b·∫°n c√≥ th·ªÉ ƒë√£ bi·∫øt r·∫±ng n√≥ ƒë√£ h·ªó tr·ª£ Flow. V√¨ v·∫≠y, b·∫°n c√≥ th·ªÉ observe c√°c thay ƒë·ªïi trong database c·ªßa m√¨nh v√† nh·∫≠n d·ªØ li·ªáu m·ªõi ngay khi c√≥. Nh∆∞ng vi·ªác ƒë·ªçc d·ªØ li·ªáu t·ª´ disk c√≥ th·ªÉ kh√° n·∫∑ng. N·∫øu c·∫ßn nh·∫≠n d·ªØ li·ªáu ·ªü nhi·ªÅu m√†n h√¨nh, b·∫°n c√≥ th·ªÉ s·ª≠ d·ª•ng SharedFlow ƒë·ªÉ tr√°nh ph·∫£i fetch d·ªØ li·ªáu cho m·ªçi m√†n h√¨nh.\nTrong v√≠ d·ª• n√†y, m√¨nh s·∫Ω tr√¨nh b√†y c√°ch ƒë·ªÉ fetch m·ªôt UserSettings m·ªôt l·∫ßn nh∆∞ng v·∫´n nh·∫≠n ƒë∆∞·ª£c update tr√™n nhi·ªÅu m√†n h√¨nh:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 // DAO ƒë∆°n gi·∫£n ƒë·ªÉ fetch d·ªØ li·ªáu t·ª´ Room @Dao interface UserSettingsDao { // fetch t·∫•t c·∫£ user settings t·ª´ database v√† emit m·ªôt flow @Query(\u0026#34;SELECT * FROM user_settings\u0026#34;) fun getAll(): Flow\u0026lt;List\u0026lt;UserSettings\u0026gt;\u0026gt; } class UserSettingsRepository @Inject constructor( private val dao: UserSettingsDao ) { // Ch√∫ng ta ch·ªâ ƒë·ªçc t·ª´ DB m·ªôt l·∫ßn v√† t·∫•t c·∫£ receiver s·∫Ω nh·∫≠n ƒë∆∞·ª£c // data ƒë∆∞·ª£c t√≠nh to√°n ·ªü ƒë√¢y. suspend fun getAll(): SharedFlow\u0026lt;List\u0026lt;UserSettings\u0026gt;\u0026gt; = coroutineScope { dao.getAll.shareIn( // truy·ªÅn xu·ªëng scope scope = this, // ch·ªâ b·∫Øt ƒë·∫ßu emit khi ch√∫ng ta c√≥ receiver started = SharingStarted.Lazily, // replay ph·∫ßn t·ª≠ m·ªõi nh·∫•t khi m·ªôt receiver m·ªõi subscribe n√≥ replay = 1 ) } } StateFlow Nguy√™n t·∫Øc ch√≠nh Ho·∫°t ƒë·ªông t∆∞∆°ng t·ª± nh∆∞ a SharedFlow v·ªõi tham s·ªë replay ƒë∆∞·ª£c ƒë·∫∑t th√†nh 1. Lu√¥n ch·ªâ l∆∞u tr·ªØ m·ªôt gi√° tr·ªã. Gi√° tr·ªã ƒë∆∞·ª£c l∆∞u tr·ªØ c√≥ th·ªÉ ƒë∆∞·ª£c truy c·∫≠p b·∫±ng thu·ªôc t√≠nh value. Ch√∫ng ta c·∫ßn ƒë·∫∑t gi√° tr·ªã ban ƒë·∫ßu trong constructor. S·ª± thay th·∫ø hi·ªán ƒë·∫°i cho LiveData. S·∫Ω kh√¥ng emit ph·∫ßn t·ª≠ m·ªõi n·∫øu n√≥ b·∫±ng ph·∫ßn t·ª≠ tr∆∞·ªõc ƒë√≥. Thi·∫øt l·∫≠p v√† ƒë·ªçc m·ªôt gi√° tr·ªã 1 2 3 4 val state = MutableStateFlow(\u0026#34;A\u0026#34;) // gi√° tr·ªã ban ƒë·∫ßu l√† A state.value = \u0026#34;B\u0026#34; // ƒë·∫∑t gi√° tr·ªã th√†nh B state.value = \u0026#34;B\u0026#34; // gi√° tr·ªã n√†y s·∫Ω kh√¥ng emit ph·∫ßn t·ª≠ m·ªõi v√¨ gi√° tr·ªã ƒë√£ l√† B val myValue = state.value // ƒë·ªçc gi√° tr·ªã t·ª´ state, ·ªü ƒë√¢y l√† \u0026#34;B\u0026#34; stateIn Chuy·ªÉn ƒë·ªïi m·ªôt flow th√†nh m·ªôt StateFlow. C·∫ßn x√°c ƒë·ªãnh scope. C√≥ 2 lo·∫°i, m·ªôt lo·∫°i suspend v√† m·ªôt lo·∫°i kh√¥ng suspend stateIn suspend suspend cho ƒë·∫øn khi ph·∫ßn t·ª≠ ƒë·∫ßu ti√™n c·ªßa flow ƒë∆∞·ª£c emit v√† gi√° tr·ªã m·ªõi ƒë∆∞·ª£c t√≠nh to√°n 1 2 3 suspend fun myFunction() = coroutineScope { myFlow.stateIn(this) } stateIn not suspend Y√™u c·∫ßu m·ªôt gi√° tr·ªã ban ƒë·∫ßu trong tham s·ªë initialValue c·ªßa n√≥. Tham s·ªë th·ª© hai c·ªßa n√≥ l√† started v√† mong ƒë·ª£i m·ªôt ph·∫ßn t·ª≠ SharingStarted. 1 2 3 4 5 myFlow.stateIn( scope = viewModelScope, started = SharingStarted.Lazily, initValue = \u0026#34;A\u0026#34; ) Use case: Emit data t·ª´ viewModel sang view ƒêo·∫°n code v·ªÅ c√°ch chuy·ªÉn flow th√†nh StateFlow ƒë·ªÉ emit state t·ª´ view model sang view m√† ƒëang observe:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class MyViewModel @Inject constructor( private val fetchDataUseCase: FetchDataUseCase ) : ViewModel() { val myState: StateFlow\u0026lt;MyState\u0026gt; = fetchDataUseCase.dataState .map { when (it) { is FetchDataUseCase.FetchDataState.Loading -\u0026gt; MyState.Loading is FetchDataUseCase.FetchDataState.Success -\u0026gt; MyState.Success(it.data) is FetchDataUseCase.FetchDataState.Error -\u0026gt; MyState.Error(it.message) } } // chuy·ªÉn flow th√†nh state flow .stateIn( // ƒë·∫∑t scope th√†nh viewModel v√¨ v·∫≠y ch√∫ng ta s·∫Ω stop // listening khi viewModel b·ªã destroy scope = viewModelScope, started = SharingStarted.WhileSubscribed(5_000), initialValue = MyState.Loading ) sealed interface MyState { data object Loading : MyState data class Success(val data: List\u0026lt;String\u0026gt;) : MyState data class Error(val message: String) : MyState } } @Composable fun MyScreen(viewModel = MyViewModel()) { val state = viewModel.myState.collectAsStateWithLifecycle() when (state) { is MyState.Loading -\u0026gt; // show loading view is MyState.Success -\u0026gt; // show success view is MyState.Error -\u0026gt; // show error view } } C·∫£m ∆°n b·∫°n ƒë√£ ƒë·ªìng h√†nh c√πng m√¨nh ƒë·∫øn h·∫øt serie Kotlin cheat sheet n√†y. Hy v·ªçng nh·ªØng ki·∫øn th·ª©c h·ªØu √≠ch n√†y s·∫Ω gi√∫p b·∫°n t·ª± tin h∆°n khi l√†m vi·ªác v·ªõi Kotlin Coroutines v√† Flow.\nReference https://medium.com/@galou.minisini/advanced-kotlin-flow-cheat-sheet-for-android-engineer-cb8157d4f848 ","date":"2024-08-18T06:00:00+07:00","image":"https://namanh11611.github.io/p/kotlin-flow-cheat-sheet-3/cheat_sheet_hu_f4de22ccd44420a7.webp","permalink":"https://namanh11611.github.io/p/kotlin-flow-cheat-sheet-3/","title":"Kotlin Flow cheat sheet ph·∫ßn 3: SharedFlow v√† StateFlow"},{"content":"Photo by Ana Cruz on Unsplash\nTi·∫øp n·ªëi serie Kotlin cheat sheet, ch√∫ng ta c√πng ƒëi ƒë·∫øn v·ªõi cheat sheet ti·∫øp theo d√†nh cho Flow.\nKotlin Flow l√† m·ªôt API m·∫°nh m·∫Ω gi√∫p qu·∫£n l√Ω lu·ªìng d·ªØ li·ªáu b·∫•t ƒë·ªìng b·ªô m·ªôt c√°ch r√µ r√†ng v√† d·ªÖ d√†ng. Trong ph·∫ßn 2 n√†y, ch√∫ng ta s·∫Ω kh√°m ph√° Flow t·ª´ c∆° b·∫£n ƒë·∫øn n√¢ng cao, t√¨m hi·ªÉu c√°ch t·∫°o, chuy·ªÉn ƒë·ªïi v√† thu th·∫≠p c√°c lu·ªìng d·ªØ li·ªáu, c≈©ng nh∆∞ c√°c best practice ƒë·ªÉ √°p d·ª•ng trong d·ª± √°n Android c·ªßa b·∫°n.\nB·∫°n c√≥ th·ªÉ ƒë·ªçc to√†n b·ªô serie t·∫°i ƒë√¢y:\nKotlin Coroutines cheat sheet n√¢ng cao d√†nh cho Android Engineer Kotlin Flow cheat sheet ph·∫ßn 1: Channel Kotlin Flow cheat sheet ph·∫ßn 2: Flow Kotlin Flow cheat sheet ph·∫ßn 3: SharedFlow v√† StateFlow Flow Nguy√™n t·∫Øc ch√≠nh L√† m·ªôt cold stream. H·ªó tr·ª£ s·∫µn structured concurrency. T√°c v·ª• cu·ªëi c√πng c·ªßa flow ƒë∆∞·ª£c g·ªçi l√† t√°c v·ª• terminal (collect, first‚Ä¶ ). M·ªôt flow c√≥ th·ªÉ c√≥ c√°c t√°c v·ª• trung gian ƒë·ªÉ s·ª≠a ƒë·ªïi flow (map, onEach, flatMapLastest‚Ä¶ ). Terminal operation l√† suspend v√† y√™u c·∫ßu m·ªôt scope. C√°c Exception ch∆∞a ƒë∆∞·ª£c b·∫Øt s·∫Ω ngay l·∫≠p t·ª©c cancel m·ªôt flow v√† collect s·∫Ω throw l·∫°i Exception ƒë√≥. Theo m·∫∑c ƒë·ªãnh, context c·ªßa flow s·∫Ω l·∫•y t·ª´ context m√† collect ƒë∆∞·ª£c g·ªçi. K·∫øt h·ª£p c√°c flow v·ªõi nhau merge, combine v√† zip l√† c√°c h√†m trung gian cho ph√©p ch√∫ng ta k·∫øt h·ª£p 2 (ho·∫∑c nhi·ªÅu) flow th√†nh 1. V·∫≠y ƒëi·ªÉm kh√°c bi·ªát ch√≠nh gi·ªØa 3 h√†m ƒë√≥ l√† g√¨?\nmerge Kh√¥ng s·ª≠a ƒë·ªïi b·∫•t k·ª≥ ph·∫ßn t·ª≠ n√†o. C√°c ph·∫ßn t·ª≠ ƒë∆∞·ª£c emit ngay khi ch√∫ng ƒë∆∞·ª£c t·∫°o ra, ch√∫ng ta kh√¥ng ƒë·ª£i flow kh√°c ƒë·ªÉ t·∫°o ra gi√° tr·ªã. S·ª≠ d·ª•ng n√≥ khi b·∫°n c√≥ nhi·ªÅu ngu·ªìn event s·∫Ω t·∫°o ra c√πng m·ªôt action. flowA emit: 1\nflowB emit: 2\nflowA emit: 3\nmerge(flowA, flowB) t·∫°o ra 1, 2, 3\nzip K·∫øt h·ª£p c√°c ph·∫ßn t·ª≠ t·ª´ c√°c flow kh√°c nhau ƒë·ªÉ t·∫°o ra gi√° tr·ªã m·ªõi. Ch√∫ng ta c·∫ßn m·ªôt h√†m ƒë·ªÉ x√°c ƒë·ªãnh c√°ch c√°c ph·∫ßn t·ª≠ ƒë∆∞·ª£c k·∫øt h·ª£p v·ªõi nhau. Ch√∫ng ta c·∫ßn ƒë·ª£i m·ªói flow emit m·ªôt gi√° tr·ªã ƒë·ªÉ c√≥ th·ªÉ t·∫°o c·∫∑p. C√°c ph·∫ßn t·ª≠ ch·ªâ c√≥ th·ªÉ l√† m·ªôt ph·∫ßn c·ªßa m·ªôt c·∫∑p. C√°c ph·∫ßn t·ª≠ c√≤n l·∫°i kh√¥ng c√≥ c·∫∑p s·∫Ω b·ªã m·∫•t. flowA emit: 1\nflowB emit: 2\nflowA emit: 4\nflowA.zip(flowB) {fA, fB -\u0026gt; fA + fB } t·∫°o ra 3 (1+2 = 3, c√≤n 4 t·ª´ flowA s·∫Ω b·ªã lo·∫°i b·ªè)\ncombine K·∫øt h·ª£p c√°c ph·∫ßn t·ª≠ t·ª´ c√°c flow kh√°c nhau ƒë·ªÉ t·∫°o ra gi√° tr·ªã m·ªõi. Ch√∫ng ta c·∫ßn m·ªôt h√†m x√°c ƒë·ªãnh c√°ch c√°c ph·∫ßn t·ª≠ ƒë∆∞·ª£c k·∫øt h·ª£p v·ªõi nhau. Ch√∫ng ta c·∫ßn ƒë·ª£i flow ch·∫≠m h∆°n emit gi√° tr·ªã l·∫ßn ƒë·∫ßu ti√™n tr∆∞·ªõc khi t·∫°o ph·∫ßn t·ª≠ m·ªõi. Khi m·ªôt flow t·∫°o ra m·ªôt ph·∫ßn t·ª≠ m·ªõi, n√≥ s·∫Ω thay th·∫ø ph·∫ßn t·ª≠ tr∆∞·ªõc ƒë√≥ v√† m·ªôt gi√° tr·ªã m·ªõi s·∫Ω ƒë∆∞·ª£c emit ngay l·∫≠p t·ª©c (ch√∫ng ta kh√¥ng ƒë·ª£i m·ªói flow emit m·ªôt ph·∫ßn t·ª≠ m·ªõi). flowA emit: 1\nflowB emit: 2\nflowA emit: 3\nflowA.combines(flowB) { fA, fB -\u0026gt; fA + fB } t·∫°o ra 3 (1+2 = 3) r·ªìi 5 (3+2 = 5, trong ƒë√≥ ph·∫ßn t·ª≠ 3 ƒë√£ thay th·∫ø cho 1 tr∆∞·ªõc ƒë√≥)\nS·ª± kh√°c bi·ªát gi·ªØa fold v√† scan C·∫£ fold v√† scan k·∫øt h·ª£p t·∫•t c·∫£ c√°c gi√° tr·ªã do m·ªôt flow emit th√†nh m·ªôt ph·∫ßn t·ª≠ b·∫±ng c√°ch √°p d·ª•ng thao t√°c k·∫øt h·ª£p c√°c gi√° tr·ªã l·∫°i v·ªõi nhau.\nfold l√† m·ªôt t√°c v·ª• terminal. N√≥ suspend cho ƒë·∫øn khi flow ho√†n th√†nh v√† t·∫°o ra gi√° tr·ªã cu·ªëi c√πng scan l√† m·ªôt t√°c v·ª• trung gian v√† t·∫°o ra t·∫•t c·∫£ c√°c gi√° tr·ªã trung gian 1 2 3 4 5 val myflow = flowOf(1, 2, 3, 4) myFlow.fold(0) { acc, newElement -\u0026gt; acc + newElement } // t·∫°o ra 10 myFlow.scan(0) { acc, newElement -\u0026gt; acc + newElement } // t·∫°o ra 1, 3 (1+2), 6 (3+3), 10 (6+4) flatMapConcat, flatMapMerge v√† flatMapLatest Ch√∫ng ƒë·ªÅu l√† nh·ªØng t√°c v·ª• trung gian Ch√∫ng bi·∫øn ƒë·ªïi c√°c ph·∫ßn t·ª≠ ƒë∆∞·ª£c emit b·ªüi flow ban ƒë·∫ßu b·∫±ng c√°ch √°p d·ª•ng m·ªôt flow kh√°c l√™n ph·∫ßn t·ª≠ ƒë√≥ v√† tr·∫£ v·ªÅ m·ªôt flow kh√°c 1 myFlowA.flatMapConcat { fA -\u0026gt; myFlowB(fA) } // gi√° tr·ªã tr·∫£ v·ªÅ do flow B t·∫°o ra flatMapConcat Chuy·ªÉn ƒë·ªïi t·ª´ng gi√° tr·ªã ƒë∆∞·ª£c emit th√†nh m·ªôt flow v√† n·ªëi c√°c flow k·∫øt qu·∫£ m·ªôt c√°ch tu·∫ßn t·ª±. Emit ho√†n to√†n c√°c gi√° tr·ªã t·ª´ inner flow ƒë·∫ßu ti√™n tr∆∞·ªõc khi b·∫Øt ƒë·∫ßu flow ti·∫øp theo. Use Case: khi b·∫°n c·∫ßn x·ª≠ l√Ω c√°c flow b√™n trong theo th·ª© t·ª±, kh√¥ng b·ªã ch·ªìng ch√©o. flatMapMerge Chuy·ªÉn ƒë·ªïi t·ª´ng gi√° tr·ªã ƒë∆∞·ª£c emit th√†nh m·ªôt flow v√† h·ª£p nh·∫•t c√°c flow k·∫øt qu·∫£ m·ªôt c√°ch ƒë·ªìng th·ªùi. Emit c√°c gi√° tr·ªã t·ª´ t·∫•t c·∫£ c√°c inner flow khi ch√∫ng c√≥ s·∫µn, c√≥ kh·∫£ nƒÉng kh√¥ng theo th·ª© t·ª±. Use Case: khi b·∫°n mu·ªën x·ª≠ l√Ω ƒë·ªìng th·ªùi c√°c flow b√™n trong v√† kh√¥ng quan t√¢m ƒë·∫øn th·ª© t·ª± c·ªßa c√°c gi√° tr·ªã ƒë∆∞·ª£c emit. flatMapLatest Chuy·ªÉn ƒë·ªïi t·ª´ng gi√° tr·ªã ƒë∆∞·ª£c emit th√†nh m·ªôt flow, h·ªßy c√°c flow tr∆∞·ªõc ƒë√≥ khi m·ªôt gi√° tr·ªã m·ªõi ƒë√£ ƒë∆∞·ª£c emit, v√† emit c√°c gi√° tr·ªã t·ª´ flow m·ªõi nh·∫•t. Ch·ªâ flow m·ªõi nh·∫•t ƒë∆∞·ª£c ho·∫°t ƒë·ªông v√† c√°c gi√° tr·ªã c·ªßa n√≥ ƒë∆∞·ª£c emit. C√°c flow tr∆∞·ªõc ƒë√≥ b·ªã h·ªßy b·ªè. Use Case: khi b·∫°n ch·ªâ quan t√¢m ƒë·∫øn gi√° tr·ªã m·ªõi nh·∫•t v√† mu·ªën h·ªßy c√°c thao t√°c tr∆∞·ªõc ƒë√≥. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 data class User(val id: Int, val name: String) data class UserDetails(val userId: Int, val address: String) fun fetchUserData(): Flow\u0026lt;User\u0026gt; = flow { emit(User(1, \u0026#34;Alice\u0026#34;)) delay(500) emit(User(2, \u0026#34;Bob\u0026#34;)) delay(500) emit(User(3, \u0026#34;Charlie\u0026#34;)) } fun fetchUserDetails(userId: Int): Flow\u0026lt;UserDetails\u0026gt; = flow { delay(1000) // Gi·∫£ l·∫≠p network delay emit(UserDetails(userId, \u0026#34;$userId\u0026#39;s address\u0026#34;)) } // flatMapConcat fetchUserData() .flatMapConcat { user -\u0026gt; fetchUserDetails(user.id) } .collect { userDetails -\u0026gt; println(\u0026#34;flatMapConcat: ${userDetails}\u0026#34;) } // M·ªói th√¥ng tin user ƒë∆∞·ª£c tr·∫£ v·ªÅ tu·∫ßn t·ª±. // flatMapConcat: UserDetails(userId=1, address=1\u0026#39;s address) // flatMapConcat: UserDetails(userId=2, address=2\u0026#39;s address) // flatMapConcat: UserDetails(userId=3, address=3\u0026#39;s address) // flatMapMerge fetchUserData() .flatMapMerge { user -\u0026gt; fetchUserDetails(user.id) } .collect { userDetails -\u0026gt; println(\u0026#34;flatMapMerge: ${userDetails}\u0026#34;) } // Th√¥ng tin user c√≥ th·ªÉ b·ªã xen k·∫Ω do tr·∫£ v·ªÅ ƒë·ªìng th·ªùi. // flatMapMerge: UserDetails(userId=1, address=1\u0026#39;s address) // flatMapMerge: UserDetails(userId=2, address=2\u0026#39;s address) // flatMapMerge: UserDetails(userId=3, address=3\u0026#39;s address) // flatMapLatest fetchUserData() .flatMapLatest { user -\u0026gt; fetchUserDetails(user.id) } .collect { userDetails -\u0026gt; println(\u0026#34;flatMapLatest: ${userDetails}\u0026#34;) } // Ch·ªâ th√¥ng tin c·ªßa user cu·ªëi c√πng ƒë∆∞·ª£c tr·∫£ v·ªÅ // do user m·ªõi s·∫Ω cancel fetch tr∆∞·ªõc ƒë√≥. // flatMapLatest: UserDetails(userId=3, address=3\u0026#39;s address) Chuy·ªÉn ƒë·ªïi function th√†nh Flow 1 2 3 4 5 6 val function = suspend { // ƒë√¢y l√† bi·ªÉu th·ª©c lambda suspend // ƒë·ªãnh nghƒ©a h√†m ·ªü ƒë√¢y } function.asFlow() Ho·∫∑c\n1 2 3 4 5 suspend fun myFunction(): Flow\u0026lt;T\u0026gt; { // ƒë·ªãnh nghƒ©a h√†m ·ªü ƒë√¢y } ::myFunction.asFlow() T·∫°o flow t·∫°o ra c√°c ph·∫ßn t·ª≠ tr∆∞·ªõc khi ch√∫ng ta subscribe H√†m channelFlow t·∫°o ra s·ª± k·∫øt h·ª£p gi·ªØa flow v√† channel. N√≥ t·∫°o ra m·ªôt hot stream data nh∆∞ng c≈©ng implement Flow interface.\n1 2 3 4 5 6 7 8 val myChannelFlow = channelFlow { val myData = // fetch d·ªØ li·ªáu t·∫°i ƒë√¢y send(myData) } suspend fun fetchData() { myData.first() } S·ª≠a ƒë·ªïi context c·ªßa Flow 1 2 3 4 5 myFlow.flowOn(Dispatchers.IO) // Ho·∫∑c myFlow.flowOn(CoroutineName( \u0026#34;NewName\u0026#34; )) Tr√°nh l·ªìng nhau khi kh·ªüi ch·∫°y flow 1 2 3 4 5 6 7 // thay v√¨ viewModelScope.launch { myFlow.collect() } // l√†m nh∆∞ n√†y myFlow.launchIn(viewModelScope) C·∫£m ∆°n c√°c b·∫°n ƒë√£ ƒë·ªçc ƒë·∫øn ƒë√¢y, c√πng ch·ªù ƒë√≥n nh·ªØng ph·∫ßn ti·∫øp theo nh√©.\nReference https://medium.com/@galou.minisini/advanced-kotlin-flow-cheat-sheet-for-android-engineer-cb8157d4f848 ","date":"2024-08-18T05:00:00+07:00","image":"https://namanh11611.github.io/p/kotlin-flow-cheat-sheet-2/cheat_sheet_hu_f4de22ccd44420a7.webp","permalink":"https://namanh11611.github.io/p/kotlin-flow-cheat-sheet-2/","title":"Kotlin Flow cheat sheet ph·∫ßn 2: Flow"},{"content":"Photo by Ana Cruz on Unsplash\nSau khi l√†m vi·ªác v·ªõi Kotlin Flows m·ªôt th·ªùi gian, c√≥ th·ªÉ b·∫°n ƒë√£ quen v·ªõi c√°c kh√°i ni·ªám c∆° b·∫£n. Nh∆∞ng n·∫øu ch∆∞a bao gi·ªù s·ª≠ d·ª•ng Channel, b·∫°n s·∫Ω kh√¥ng bi·∫øt s·ª± kh√°c nhau gi·ªØa merge, combine v√† zip, ho·∫∑c c√≥ th·ªÉ b·∫°n ch∆∞a hi·ªÉu r√µ SharedFlow v√† StateFlow c≈©ng nh∆∞ c√°ch s·ª≠ d·ª•ng ch√∫ng.\nCheat sheet n√†y h·ªá th·ªëng l·∫°i nh·ªØng ki·∫øn th·ª©c quan tr·ªçng m√† m√¨nh ƒë√£ g√≥p nh·∫∑t ƒë∆∞·ª£c trong qu√° tr√¨nh l√†m vi·ªác v·ªõi Kotlin Flow. N√≥ ƒë∆∞·ª£c thi·∫øt k·∫ø ƒë·ªÉ tr·ªü th√†nh m·ªôt t√†i li·ªáu tham kh·∫£o h·ªØu √≠ch, gi√∫p b·∫°n gi·∫£i quy·∫øt c√°c t√¨nh hu·ªëng ph·ª©c t·∫°p.\nTrong ph·∫ßn 1, ch√∫ng ta s·∫Ω t√¨m hi·ªÉu chi ti·∫øt v·ªÅ Channel, c√°ch th·ª©c ho·∫°t ƒë·ªông, v√† c√°ch ·ª©ng d·ª•ng trong c√°c tr∆∞·ªùng h·ª£p th·ª±c t·∫ø ƒë·ªÉ giao ti·∫øp gi·ªØa c√°c coroutine m·ªôt c√°ch an to√†n v√† hi·ªáu qu·∫£.\nB·∫°n c√≥ th·ªÉ ƒë·ªçc to√†n b·ªô serie t·∫°i ƒë√¢y:\nKotlin Coroutines cheat sheet n√¢ng cao d√†nh cho Android Engineer Kotlin Flow cheat sheet ph·∫ßn 1: Channel Kotlin Flow cheat sheet ph·∫ßn 2: Flow Kotlin Flow cheat sheet ph·∫ßn 3: SharedFlow v√† StateFlow Hot streams v√† Cold streams Hot streams V√≠ d·ª•: channel, Collections (List, Set‚Ä¶ ). B·∫Øt ƒë·∫ßu ngay l·∫≠p t·ª©c: b·∫Øt ƒë·∫ßu emit c√°c gi√° tr·ªã b·∫•t k·ªÉ c√≥ subscriber hay kh√¥ng. L∆∞u c√°c ph·∫ßn t·ª≠: ch√∫ng kh√¥ng c·∫ßn ph·∫£i t√≠nh to√°n l·∫°i v√† t·∫•t c·∫£ subscriber ƒë·ªÅu nh·∫≠n ƒë∆∞·ª£c c√πng m·ªôt chu·ªói gi√° tr·ªã. Cold streams V√≠ d·ª•: Sequence, Flow B·∫Øt ƒë·∫ßu theo y√™u c·∫ßu: cold streams ch·ªâ b·∫Øt ƒë·∫ßu emit c√°c gi√° tr·ªã khi subscriber ch·ªß ƒë·ªông ƒëƒÉng k√Ω stream ƒë√≥. Ngu·ªìn d·ªØ li·ªáu l√† lazy. Ph√°t ƒë·ªôc l·∫≠p: m·ªói subscriber nh·∫≠n ƒë∆∞·ª£c chu·ªói gi√° tr·ªã ƒë·ªôc l·∫≠p c·ªßa ri√™ng m√¨nh. Kh√¥ng c√≥ ph·∫ßn t·ª≠ n√†o ƒë∆∞·ª£c l∆∞u tr·ªØ. Channel Nguy√™n t·∫Øc ch√≠nh L√† m·ªôt hot stream. ƒê·∫£m b·∫£o kh√¥ng c√≥ xung ƒë·ªôt (kh√¥ng c√≥ v·∫•n ƒë·ªÅ v·ªõi tr·∫°ng th√°i chia s·∫ª) v√† c√¥ng b·∫±ng n√™n r·∫•t h·ªØu √≠ch khi c√°c coroutine kh√°c nhau c·∫ßn li√™n l·∫°c v·ªõi nhau. H·ªó tr·ª£ b·∫•t k·ª≥ s·ªë l∆∞·ª£ng sender v√† receiver. M·ªói gi√° tr·ªã g·ª≠i t·ªõi channel ch·ªâ ƒë∆∞·ª£c nh·∫≠n m·ªôt l·∫ßn. N·∫øu c√≥ nhi·ªÅu receiver subscribe c√πng l√∫c, c√°c ph·∫ßn t·ª≠ s·∫Ω ƒë∆∞·ª£c ph√¢n b·ªï c√¥ng b·∫±ng gi·ªØa c√°c receiver. (H√†ng ƒë·ª£i FIFO c·ªßa receiver). Channel c√≥ 3 receiver, subscribe theo th·ª© t·ª±: Receiver1, Receiver2, Receiver3.\nT·∫•t c·∫£ receiver ƒë√£ subscribe channel.\nChannel emit ra 4 gi√° tr·ªã: \u0026ldquo;A\u0026rdquo;, \u0026ldquo;B\u0026rdquo;, \u0026ldquo;C\u0026rdquo; r·ªìi \u0026ldquo;D\u0026rdquo;.\nReceiver1 nh·∫≠n ƒë∆∞·ª£c \u0026ldquo;A\u0026rdquo; v√† \u0026ldquo;D\u0026rdquo;\nReceiver2 nh·∫≠n ƒë∆∞·ª£c \u0026ldquo;B\u0026rdquo;\nReceiver3 nh·∫≠n ƒë∆∞·ª£c \u0026ldquo;C\u0026rdquo;\nCh√∫ng c√≥ 2 suspend function l√† send v√† receive. receive b·ªã suspend n·∫øu kh√¥ng c√≥ ph·∫ßn t·ª≠ n√†o trong channel v√† s·∫Ω ƒë·ª£i m·ªôt ph·∫ßn t·ª≠ s·∫µn s√†ng ƒë·ªÉ ti·∫øp t·ª•c. send b·ªã suspend n·∫øu channel ƒë·∫°t ƒë·∫øn capacity. Ch√∫ng ta c≈©ng c√≥ th·ªÉ s·ª≠ d·ª•ng phi√™n b·∫£n kh√¥ng b·ªã suspend l√† trySend v√† tryReceive, ch√∫ng tr·∫£ v·ªÅ m·ªôt ChannelResult (cho ch√∫ng ta bi·∫øt thao t√°c c√≥ th√†nh c√¥ng hay kh√¥ng). Ch√∫ng c·∫ßn ƒë∆∞·ª£c close th·ªß c√¥ng sau khi ch√∫ng ta g·ª≠i xong d·ªØ li·ªáu ho·∫∑c khi x·∫£y ra Exception: myChannel.close(). N·∫øu kh√¥ng, receive s·∫Ω ƒë·ª£i c√°c ph·∫ßn t·ª≠ m√£i m√£i. C√°c lo·∫°i channel capacity 1 2 3 4 5 6 7 val myChannel = Channel\u0026lt;Int\u0026gt;(capacity = 3) // ho·∫∑c val myChannel = produce(capacity = 3) { // emit c√°c gi√° tr·ªã ·ªü ƒë√¢y } Channel.UNLIMITED: buffer kh√¥ng gi·ªõi h·∫°n v√† send kh√¥ng bao gi·ªù b·ªã suspend. Channel.BUFFERED: buffer capacity l√† 64. Gi√° tr·ªã m·∫∑c ƒë·ªãnh n√†y c√≥ th·ªÉ ƒë∆∞·ª£c override b·∫±ng thu·ªôc t√≠nh h·ªá th·ªëng kotlinx.coroutines.channels.defaultBuffer trong JVM. Channel.RENDEZVOUS: (behavior m·∫∑c ƒë·ªãnh) buffer capacity l√† 0. Receiver s·∫Ω ch·ªâ nh·∫≠n ƒë∆∞·ª£c d·ªØ li·ªáu n·∫øu n√≥ ƒë√£ subscribe v·ªõi sender khi d·ªØ li·ªáu ƒë∆∞·ª£c emit. Channel.CONFLATED: buffer capacity l√† 1. M·ªói ph·∫ßn t·ª≠ m·ªõi s·∫Ω thay th·∫ø ph·∫ßn t·ª≠ tr∆∞·ªõc ƒë√≥. Gi√° tr·ªã intb·∫•t k·ª≥: buffer s·∫Ω c√≥ capacity b·∫±ng gi√° tr·ªã ƒë∆∞·ª£c set. X·ª≠ l√Ω l·ªói tr√†n buffer C√°c channel c√≥ m·ªôt tham s·ªë onBufferOverflow ki·ªÉm so√°t nh·ªØng g√¨ x·∫£y ra khi buffer ƒë·∫ßy. C√≥ 3 l·ª±a ch·ªçn:\nBufferOverflow.SUSPEND: (behavior m·∫∑c ƒë·ªãnh) t·∫°m d·ª´ng ph∆∞∆°ng th·ª©c send khi buffer ƒë·∫ßy. BufferOverflow.DROP_OLDEST: lo·∫°i b·ªè ph·∫ßn t·ª≠ c≈© nh·∫•t khi buffer ƒë·∫ßy. BufferOverflow.DROP_LATEST: lo·∫°i b·ªè ph·∫ßn t·ª≠ m·ªõi nh·∫•t khi buffer ƒë·∫ßy. T·∫°o Channel t·ª± ƒë·ªông close Coroutine builder produce s·∫Ω close channel b·∫•t c·ª© khi n√†o builder coroutine k·∫øt th√∫c (finish, stop ho·∫∑c cancel).\n1 2 3 4 5 suspend fun myFunction() = coroutineScope { val channel = produce { // emit c√°c gi√° tr·ªã ·ªü ƒë√¢y v√† kh√¥ng c·∫ßn g·ªçi close() khi k·∫øt th√∫c } } T·ª± ƒë·ªông d·ªçn d·∫πp n·∫øu m·ªôt ph·∫ßn t·ª≠ kh√¥ng th·ªÉ x·ª≠ l√Ω N·∫øu channel ƒë√£ b·ªã close, cancel ho·∫∑c khi send, receive, hastNext c√≥ l·ªói\n1 2 3 4 val myChannel = Channel( capacity, onUnderliveredElement = { /* c√°c t√°c v·ª• d·ªçn d·∫πp ·ªü ƒë√¢y */ } ) Use case: trigger m·ªôt refresh Trong Android, tr∆∞·ªùng h·ª£p s·ª≠ d·ª•ng ph·ªï bi·∫øn cho c√°c channel l√† trigger khi m·ªôt screen ƒë∆∞·ª£c refresh (pull to refresh ho·∫∑c button retry). ƒêo·∫°n code b√™n d∆∞·ªõi tr√¨nh b√†y c√°ch fetch data t·ª´ API khi ch√∫ng ta subscribe flow l·∫ßn ƒë·∫ßu ti√™n ho·∫∑c khi trigger m·ªôt refresh.\nR·∫•t nhi·ªÅu ng∆∞·ªùi s·ª≠ d·ª•ng SharedFlow ƒë·ªÉ trigger refresh v√† n√≥ ho·∫°t ƒë·ªông ·ªïn, nh∆∞ng ƒë√≥ kh√¥ng ph·∫£i l√† gi·∫£i ph√°p t·ªët nh·∫•t v√¨ SharedFlow ƒë∆∞·ª£c thi·∫øt k·∫ø ƒë·ªÉ c√≥ nhi·ªÅu receiver.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 // ƒê√¢y l√† phi√™n b·∫£n ƒë∆°n gi·∫£n h√≥a ƒë·ªÉ minh h·ªça c√°ch ch√∫ng ta c√≥ th·ªÉ s·ª≠ d·ª•ng channel. // Trong tr∆∞·ªùng h·ª£p s·ª≠ d·ª•ng th·ª±c t·∫ø, ch√∫ng ta s·∫Ω y√™u c·∫ßu m·ªôt s·ªë logic b·ªï sung ƒë·ªÉ tr√°nh // l√†m m·ªõi n·∫øu d·ªØ li·ªáu ƒë√£ ƒë∆∞·ª£c t·∫£i ch·∫≥ng h·∫°n. interface ApiService { suspend fun fetchData(): List\u0026lt;String\u0026gt; } class FetchDataUseCase @Inject constructor ( private val apiService: ApiService ) { // t·∫°o m·ªôt channel c√≥ buffer l√† 1 v√† s·∫Ω lo·∫°i b·ªè d·ªØ li·ªáu m·ªõi nh·∫•t // v√¨ v·∫≠y n·∫øu ch√∫ng ta trigger refresh nhi·ªÅu l·∫ßn li√™n ti·∫øp // ch√∫ng ta s·∫Ω ch·ªâ gi·ªØ ph·∫ßn t·ª≠ ƒë·∫ßu ti√™n. private val refreshChannel = Channel\u0026lt;Unit\u0026gt;( capacity = 1, onBufferOverflow = BufferOverflow.DROP_LATEST ) // viewModel c√≥ th·ªÉ receive flow n√†y ƒë·ªÉ build UI state val dataState: Flow\u0026lt;FetchDataState\u0026gt; = refreshChannel // convert channel th√†nh flow .consumeAsFlow() // emit m·ªôt ph·∫ßn t·ª≠ khi b·∫Øt ƒë·∫ßu fetch data ngay khi ch√∫ng ta subscribe flow .onStart { emit(Unit) } .map { fetchData() } fun refresh() { // Ch√∫ng ta s·ª≠ d·ª•ng trySend ·ªü ƒë√¢y ƒë·ªÉ kh√¥ng ph·∫£i t·∫°o suspend function // v√† v√¨ v·∫≠y ch√∫ng ta kh√¥ng c·∫ßn scope ƒë·ªÉ g·ªçi n√≥. // Ph∆∞∆°ng th·ª©c n√†y c√≥ th·ªÉ ƒë∆∞·ª£c g·ªçi t·ª´ viewModel ƒë·ªÉ trigger refresh refreshChannel.trySend(Unit) } private suspend fun fetchData(): FetchDataState = try { val data = apiService.fetchData() FetchDataState.Success(data) } catch (e: Exception) { FetchDataState.Error(e.message ?: \u0026#34;An error occurred\u0026#34;) } sealed interface FetchDataState { data object Loading : FetchDataState data class Success(val data: List\u0026lt;String\u0026gt;) : FetchDataState data class Error(val message: String) : FetchDataState } } C·∫£m ∆°n c√°c b·∫°n ƒë√£ ƒë·ªçc ƒë·∫øn ƒë√¢y, c√πng ch·ªù ƒë√≥n nh·ªØng ph·∫ßn ti·∫øp theo nh√©.\nReference https://medium.com/@galou.minisini/advanced-kotlin-flow-cheat-sheet-for-android-engineer-cb8157d4f848 ","date":"2024-08-18T04:00:00+07:00","image":"https://namanh11611.github.io/p/kotlin-flow-cheat-sheet-1/cheat_sheet_hu_f4de22ccd44420a7.webp","permalink":"https://namanh11611.github.io/p/kotlin-flow-cheat-sheet-1/","title":"Kotlin Flow cheat sheet ph·∫ßn 1: Channel"},{"content":"Photo by Ana Cruz on Unsplash\nSau khi l√†m vi·ªác v·ªõi Kotlin Coroutines m·ªôt th·ªùi gian, c√≥ th·ªÉ anh em ƒë√£ quen v·ªõi c√°c kh√°i ni·ªám c∆° b·∫£n nh∆∞ suspend function v√† c√°c h√†m launch, async\u0026hellip;, c√≥ th·ªÉ gi·∫£i quy·∫øt c√°c use case ƒë∆°n gi·∫£n m·ªôt c√°ch ngon ∆°. Nh∆∞ng khi d·ª± √°n tr·ªü n√™n ph·ª©c t·∫°p h∆°n, anh em c√≥ th·ªÉ th∆∞·ªùng xuy√™n c·∫ßn c√°c gi·∫£i ph√°p n√¢ng cao h∆°n v√† ph·∫£i nh·ªù s·ª± tr·ª£ gi√∫p ƒë·∫øn t·ª´ Google ho·∫∑c AI.\nCheat sheet n√†y h·ªá th·ªëng l·∫°i nh·ªØng ki·∫øn th·ª©c quan tr·ªçng m√† m√¨nh ƒë√£ g√≥p nh·∫∑t ƒë∆∞·ª£c trong qu√° tr√¨nh l√†m vi·ªác v·ªõi Kotlin Coroutines. N√≥ ƒë∆∞·ª£c thi·∫øt k·∫ø ƒë·ªÉ tr·ªü th√†nh m·ªôt t√†i li·ªáu tham kh·∫£o h·ªØu √≠ch, gi√∫p anh em gi·∫£i quy·∫øt c√°c tr∆∞·ªùng h·ª£p ph·ª©c t·∫°p c·ªßa coroutine.\nB·∫°n c√≥ th·ªÉ ƒë·ªçc to√†n b·ªô serie t·∫°i ƒë√¢y:\nKotlin Coroutines cheat sheet n√¢ng cao d√†nh cho Android Engineer Kotlin Flow cheat sheet ph·∫ßn 1: Channel Kotlin Flow cheat sheet ph·∫ßn 2: Flow Kotlin Flow cheat sheet ph·∫ßn 3: SharedFlow v√† StateFlow C√°c kh√°i ni·ªám trong Coroutines Coroutine Context: t·∫≠p h·ª£p c√°c th√†nh ph·∫ßn kh√°c nhau. Trong ƒë√≥, c√°c th√†nh ph·∫ßn ch√≠nh l√† Job v√† Dispatcher c·ªßa coroutine.\nJob: th·ª© c√≥ th·ªÉ h·ªßy ƒë∆∞·ª£c v·ªõi v√≤ng ƒë·ªùi ƒë·∫°t ƒë·∫øn ƒë·ªânh khi n√≥ ho√†n th√†nh. M·ªói coroutine ƒë·ªÅu t·∫°o m·ªôt Job c·ªßa ri√™ng n√≥ (ƒë√≥ l√† coroutine context duy nh·∫•t kh√¥ng ƒë∆∞·ª£c k·∫ø th·ª´a t·ª´ coroutine cha).\nDispatcher: cho ph√©p ch√∫ng ta quy·∫øt ƒë·ªãnh thread n√†o (ho·∫∑c pool c·ªßa thread) m√† coroutine s·∫Ω ch·∫°y tr√™n ƒë√≥ (khi start v√† resume). B·∫°n c√≥ th·ªÉ ƒë·ªçc b√†i vi·∫øt chi ti·∫øt c·ªßa m√¨nh v·ªÅ Dispatchers trong Kotlin Coroutines\nCoroutine scope: x√°c ƒë·ªãnh th·ªùi gian t·ªìn t·∫°i v√† context c·ªßa coroutine. N√≥ ch·ªãu tr√°ch nhi·ªám qu·∫£n l√Ω v√≤ng ƒë·ªùi c·ªßa coroutine, bao g·ªìm c·∫£ vi·ªác h·ªßy v√† x·ª≠ l√Ω l·ªói.\nCoroutine builder: c√°c extension function c·ªßa CoroutineScope, cho ph√©p ch√∫ng ta start m·ªôt coroutine b·∫•t ƒë·ªìng b·ªô (v√≠ d·ª• nh∆∞ launch, async‚Ä¶ ).\nC√°c quy t·∫Øc ch√≠nh c·ªßa Coroutines B·∫°n c·∫ßn m·ªôt CoroutineScope ƒë·ªÉ start m·ªôt coroutine (v·ªõi function launch ho·∫∑c async). viewModelScope ƒë∆∞·ª£c s·ª≠ d·ª•ng ph·ªï bi·∫øn nh·∫•t trong Android, nh∆∞ng b·∫°n c≈©ng c√≥ th·ªÉ t·ª± x√¢y d·ª±ng scope c·ªßa ri√™ng b·∫°n. Coroutine con (m·ªôt coroutine b·∫Øt ƒë·∫ßu t·ª´ m·ªôt coroutine kh√°c) k·∫ø th·ª´a coroutine context t·ª´ coroutine cha (ngo·∫°i tr·ª´ Job). Job c·ªßa coroutine cha ƒë∆∞·ª£c s·ª≠ d·ª•ng l√†m cha c·ªßa Job c·ªßa coroutine con. Coroutine cha suspend cho ƒë·∫øn khi t·∫•t c·∫£ c√°c coroutine con c·ªßa n√≥ k·∫øt th√∫c. Khi m·ªôt coroutine cha b·ªã h·ªßy th√¨ t·∫•t c·∫£ c√°c coroutine con c·ªßa n√≥ c≈©ng b·ªã h·ªßy. Khi m·ªôt coroutine con b·ªã l·ªói v√¨ m·ªôt Exception ch∆∞a ƒë∆∞·ª£c x·ª≠ l√Ω, n√≥ s·∫Ω cancel coroutine cha c·ªßa n√≥ (tr·ª´ khi b·∫°n s·ª≠ d·ª•ng m·ªôt SupervisorJob). B·∫°n kh√¥ng n√™n s·ª≠ d·ª•ng GlobalScope, n√≥ c√≥ th·ªÉ g√¢y memory leak v√† gi·ªØ coroutine t·ªìn t·∫°i ngay c·∫£ sau khi Activity ho·∫∑c Fragment kh·ªüi ch·∫°y n√≥ ƒë√£ b·ªã b·ªè qua. B·∫°n kh√¥ng n√™n truy·ªÅn coroutine scope nh∆∞ m·ªôt tham s·ªë, thay v√†o ƒë√≥ h√£y s·ª≠ d·ª•ng function coroutineScope. C√°c function c·ªßa Coroutine scope coroutineScope: suspend function, d√πng ƒë·ªÉ b·∫Øt ƒë·∫ßu m·ªôt scope v√† tr·∫£ v·ªÅ gi√° tr·ªã do tham s·ªë c·ªßa function t·∫°o ra. supervisorScope: t∆∞∆°ng t·ª± coroutineScope nh∆∞ng n√≥ override Job c·ªßa context, v√¨ v·∫≠y function kh√¥ng b·ªã cancel khi coroutine con throw m·ªôt Exception. withContext: t∆∞∆°ng t·ª± coroutineScope nh∆∞ng cho ph√©p th·ª±c hi·ªán m·ªôt s·ªë thay ƒë·ªïi trong scope (th∆∞·ªùng ƒë∆∞·ª£c s·ª≠ d·ª•ng ƒë·ªÉ set Dispatcher). withTimeout: t∆∞∆°ng t·ª± coroutineScope nh∆∞ng ƒë·∫∑t gi·ªõi h·∫°n th·ªùi gian cho ph·∫ßn body v√† n·∫øu qu√° l√¢u s·∫Ω b·ªã h·ªßy. Throw m·ªôt TimeoutCancellationException. withTimeoutOrNull: t∆∞∆°ng t·ª± withTimeout nh∆∞ng s·∫Ω tr·∫£ v·ªÅ null thay v√¨ throw Exception khi h·∫øt th·ªùi gian. Ch·∫°y song song Khi b·∫°n mu·ªën th·ª±c hi·ªán hai t√°c v·ª• c√πng l√∫c v√† ƒë·ª£i k·∫øt qu·∫£ c·ªßa c·∫£ hai tr∆∞·ªõc khi tr·∫£ v·ªÅ k·∫øt qu·∫£:\nKhi b·∫°n c√≥ quy·ªÅn truy c·∫≠p v√†o m·ªôt scope (v√≠ d·ª• t·ª´ ViewModel) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 suspend fun getConfigFromAPI(): UserConfig { // th·ª±c hi·ªán l·ªánh g·ªçi API t·∫°i ƒë√¢y ho·∫∑c b·∫•t k·ª≥ suspend fun n√†o } suspend fun getSongsFromAPI(): List\u0026lt;Song\u0026gt; { // th·ª±c hi·ªán l·ªánh g·ªçi API t·∫°i ƒë√¢y ho·∫∑c b·∫•t k·ª≥ suspend fun n√†o } fun getConfigAndSongs() { // scope c√≥ th·ªÉ l√† b·∫•t k·ª≥ scope n√†o b·∫°n mu·ªën, tr∆∞·ªùng h·ª£p ƒëi·ªÉn h√¨nh s·∫Ω l√† viewModelScope scope.launch { val userConfig = async { getConfigFromAPI() } val songs = async { getSongsFromAPI() } return Pair(userConfig.await(), songs.await()) } } Gi·∫£ s·ª≠ b·∫°n c√≥ API ƒë∆∞·ª£c ph√¢n trang v√† b·∫°n mu·ªën t·∫£i xu·ªëng t·∫•t c·∫£ c√°c trang tr∆∞·ªõc khi hi·ªÉn th·ªã ch√∫ng cho ng∆∞·ªùi d√πng, nh∆∞ng b·∫°n mu·ªën t·∫£i song song t·∫•t c·∫£ c√°c trang:\n1 2 3 4 5 6 7 8 9 10 11 12 13 suspend fun getSongsFromAPI(page: Int): List\u0026lt;Song\u0026gt; { // th·ª±c hi·ªán l·ªánh g·ªçi API } const val totalNumberOfPages = 10 fun getAllSongs() { // scope c√≥ th·ªÉ l√† b·∫•t k·ª≥ scope n√†o b·∫°n mu·ªën, tr∆∞·ªùng h·ª£p ƒëi·ªÉn h√¨nh l√† viewModelScope scope.launch { val allNews = (0 until totalNumberOfPages) .map { page -\u0026gt; async { getSongsFromAPI(page) } } .flatMap { it.await } } } L∆∞u √Ω v·ªÅ async/await: coroutine s·∫Ω ƒë∆∞·ª£c b·∫Øt ƒë·∫ßu ngay l·∫≠p t·ª©c khi n√≥ ƒë∆∞·ª£c g·ªçi. async tr·∫£ v·ªÅ m·ªôt object thu·ªôc lo·∫°i Deferred\u0026lt;T\u0026gt; (trong v√≠ d·ª• c·ªßa ch√∫ng ta l√† Deferred\u0026lt;List\u0026lt;Song\u0026gt;\u0026gt;). Deferred c√≥ suspend function await tr·∫£ v·ªÅ gi√° tr·ªã khi n√≥ s·∫µn s√†ng.\nKhi b·∫°n kh√¥ng c√≥ quy·ªÅn truy c·∫≠p v√†o m·ªôt scope (v√≠ d·ª• t·ª´ m·ªôt repository) T·ª´ repository ho·∫∑c use case c·ªßa b·∫°n, b·∫°n mu·ªën ƒë·ªãnh nghƒ©a m·ªôt coroutine s·∫Ω b·∫Øt ƒë·∫ßu song song 2 (ho·∫∑c nhi·ªÅu) l·ªánh g·ªçi. V·∫•n ƒë·ªÅ l√† b·∫°n c·∫ßn m·ªôt scope ƒë·ªÉ s·ª≠ d·ª•ng async nh∆∞ng b·∫°n kh√¥ng ·ªü trong viewModel ho·∫∑c presenter n√™n b·∫°n kh√¥ng c√≥ quy·ªÅn truy c·∫≠p v√†o scope c·ªßa m√¨nh ·ªü ƒë√¢y (h√£y nh·ªõ quy t·∫Øc c·ªßa ch√∫ng ta l√† kh√¥ng n√™n truy·ªÅn scope nh∆∞ m·ªôt tham s·ªë).\nT·ª´ v√≠ d·ª• ·ªü tr√™n, ch√∫ng ta s·ª≠a l·∫°i m·ªôt ch√∫t nh∆∞ sau:\n1 2 3 4 5 suspend fun getConfigAndSongs(): Pair\u0026lt;UserConfig, List\u0026lt;Song\u0026gt; = coroutineScope { val userConfig = async { getConfigFromAPI() } val songs = async { getSongsFromAPI()} Pair(userConfig.await(), songs.await()) } D·ªçn d·∫πp khi Coroutine b·ªã cancel N·∫øu m·ªôt coroutine b·ªã h·ªßy th√¨ n√≥ s·∫Ω c√≥ tr·∫°ng th√°i cancelling tr∆∞·ªõc khi chuy·ªÉn sang cancelled. Khi m·ªôt coroutine b·ªã h·ªßy, ch√∫ng ta s·∫Ω c√≥ th·ªùi gian ƒë·ªÉ th·ª±c hi·ªán m·ªôt s·ªë t√°c v·ª• d·ªçn d·∫πp n·∫øu c·∫ßn thi·∫øt (ch·∫≥ng h·∫°n nh∆∞ d·ªçn d·∫πp local database ho·∫∑c g·ªçi API ƒë·ªÉ cho server bi·∫øt r·∫±ng t√°c v·ª• kh√¥ng th√†nh c√¥ng).\nCh√∫ng ta c√≥ th·ªÉ s·ª≠ d·ª•ng finally ƒë·ªÉ th·ª±c hi·ªán m·ªôt t√°c v·ª•:\n1 2 3 4 5 6 7 viewModelScope.launch { try { // g·ªçi m·ªôt s·ªë suspend function t·∫°i ƒë√¢y } finally { // th·ª±c hi·ªán t√°c v·ª• d·ªçn d·∫πp t·∫°i ƒë√¢y } } Nh∆∞ng kh√¥ng ƒë∆∞·ª£c ph√©p g·ªçi suspend function trong qu√° tr√¨nh d·ªçn d·∫πp. N·∫øu b·∫°n c·∫ßn g·ªçi suspend function, b·∫°n s·∫Ω c·∫ßn ph·∫£i l√†m nh∆∞ sau:\n1 2 3 4 5 6 7 8 9 viewModelScope.launch { try { // g·ªçi m·ªôt s·ªë suspend function t·∫°i ƒë√¢y } finally { withContext(NonCancellable) { // th·ª±c hi·ªán suspend function d·ªçn d·∫πp t·∫°i ƒë√¢y } } } L∆∞u √Ω: Vi·ªác cancel s·∫Ω x·∫£y ra t·∫°i ƒëi·ªÉm suspend ƒë·∫ßu ti√™n. V√¨ v·∫≠y vi·ªác cancel s·∫Ω kh√¥ng x·∫£y ra n·∫øu ch√∫ng kh√¥ng c√≥ b·∫•t k·ª≥ suspend function n√†o.\nD·ªçn d·∫πp Coroutine khi ho√†n th√†nh T∆∞∆°ng t·ª± nh∆∞ vi·ªác d·ªçn d·∫πp khi m·ªôt coroutine b·ªã h·ªßy, b·∫°n c√≥ th·ªÉ mu·ªën th·ª±c hi·ªán m·ªôt thao t√°c khi coroutine ƒë·∫°t ƒë·∫øn tr·∫°ng th√°i cu·ªëi c√πng (completed ho·∫∑c cancelled).\n1 2 3 4 5 6 suspend fun myFunction() = coroutineScope { val job = launch { /* suspend function t·∫°i ƒë√¢y */ } job.invokeOnCompletion { exception: Throwable -\u0026gt; // do something here } } L√†m c√°ch n√†o ƒë·ªÉ KH√îNG cancel Coroutine khi m·ªôt trong c√°c ph·∫ßn t·ª≠ con c·ªßa n√≥ b·ªã l·ªói B·∫°n c√≥ th·ªÉ s·ª≠ d·ª•ng SupervisorJob v√† n√≥ s·∫Ω b·ªè qua t·∫•t c·∫£ c√°c exception ·ªü con c·ªßa n√≥.\nT·∫°o coroutine scope c·ªßa b·∫°n 1 2 3 4 val scope = CoroutineScope(SupervisorJob()) // n·∫øu m·ªôt coroutine m·∫Øc l·ªói th√¨ coroutine c√≤n l·∫°i s·∫Ω kh√¥ng b·ªã h·ªßy scope.launch { myFirstCoroutine() } scope.launch { mySecondCoroutine() } S·ª≠ d·ª•ng scope function 1 2 3 4 5 suspend fun myFunction() = supervisorScope { // n·∫øu m·ªôt coroutine x·∫£y ra l·ªói th√¨ coroutine kia s·∫Ω kh√¥ng b·ªã h·ªßy launch { myFirstCoroutine() } launch { mySecondCoroutine() } } B·∫Øt exception 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 suspend fun myFunction() { try { coroutineScope { launch { myFirstCoroutine() } } } catch (e: Exception) { // x·ª≠ l√Ω l·ªói t·∫°i ƒë√¢y } try { coroutineScope { launch { mySecondCoroutine() } } } catch (e: Exception) { // x·ª≠ l√Ω l·ªói t·∫°i ƒë√¢y } } CancellationException kh√¥ng truy·ªÅn t·ªõi coroutine cha, ch·ªâ coroutine hi·ªán t·∫°i b·ªã cancel. C√≥ th·ªÉ k·∫ø th·ª´a CancellationException ƒë·ªÉ t·∫°o lo·∫°i exception c·ªßa ri√™ng b·∫°n, v√† n√≥ c≈©ng s·∫Ω kh√¥ng truy·ªÅn t·ªõi coroutine cha.\nƒê·ªãnh nghƒ©a t√°c v·ª• m·∫∑c ƒë·ªãnh trong tr∆∞·ªùng h·ª£p c√≥ exception Ch√∫ng ta c√≥ th·ªÉ s·ª≠ d·ª•ng CoroutineExceptionHandler. V√≠ d·ª•, d√πng ƒë·ªÉ t·ª± ƒë·ªông ƒëƒÉng xu·∫•t ng∆∞·ªùi d√πng khi server tr·∫£ v·ªÅ l·ªói 401.\n1 2 3 4 5 6 val handler = CoroutineExceptionHandler { context, exception -\u0026gt; // ƒë·ªãnh nghƒ©a t√°c v·ª• m·∫∑c ƒë·ªãnh nh∆∞ hi·ªÉn th·ªã h·ªôp tho·∫°i ho·∫∑c th√¥ng b√°o l·ªói } val scope = CoroutineScope(SupervisorJob() + handler) scope.launch { /* g·ªçi suspend function t·∫°i ƒë√¢y */ } scope.launch { /* g·ªçi suspend function t·∫°i ƒë√¢y */ } Ch·∫°y m·ªôt t√°c v·ª• kh√¥ng c·∫ßn thi·∫øt N·∫øu b·∫°n mu·ªën ch·∫°y m·ªôt suspend function m√† kh√¥ng ·∫£nh h∆∞·ªüng ƒë·∫øn c√°c function kh√°c (v√≠ d·ª• n·∫øu n√≥ g√¢y ra l·ªói th√¨ ch·ªâ h√†m n√†y s·∫Ω KH√îNG cancel coroutine, nh∆∞ng c√°c h√†m kh√°c n·∫øu g√¢y ra l·ªói th√¨ v·∫´n s·∫Ω cancel coroutine b√¨nh th∆∞·ªùng). V√≠ d·ª• ƒëi·ªÉn h√¨nh l√† c√°c function analytics.\n1 2 3 4 5 6 7 val nonEssentialOperationScope = CoroutineScope(SupervisorJob()) suspend fun getConfigAndSongs(): Pair\u0026lt;UserConfig, List\u0026lt;Song\u0026gt; = coroutineScope { val userConfig = async { getConfigFromAPI() } val songs = async { getSongsFromAPI()} nonEssentialOperationScope.launch { /* t√°c v·ª• kh√¥ng c·∫ßn thi·∫øt ·ªü ƒë√¢y */ } Pair(userConfig.await(), songs.await()) } L√Ω t∆∞·ªüng nh·∫•t l√† b·∫°n n√™n inject nonEssentialOperationScope v√†o class ƒë·ªÉ d·ªÖ test h∆°n.\nCh·∫°y m·ªôt t√°c v·ª• tr√™n single thread ƒë·ªÉ tr√°nh c√°c s·ª± c·ªë ƒë·ªìng b·ªô 1 2 3 4 suspend fun myFunction() = withContext(Dispatchers.Default.limiteParallelism(1)) { // suspend function t·∫°i ƒë√¢y } // C≈©ng c√≥ th·ªÉ s·ª≠ d·ª•ng Dispatchers.IO C√°c c√°ch ti·∫øp c·∫≠n kh√°c ƒë·ªÉ tr√°nh s·ª± c·ªë ƒë·ªìng b·ªô h√≥a v·ªõi multithreading B·∫°n c√≥ th·ªÉ s·ª≠ d·ª•ng AtomicReference (t·ª´ Java)\n1 2 3 4 5 6 private val myList = AtomicReference(listOf( /* th√™m object v√†o ƒë√¢y */ )) suspend fun fetchNewElement() { val myNewElement = // fetch ph·∫ßn t·ª≠ m·ªõi t·∫°i ƒë√¢y myList.getAndSet { it + myNewElement } } Ho·∫∑c v·ªõi Mutex\n1 2 3 4 5 6 7 8 9 val mutex = Mutex() private var myList = listOf( /* th√™m object v√†o ƒë√¢y */ ) suspend fun fetchNewElement() { mutex.withLock { val myNewElement = // fetch ph·∫ßn t·ª≠ m·ªõi t·∫°i ƒë√¢y myList += myNewElement } } Tr√°nh g·ª≠i l·∫°i m·ªôt coroutine ƒë·∫øn c√πng m·ªôt dispatcher Tr√°nh chi ph√≠ kh√¥ng c·∫ßn thi·∫øt khi chuy·ªÉn ƒë·ªïi dispatcher n·∫øu ch√∫ng ta ƒë√£ s·ª≠ d·ª•ng Dispatcher.Main:\n1 2 3 4 // ƒëi·ªÅu n√†y s·∫Ω ch·ªâ dispatch n·∫øu c·∫ßn thi·∫øt suspend fun myFunction() = withContext(Dispatcher.Main.immediate) { // suspend fun t·∫°i ƒë√¢y } Hi·ªán t·∫°i ch·ªâ Dispatchers.Main h·ªó tr·ª£ immediate dispatching.\nC·∫£m ∆°n b·∫°n ƒë√£ ƒë·ªçc ƒë·∫øn ƒë√¢y. N·∫øu b·∫°n c√≥ ki·∫øn th·ª©c hay ho ho·∫∑c tip v·ªÅ Kotlin Coroutines, ƒë·ª´ng ng·∫ßn ng·∫°i comment chia s·∫ª v·ªõi m√¨nh nh√©!\nReference https://medium.com/@galou.minisini/advanced-kotlin-coroutine-cheat-sheet-for-android-engineer-15e0d180fc1f ","date":"2024-08-12T00:00:00+07:00","image":"https://namanh11611.github.io/p/kotlin-coroutines-cheat-sheet/cheat_sheet_hu_f4de22ccd44420a7.webp","permalink":"https://namanh11611.github.io/p/kotlin-coroutines-cheat-sheet/","title":"Kotlin Coroutines cheat sheet n√¢ng cao d√†nh cho Android Engineer"},{"content":"Photo by Ashley Batz on Unsplash\nThe Journey Begins LeetCode is likely familiar to many of you‚Äîa platform for solving algorithm problems and preparing for coding interviews, especially for foreign companies and a few in Vietnam.\nI started my journey the same way, simply to prepare for interviews. I realized that practicing problems on LeetCode not only improved my coding skills but also gave me more confidence when facing algorithm and data structure-related interview questions.\nI began solving problems by topic. This approach helped me systematically organize my knowledge and master specific types of problems. By focusing on one topic at a time, I could deepen my understanding and solve problems more efficiently. Since I didn‚Äôt specialize in Computer Science and didn‚Äôt participate in algorithm competitions during university, I could manage problems involving BFS, DFS, Hash Table, Stack, or Queue, but initially struggled with topics like Dynamic Programming and Union Find. However, as the saying goes, \u0026ldquo;Practice makes perfect\u0026rdquo;, after solving about ten problems, it became much easier.\nIn this initial phase, I solved around 100 problems, which I found sufficient to interview with companies that typically ask easy-to-medium-level questions.\nSustaining as a Hobby After passing my interview and joining a good company, I stopped solving problems for about a year. Then, on a beautiful day, I felt inspired to pick it up again. During this second phase, I treated solving LeetCode problems as a daily hobby. I spent around 30 minutes a day solving one problem from the Daily Coding Challenge. This not only helped maintain my algorithm skills but also served as a form of relaxation and self-challenge. Moreover, solving random problems daily better mimicked real-life interview scenarios.\nI usually set a 30-minute timer, and if I couldn‚Äôt figure out a solution, I‚Äôd read the Editorial (solutions provided by LeetCode), then try to memorize and code it myself. After every problem, whether solved independently or with help, I would check the Solutions section to see how others approached it. The top-voted solutions often showcased creative and optimized methods, sometimes even better than the Editorial solutions.\nAs the saying goes, \u0026ldquo;If you want to go fast, go alone. If you want to go far, go together.\u0026rdquo; To find companions and exchange experiences, I frequently joined discussions on the voz forum. This not only motivated me but also allowed me to learn various approaches from the community. To maintain motivation, I set a specific goal: reaching 6000 points to earn the LeetCode T-shirt. Setting clear goals gave me a reason to keep pushing forward every day.\nAchieving the Goal and Deciding to Pause After about 1.5 years of consistent effort, on July 26, 2024, I finally achieved my goal of 6000 points and claimed the T-shirt.\nHowever, with work becoming busier, I decided to take a break and focus on current responsibilities. Interestingly, the number of problems I solved happened to be 555‚Äîa perfect milestone. Maybe it‚Äôs a signal from the universe.\nWhen working with Thai colleagues, I learned that 555 in Thai is pronounced like laughter, Hahaha. Isn‚Äôt this universal signal quite amusing?\nTaking a break doesn‚Äôt mean giving up. In the future, if I feel inspired or need to prepare for companies that demand higher algorithm expertise, I‚Äôll return to solving problems. The journey of solving 555 LeetCode problems has significantly enhanced my programming skills and logical thinking.\nWishing you all an energetic week ahead!\n","date":"2024-07-28T00:00:00+07:00","image":"https://namanh11611.github.io/p/leetcode/leetcode_hu_420f78f38869e6e7.webp","permalink":"https://namanh11611.github.io/p/leetcode/","title":"Journey of Solving 555 LeetCode Problems"},{"content":"Introduction Process is a fundamental but essential concept in Android. When we launch an application, by default, all components like Activity, Service, BroadcastReceiver, and ContentProvider run within a single Linux Process unless we specify a separate process in the AndroidManifest file, as shown below:\n1 2 3 4 \u0026lt;activity android:process=\u0026#34;new_process_name\u0026#34; ...\u0026gt; \u0026lt;/activity\u0026gt; By default, the process name matches the app ID declared in the build.gradle file. Both the application and the four main components have an android:process tag. Therefore, if you declare android:process for the \u0026lt;application\u0026gt; tag, that process name will apply to all components of that application.\nPriority Levels We cannot manage Process lifetime directly. Android automatically calculates which components of running applications are active, their importance to the user, and the remaining memory to decide the Process lifetime.\nWhen Android runs out of resources, it shuts down a Process, and naturally, the components running on that Process are destroyed as well. What determines which Process gets shut down?\nAndroid prioritizes Processes based on their importance to the user. It classifies Processes into four priority levels:\nForeground Process This is the highest priority Process. It contains components the user is actively interacting with, such as:\nActivity at the top of the screen that the user is engaging with, where the onResume() method has been called. BroadcastReceiver running, with its onReceive() method currently executing. Service executing code in one of its callbacks: onCreate(), onStart(), or onDestroy(). Only a few Processes like this exist in the system, and they are only killed when memory is so low that even these cannot continue running.\nVisible Process This Process performs tasks that the user is aware of. If killed, it would impact the user experience. Examples include:\nActivity displayed on the screen but not in the foreground, where the onPause() method has been called. For example, an Activity partially covered by a dialog. Foreground Service running via the startForeground() method, making it visible to the user. A service running a feature visible to the user, such as a live wallpaper or keyboard. Service Process This Process contains a Service running via the startService() method. The user does not see it directly but is aware of the tasks it performs, such as uploading or downloading data in the background.\nA long-running Service (e.g., more than 30 minutes) may have its importance reduced to a cached state.\nCached Process These Processes are no longer necessary, and the system can safely kill them without hesitation when more resources are required.\nAn efficient system will have many Cached Processes to facilitate smooth app transitions and frequently kill Cached apps when needed.\nAndroid uses LRU Cache (Least Recently Used Cache) to manage Cached Processes, prioritizing the removal of Processes least recently used.\nIn summary, understanding how components like Activity, Service, and BroadcastReceiver impact priority levels is crucial. Select the appropriate component for your use case to avoid a Process being killed during important tasks.\nInter-Process Communication (IPC) Inter-Process Communication, or IPC, is a mechanism that allows Processes to communicate and synchronize their actions in Android.\nEach app runs in a separate Process, but many apps need to communicate with each other to share data or perform collaborative tasks, making IPC essential for safe and efficient inter-Process communication.\nIntent Intent is the standard mechanism for asynchronous communication between Activities and BroadcastReceivers. Depending on the need, you can use sendBroadcast, sendOrderedBroadcast, or explicit intents.\nAndroid Interface Definition Language (AIDL) AIDL is a tool for defining interfaces between Android applications. It enables apps to communicate safely and efficiently, regardless of the programming languages they are written in.\nMessenger Messenger is a class in the Android SDK that allows applications to send and receive messages. It provides a simple interface for inter-application communication.\nThe main difference between AIDL and Messenger is that AIDL supports concurrent tasks, while Messenger is limited to sequential tasks.\nBroadcast Receiver BroadcastReceiver handles asynchronous requests from Intents. By default, any app can call the receiver. If you intend to use BroadcastReceiver for a specific application, you can secure it by using the \u0026lt;receiver\u0026gt; tag in the AndroidManifest. This prevents unauthorized apps from sending Intents to the BroadcastReceiver.\nReference https://developer.android.com/guide/components/processes-and-threads https://developer.android.com/guide/components/activities/process-lifecycle https://developer.android.com/privacy-and-security/security-tips#interprocess-communication ","date":"2024-06-21T00:00:00+07:00","image":"https://namanh11611.github.io/p/process/process_hu_bfc572b468ea73d1.webp","permalink":"https://namanh11611.github.io/p/process/","title":"Everything About Process in Android"},{"content":"C√≥ th·ªÉ n√≥i, trong qu√° tr√¨nh l√†m LeetCode th√¨ Dynamic Programming (DP), hay c√≤n g·ªçi l√† Quy ho·∫°ch ƒë·ªông trong ti·∫øng Vi·ªát, l√† m·ªôt d·∫°ng b√†i m·ªçi ng∆∞·ªùi th∆∞·ªùng xuy√™n g·∫∑p nh·∫•t, nh∆∞ng c≈©ng l√† m·ªôt trong nh·ªØng d·∫°ng kh√≥ nh·∫±n nh·∫•t. Khi g·∫∑p m·ªôt b√†i m·ªõi, n·∫øu b·∫°n nh·∫≠n ra n√≥ c√≥ th·ªÉ gi·∫£i b·∫±ng DP l√† b·∫°n ƒë√£ ƒëi ƒë∆∞·ª£c 80% qu√£ng ƒë∆∞·ªùng r·ªìi. V·∫≠y n√™n, ƒë·ªÉ gi√∫p cho qu√° tr√¨nh \u0026ldquo;nh·∫≠n ra\u0026rdquo; ƒë·∫•y tr·ªü n√™n d·ªÖ d√†ng h∆°n, trong b√†i vi·∫øt n√†y, m√¨nh s·∫Ω chia s·∫ª v·ªõi c√°c b·∫°n 5 d·∫°ng ph·ªï bi·∫øn c·ªßa DP tr√™n LeetCode.\nT√¨m gi√° tr·ªã nh·ªè nh·∫•t / l·ªõn nh·∫•t ƒê·ªÅ b√†i th∆∞·ªùng c√≥ d·∫°ng:\nCho m·ªôt m·ª•c ti√™u, t√¨m gi√° tr·ªã nh·ªè nh·∫•t / l·ªõn nh·∫•t ƒë·ªÉ ƒë·∫°t m·ª•c ti√™u ƒë√≥.\nH∆∞·ªõng gi·∫£i:\nT√¨m gi√° tr·ªã nh·ªè nh·∫•t / l·ªõn nh·∫•t trong s·ªë t·∫•t c·∫£ c√°c c√°ch c√≥ th·ªÉ tr∆∞·ªõc ƒë√≥, sau ƒë√≥ c·ªông v·ªõi gi√° tr·ªã c·ªßa tr·∫°ng th√°i hi·ªán t·∫°i.\n1 routes[i] = min(routes[i-1], ... , routes[i-k]) + cost[i] Khi gi·∫£i m·ªôt b√†i DP, ch√∫ng ta c√≥ 2 h∆∞·ªõng l√†m l√† Top-Down v√† Bottom-Up.\nTheo h∆∞·ªõng ti·∫øp c·∫≠n Top-Down, ch√∫ng ta s·∫Ω b·∫Øt ƒë·∫ßu b·∫±ng b√†i to√°n l·ªõn nh·∫•t hay l√† b√†i to√°n ·ªü m·ª©c tr√™n c√πng sau ƒë√≥ d√πng ph∆∞∆°ng ph√°p ƒë·ªá quy ƒë·ªÉ g·ªçi l·ªùi gi·∫£i cho c√°c b√†i to√°n con ·ªü m·ª©c th·∫•p h∆°n ti·∫øp theo. Qu√° tr√¨nh ti·∫øp t·ª•c cho ƒë·∫øn khi g·∫∑p b√†i to√°n nh·ªè nh·∫•t. ƒê·ªá quy s·∫Ω t·ª± ƒë·ªông t·ªï h·ª£p k·∫øt qu·∫£ c·ªßa c√°c b√†i to√°n con ƒë·ªÉ ƒë∆∞·ª£c k·∫øt qu·∫£ b√†i to√°n ban ƒë·∫ßu. Ch√∫ng ta th∆∞·ªùng s·∫Ω d√πng m·ªôt m·∫£ng memo ƒë·ªÉ l∆∞u k·∫øt qu·∫£ c√°c b√†i to√°n con, tr√°nh vi·ªác ph·∫£i t√≠nh ƒëi t√≠nh l·∫°i ch√∫ng g√¢y ra l·ªói Time Limit Exceeded.\n1 2 3 4 for (int j = 0; j \u0026lt; ways.size(); ++j) { result = min(result, topDown(target - ways[j]) + cost[i]); } return memo[/*state parameters*/] = result; C√≤n theo h∆∞·ªõng Bottom-Up, ch√∫ng ta s·∫Ω gi·∫£i c√°c b√†i to√°n con ·ªü m·ª©c th·∫•p nh·∫•t, sau ƒë√≥ d√πng c√°c k·∫øt qu·∫£ n√†y ƒë·ªÉ t√≠nh b√†i to√°n ·ªü m·ª©c tr√™n. Qu√° tr√¨nh ti·∫øp t·ª•c cho ƒë·∫øn khi ch√∫ng ta t√¨m ƒë∆∞·ª£c k·∫øt qu·∫£ b√†i to√°n m·ª©c cao nh·∫•t. C√° nh√¢n m√¨nh th√¨ th∆∞·ªùng l√†m theo h∆∞·ªõng nay h∆°n.\n1 2 3 4 5 6 7 8 for (int i = 1; i \u0026lt;= target; ++i) { for (int j = 0; j \u0026lt; ways.size(); ++j) { if (ways[j] \u0026lt;= i) { dp[i] = min(dp[i], dp[i - ways[j]] + cost[i]); } } } return dp[target] Ch√∫ng ta c√πng √°p d·ª•ng v√†o b√†i Min Cost Climbing Stairs\nCho m·∫£ng cost, trong ƒë√≥ cost[i] l√† chi ph√≠ c·ªßa b∆∞·ªõc th·ª© i tr√™n c·∫ßu thang. Khi b·∫°n tr·∫£ ph√≠, b·∫°n c√≥ th·ªÉ b∆∞·ªõc 1 ho·∫∑c 2 b∆∞·ªõc. B·∫°n ƒë∆∞·ª£c ch·ªçn b∆∞·ªõc t·ª´ v·ªã tr√≠ 0 ho·∫∑c 1.\nT√¨m chi ph√≠ nh·ªè nh·∫•t ƒë·ªÉ ƒëi h·∫øt c·∫ßu thang.\nB·∫°n c√≥ th·ªÉ nh·∫≠n th·∫•y r·∫±ng, khi x√©t b∆∞·ªõc th·ª© i, b·∫°n ch·ªâ c√≥ th·ªÉ b∆∞·ªõc ƒë·∫øn ƒë√¢y t·ª´ b∆∞·ªõc th·ª© i - 1 (b∆∞·ªõc 1 b∆∞·ªõc) ho·∫∑c t·ª´ b∆∞·ªõc th·ª© i - 2 (b∆∞·ªõc 2 b∆∞·ªõc). V·∫≠y n√™n, chi ph√≠ nh·ªè nh·∫•t khi b∆∞·ªõc ƒë·∫øn b∆∞·ªõc th·ª© i s·∫Ω b·∫±ng t·ªïng c·ªßa gi√° tr·ªã nh·ªè h∆°n trong 2 b∆∞·ªõc tr∆∞·ªõc ƒë√≥ c·ªông v·ªõi cost[i]. T·ª´ ƒë√≥ ch√∫ng ta c√≥ 2 c√°ch gi·∫£i t∆∞∆°ng ·ª©ng nh∆∞ sau.\nTop-Down\n1 2 3 int result = min(minCost(n-1, cost, memo), minCost(n-2, cost, memo)) + (n == cost.size() ? 0 : cost[n]); return memo[n] = result; Bottom-Up\n1 2 3 4 for (int i = 2; i \u0026lt;= n; ++i) { dp[i] = min(dp[i-1], dp[i-2]) + (i == n ? 0 : cost[i]); } return dp[n] T√¨m s·ªë c√°ch kh√°c nhau ƒê·ªÅ b√†i th∆∞·ªùng c√≥ d·∫°ng:\nCho m·ªôt m·ª•c ti√™u, t√¨m s·ªë c√°ch kh√°c nhau ƒë·ªÉ ƒë·∫°t m·ª•c ti√™u ƒë√≥.\nH∆∞·ªõng gi·∫£i:\nT√≠nh t·ªïng t·∫•t c·∫£ c√°c c√°ch c√≥ th·ªÉ ƒë·ªÉ ƒë·∫°t ƒë·∫øn m·ª•c ti√™u.\n1 routes[i] = routes[i-1] + routes[i-2] + ... + routes[i-k] Top-Down\n1 2 3 4 for (int j = 0; j \u0026lt; ways.size(); ++j) { result += topDown(target - ways[j]); } return memo[/*state parameters*/] = result; Bottom-Up\n1 2 3 4 5 6 7 8 for (int i = 1; i \u0026lt;= target; ++i) { for (int j = 0; j \u0026lt; ways.size(); ++j) { if (ways[j] \u0026lt;= i) { dp[i] += dp[i - ways[j]]; } } } return dp[target] Ch√∫ng ta c√πng √°p d·ª•ng v√†o b√†i Climbing Stairs\nB·∫°n ƒëang leo l√™n m·ªôt chi·∫øc c·∫ßu thang. N√≥ c·∫ßn n b∆∞·ªõc ƒë·ªÉ leo ƒë·∫øn ƒë·ªânh. M·ªói l·∫ßn b·∫°n ch·ªâ c√≥ th·ªÉ leo 1 ho·∫∑c 2 b∆∞·ªõc.\nH√£y t√≠nh b·∫°n c√≥ bao nhi√™u c√°ch kh√°c nhau ƒë·ªÉ leo ƒë·∫øn ƒë·ªânh?\nT∆∞∆°ng t·ª± nh∆∞ b√†i tr√™n, khi x√©t b∆∞·ªõc th·ª© i, b·∫°n ch·ªâ c√≥ th·ªÉ b∆∞·ªõc ƒë·∫øn ƒë√¢y t·ª´ b∆∞·ªõc th·ª© i - 1 (b∆∞·ªõc 1 b∆∞·ªõc) ho·∫∑c t·ª´ b∆∞·ªõc th·ª© i - 2 (b∆∞·ªõc 2 b∆∞·ªõc). V·∫≠y n√™n, s·ªë c√°ch kh√°c nhau leo ƒë·∫øn b∆∞·ªõc th·ª© i s·∫Ω b·∫±ng t·ªïng c·ªßa s·ªë c√°ch ƒë·∫øn b∆∞·ªõc i - 1 v√† s·ªë c√°ch ƒë·∫øn b∆∞·ªõc i - 2. T·ª´ ƒë√≥ ch√∫ng ta c√≥ 2 c√°ch gi·∫£i t∆∞∆°ng ·ª©ng nh∆∞ sau.\nTop-Down\n1 2 int result = climbStairs(n-1, memo) + climbStairs(n-2, memo); return memo[n] = result; Bottom-Up\n1 2 3 for (int stair = 2; stair \u0026lt;= n; ++stair) { dp[stair] = dp[stair-1] + dp[stair-2]; } H·ª£p nh·∫•t c√°c kho·∫£ng gi√° tr·ªã ƒê·ªÅ b√†i th∆∞·ªùng c√≥ d·∫°ng:\nCho m·ªôt b·ªô s·ªë, t√¨m gi·∫£i ph√°p t·ªëi ∆∞u cho m·ªôt b√†i to√°n m√† x√©t s·ªë hi·ªán t·∫°i v√† k·∫øt qu·∫£ t·ªët nh·∫•t b·∫°n c√≥ th·ªÉ nh·∫≠n ƒë∆∞·ª£c t·ª´ b√™n tr√°i v√† b√™n ph·∫£i.\nH∆∞·ªõng gi·∫£i:\nT√¨m t·∫•t c·∫£ gi·∫£i ph√°p t·ªëi ∆∞u cho m·ªói kho·∫£ng v√† tr·∫£ v·ªÅ k·∫øt qu·∫£ t·ªët nh·∫•t c√≥ th·ªÉ.\n1 2 // From i to j dp[i][j] = dp[i][k] + result[k] + dp[k+1][j] Top-Down\n1 2 3 4 for (int k = i; k \u0026lt;= j; ++k) { result = max(result, topDown(nums, i, k) + result[k] + topDown(nums, k+1, j)); } return memo[/*state parameters*/] = result; Bottom-Up\n1 2 3 4 5 6 7 8 9 for(int l = 1; l\u0026lt;n; l++) { for(int i = 0; i\u0026lt;n-l; i++) { int j = i+l; for(int k = i; k\u0026lt;j; k++) { dp[i][j] = max(dp[i][j], dp[i][k] + result[k] + dp[k+1][j]); } } } return dp[0][n-1]; Ch√∫ng ta c√πng √°p d·ª•ng v√†o b√†i Minimum Cost Tree From Leaf Values\nCho m·ªôt m·∫£ng arr c√°c s·ªë d∆∞∆°ng. Ch·ªçn t·∫•t c·∫£ c√¢y nh·ªã ph√¢n tho·∫£ m√£n ƒëi·ªÅu ki·ªán:\nM·ªói node c√≥ 0 ho·∫∑c 2 node con Gi√° tr·ªã c√°c ph·∫ßn t·ª≠ c·ªßa m·∫£ng arr t∆∞∆°ng ·ª©ng v·ªõi gi√° tr·ªã c·ªßa m·ªói l√° (node kh√¥ng c√≥ con) khi duy·ªát c√¢y theo in-order Gi√° tr·ªã c·ªßa m·ªói node kh√¥ng ph·∫£i l√° th√¨ b·∫±ng t√≠ch c·ªßa l√° l·ªõn nh·∫•t trong c√¢y con tr√°i v√† ph·∫£i c·ªßa n√≥ Trong t·∫•t c·∫£ c√°c c√¢y ƒë∆∞·ª£c ch·ªçn, t√¨m c√¢y c√≥ t·ªïng c√°c node kh√¥ng ph·∫£i l√° nh·ªè nh·∫•t.\n1 2 3 4 5 6 7 8 9 for (int l = 1; l \u0026lt; n; ++l) { for (int i = 0; i \u0026lt; n - l; ++i) { int j = i + l; dp[i][j] = INT_MAX; for (int k = i; k \u0026lt; j; ++k) { dp[i][j] = min(dp[i][j], dp[i][k] + dp[k+1][j] + maxs[i][k] * maxs[k+1][j]); } } } String ƒê·ªÅ b√†i cho String th∆∞·ªùng c√≥ r·∫•t nhi·ªÅu d·∫°ng, nh∆∞ng h·∫ßu h·∫øt ƒë·ªÅu l√† cho 1 ho·∫∑c 2 string v·ªõi ƒë·ªô d√†i kh√¥ng qu√° l·ªõn.\nCho 2 string s1 v√† s2, tr·∫£ v·ªÅ k·∫øt qu·∫£ g√¨ ƒë·∫•y.\nH∆∞·ªõng gi·∫£i:\nH·∫ßu h·∫øt c√°c b√†i to√°n d·∫°ng n√†y c√≥ th·ªÉ gi·∫£i v·ªõi k·∫øt qu·∫£ c√≥ ƒë·ªô ph·ª©c t·∫°p v·ªÅ th·ªùi gian l√† O(n).\n1 2 3 4 5 6 7 8 9 10 11 // i - indexing string s1 // j - indexing string s2 for (int i = 1; i \u0026lt;= m; ++i) { for (int j = 1; j \u0026lt;= n; ++j) { if (s1[i-1] == s2[j-1]) { dp[i][j] = /*code*/; } else { dp[i][j] = /*code*/; } } } N·∫øu ƒë·ªÅ b√†i ch·ªâ cho 1 string th√¨ c√°ch gi·∫£i s·∫Ω h∆°i kh√°c m·ªôt ch√∫t:\n1 2 3 4 5 6 7 8 9 10 for (int l = 1; l \u0026lt; n; ++l) { for (int i = 0; i \u0026lt; n-l; ++i) { int j = i + l; if (s[i] == s[j]) { dp[i][j] = /*code*/; } else { dp[i][j] = /*code*/; } } } Ch√∫ng ta c√πng √°p d·ª•ng v√†o b√†i Longest Common Subsequence\nCho 2 string text1 v√† text2, t√¨m chi·ªÅu d√†i l·ªõn nh·∫•t c·ªßa subsequence chung.\nX√©t k√Ω t·ª± th·ª© i c·ªßa text1 v√† k√Ω t·ª± th·ª© j c·ªßa text2.\nN·∫øu ch√∫ng gi·ªëng nhau, ch√∫ng ta tƒÉng chi·ªÅu d√†i subsequence chung th√™m 1 N·∫øu ch√∫ng kh√°c nhau, ch√∫ng ta s·∫Ω l·∫•y chi·ªÅu d√†i l·ªõn h∆°n trong 2 tr∆∞·ªùng h·ª£p i - 1 v·ªõi j ho·∫∑c i v·ªõi j - 1 1 2 3 4 5 6 7 8 9 for (int i = 1; i \u0026lt;= m; ++i) { for (int j = 1; j \u0026lt;= n; ++j) { if (text1[i-1] == text2[j-1]) { dp[i][j] = dp[i-1][j-1] + 1; } else { dp[i][j] = max(dp[i-1][j], dp[i][j-1]); } } } V·ªõi b√†i to√°n 1 string, ch√∫ng ta s·∫Ω √°p d·ª•ng v√†o b√†i Palindromic Substrings\nCho 1 string s, t√≠nh s·ªë l∆∞·ª£ng palindromic substring c·ªßa n√≥.\nCh√∫ng ta x√©t k√Ω t·ª± th·ª© i v√† j, n·∫øu ch√∫ng gi·ªëng nhau v√† substring t·ª´ i + 1 ƒë·∫øn j - 1 ƒë√£ l√† palindromic th√¨ ch√∫ng ta t√¨m ƒë∆∞·ª£c m·ªôt palindromic m·ªõi.\n1 2 3 4 5 6 7 8 9 10 for (int l = 1; l \u0026lt; n; ++l) { for (int i = 0; i \u0026lt; n-l; ++i) { int j = i + l; if (s[i] == s[j] \u0026amp;\u0026amp; dp[i+1][j-1] == j-i-1) { dp[i][j] = dp[i+1][j-1] + 2; } else { dp[i][j] = 0; } } } Ra quy·∫øt ƒë·ªãnh D·∫°ng b√†i th√¨ n·ªïi ti·∫øng v·ªõi lo·∫°t b√†i House Robber v√† Best Time to Buy and Sell Stock.\nƒê·ªÅ b√†i th∆∞·ªùng c√≥ d·∫°ng:\nCho m·ªôt t·∫≠p gi√° tr·ªã, t√¨m ƒë√°p √°n v·ªõi tu·ª≥ ch·ªçn l√† ch·ªçn ho·∫∑c b·ªè qua gi√° tr·ªã hi·ªán t·∫°i.\nH∆∞·ªõng gi·∫£i:\nN·∫øu b·∫°n quy·∫øt ƒë·ªãnh ch·ªçn gi√° tr·ªã hi·ªán t·∫°i, h√£y s·ª≠ d·ª•ng k·∫øt qu·∫£ tr∆∞·ªõc ƒë√≥, trong ƒë√≥ gi√° tr·ªã tr∆∞·ªõc ƒë√≥ b·ªã b·ªè qua. Ng∆∞·ª£c l·∫°i, n·∫øu b·∫°n quy·∫øt ƒë·ªãnh b·ªè qua gi√° tr·ªã hi·ªán t·∫°i, h√£y s·ª≠ d·ª•ng gi√° tr·ªã tr∆∞·ªõc ƒë√≥, trong ƒë√≥ gi√° tr·ªã tr∆∞·ªõc ƒë√≥ ƒë∆∞·ª£c s·ª≠ d·ª•ng.\n1 2 3 4 5 6 7 8 // i - indexing a set of values // j - options to ignore j values for (int i = 1; i \u0026lt; n; ++i) { for (int j = 1; j \u0026lt;= k; ++j) { dp[i][j] = max({dp[i][j], dp[i-1][j] + arr[i], dp[i-1][j-1]}); dp[i][j-1] = max({dp[i][j-1], dp[i-1][j-1] + arr[i], arr[i]}); } } Ch√∫ng ta c√πng √°p d·ª•ng v√†o b√†i House Robber\nB·∫°n l√† m·ªôt t√™n tr·ªôm chuy√™n nghi·ªáp ƒëang c√≥ k·∫ø ho·∫°ch ƒÉn tr·ªôm c·∫£ m·ªôt d√£y ph·ªë. Tuy nhi√™n d√£y ph·ªë n√†y c√≥ h·ªá th·ªëng an ninh li√™n k·∫øt v·ªõi nhau, v√† n√≥ s·∫Ω t·ª± ƒë·ªông b√°o c·∫£nh s√°t n·∫øu 2 ng√¥i nh√† c·∫°nh nhau c√πng b·ªã tr·ªôm.\nCho m·ªôt m·∫£ng nums ƒë·∫°i di·ªán cho s·ªë ti·ªÅn trong m·ªói ng√¥i nh√†. H√£y t√≠nh s·ªë ti·ªÅn t·ªëi ƒëa b·∫°n c√≥ th·ªÉ tr·ªôm ƒë∆∞·ª£c m√† kh√¥ng b·ªã b√°o c·∫£nh s√°t.\nCh√∫ng ta t·∫°o 1 m·∫£ng 2 chi·ªÅu v·ªõi c√¥ng th·ª©c:\ndp[i][1] l√† t·ªïng s·ªë ti·ªÅn n·∫øu quy·∫øt ƒë·ªãnh tr·ªôm nh√† th·ª© i dp[i][0] l√† t·ªïng s·ªë ti·ªÅn n·∫øu quy·∫øt ƒë·ªãnh kh√¥ng tr·ªôm nh√† th·ª© i 1 2 3 4 for (int i = 1; i \u0026lt; n; ++i) { dp[i][1] = max(dp[i-1][0] + nums[i], dp[i-1][1]); dp[i][0] = dp[i-1][1]; } Reference https://leetcode.com/discuss/general-discussion/458695/Dynamic-Programming-Patterns ","date":"2024-05-05T00:00:00+07:00","image":"https://namanh11611.github.io/p/dynamic-programming/dynamic_programming_hu_7dc8a035c2a4b0.webp","permalink":"https://namanh11611.github.io/p/dynamic-programming/","title":"LeetCode: D·ªÖ d√†ng nh·∫≠n bi·∫øt 5 d·∫°ng b√†i Dynamic Programming"},{"content":"Clean Code is probably a classic topic in programming. I once mentioned the book Clean Code by Uncle Bob in the article Things I Wish I Knew When I Was a Junior. However, this time I won\u0026rsquo;t rewrite the contents of that book‚Äîyou should read it directly for the best experience. I just want to share a few tips that I often use to keep my code tidy and clean.\nUse return to avoid if/else hell Have you ever encountered if/else hell like this in your code?\n1 2 3 4 5 6 7 8 9 10 11 void doSomething() { if (condition1) { doFirstTask(); if (condition2 != null) { doSecondTask(); if (condition3.isNotEmpty()) { doThirdTask(); } } } } In theory, the above code is fine. But I don\u0026rsquo;t like looking at code with so many nested layers. So I often use return to avoid writing too many nested braces {}. We can refactor the code above as follows:\n1 2 3 4 5 6 7 8 void doSomething() { if (!condition1) return doFirstTask(); if (condition2 == null) return doSecondTask(); if (condition3.isEmpty()) return doThirdTask(); } The logic is equivalent, but the meaning is slightly different. In the first case, when your colleague reads the code, they\u0026rsquo;ll understand: \u0026ldquo;If this condition is met, the code will continue to process like this.\u0026rdquo; In the second case, they\u0026rsquo;ll understand: \u0026ldquo;If this condition is not met, the code will not continue.\u0026rdquo; Thinking in the second way can sometimes feel a bit reversed, so apply this tip as appropriate, don\u0026rsquo;t use it mechanically in all cases.\nUse Map or Set instead of List Map and Set are two special data structures that you probably learned in university. However, in projects, people often always use List because it\u0026rsquo;s \u0026ldquo;convenient.\u0026rdquo; For me, before choosing a data type for a list, I always ask whether using Map or Set would make the code shorter and improve performance. If yes, I definitely prioritize these two types.\nFor example, I have a variable existingValueList which is a list of existing values. When a user enters a new value, I need to check if it already exists, and if so, return an error. If existingValueList is a List, I\u0026rsquo;d write the check like this:\n1 boolean isExisting = existingValueList.contains(value); But if it\u0026rsquo;s a Set, we\u0026rsquo;d write:\n1 boolean isExisting = existingValueSet.contains(value); \u0026ldquo;So, what\u0026rsquo;s the difference?\u0026rdquo; The way you write it is the same, but the difference lies in the contains() method: the runtime for List is O(n), while for Set it\u0026rsquo;s only O(1).\n99% of you probably know this, but sometimes you use List out of habit. So next time, before creating a List, pause for a moment to consider whether you should use Map or Set.\nThere are also other data structures like Stack, Queue, Tree\u0026hellip; But in real projects, I rarely encounter use-cases for these.\nDon\u0026rsquo;t comment out unused code‚Äîjust delete it I\u0026rsquo;ve noticed some people have the habit of commenting out old code when modifying a feature instead of deleting it. Or there are old functions that are no longer used, but they don\u0026rsquo;t bother to comment or delete them, just leaving them there forever. But trust me, a few months or even a few years later, you\u0026rsquo;ll probably never uncomment that code again. A few lines each time, but over the years it becomes a mountain of dead code.\nIf you want to review old code, Git can help you very well. So be bold and delete it‚Äînot just a few lines of code, a function, but also any resources of the app that you no longer use. This will help reduce your source code size significantly.\nIf you have any cool tips that you use, please share them with me!\n","date":"2024-05-01T00:00:00+07:00","image":"https://namanh11611.github.io/p/clean-code/tidy_hu_d9b9811218b84083.webp","permalink":"https://namanh11611.github.io/p/clean-code/","title":"3 Ways I Apply to Write Cleaner and Tidier Code"},{"content":"What is Flutter Hooks? When searching for the keyword Hooks on Google, you\u0026rsquo;ll find many results related to React. Indeed, as mentioned in the introduction, the flutter_hooks library by Remi Rousselet was built inspired by React.\nHooks are objects that help manage the life-cycle of a Widget. Their sole purpose is to increase the ability to share source code between Widgets by eliminating duplicated code.\nYou might wonder: \u0026ldquo;Wait, doesn\u0026rsquo;t StatefulWidget in Flutter already have initState and dispose methods to handle life-cycle management? Why do we need Hooks?\u0026rdquo; That\u0026rsquo;s correct, but it\u0026rsquo;s very difficult to reuse code in these two methods. Hooks were created to solve that problem.\nUsage Guide A simple example of Hooks is as follows:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class MyHookWidget extends HookWidget { const MyHookWidget({super.key}); @override Widget build(BuildContext context) { final counter = useState(0); return Scaffold( body: Center( child: Text(\u0026#39;Counter: ${counter.value}\u0026#39;), ), floatingActionButton: FloatingActionButton( onPressed: () =\u0026gt; counter.value++, child: const Icon(Icons.add), ), ); } } You can see that our Widget now extends HookWidget instead of StatefulWidget or StatelessWidget. In the build method, there\u0026rsquo;s a new keyword useState, which is one of the hooks in Flutter Hooks. We\u0026rsquo;ll explore some basic hooks below.\nNow, when you click the FloatingActionButton, the text value will change as the counter variable increases, similar to how StatefulWidget works, right?\nuseEffect hook This is similar to the useEffect hook in React, used to perform side effects synchronously during rendering. The effect can return a function, which will be called when the effect is recalled or the widget is disposed.\nBy default, the effect is called every build, unless you pass a key parameter. In that case, the effect is only called when the key changes.\nSide effects can include stream subscriptions, opening a WebSocket connection, or making an HTTP request. You can cancel them when the widget is disposed.\n1 2 3 4 5 6 useEffect(() { performSideEffect(); return () { cleanUp(); }; }, [key]); useState hook This is the most basic hook when you want to convert a StatelessWidget to a StatefulWidget. When called in the build method, it maintains state between widget rebuilds.\n1 final counter = useState(0); In this example, we pass an initial value of 0. The counter variable is an instance of ValueNotifier. The state is stored in the value property of ValueNotifier. Whenever the value changes, the useState hook will rebuild the widget to display the new value.\nuseMemoized hook This is a useful method when you need to create a complex object and want to return the same object across multiple child widget rebuilds. useMemoized helps cache that object; the value is only computed on the first call, and subsequent calls return the previously stored value.\n1 2 3 4 final complexObject = useMemoized( () =\u0026gt; createComplexObject(), [] ); useRef hook Creates an object containing a mutable property. However, changing the property of the object does not trigger an effect. It\u0026rsquo;s suitable for use-cases where you need to share state between build method calls, but want to avoid unnecessary rebuilds.\n1 2 3 4 5 6 7 8 9 10 11 12 final textController = useTextEditingController(); /// Using useState() in this case /// would cause the widget to rebuild on every character input // final name = useState(\u0026#39;\u0026#39;); final name = useRef(\u0026#39;\u0026#39;); useEffect(() { textController.addListener(() { name.value = textController.text; }); return null; }, []); useCallback hook Caches the instance of an entire function, if that function is recalled.\n1 2 3 final cachedFun = useCallback(() { Statements }, []); useContext hook Keeps the BuildContext of the HookWidget, so you don\u0026rsquo;t have to pass the context parameter through methods.\n1 2 3 4 5 Widget createSizedBox() { return SizedBox( height: MediaQuery.sizeOf(useContext()).height / 10 ); } useValueChanged hook Monitors a value and triggers a callback whenever its value changes. Returning to the initial example, let\u0026rsquo;s modify it a bit:\n1 2 3 4 5 6 7 final count = useState(0); final newCount = useState(0); useValueChanged(count.value, (oldValue, oldResult) { print(\u0026#39;oldValue = $oldValue, oldResult = $oldResult\u0026#39;); newCount.value += 5; return newCount.value; }); When you click the FloatingActionButton, the output will be printed as follows:\n1 2 3 4 oldValue = 0, oldResult = null oldValue = 1, oldResult = 5 oldValue = 2, oldResult = 10 ... As you can see, whenever the value of count changes, newCount also changes accordingly.\nuseStream hook Helps subscribe to a Stream and returns its current state.\n1 final snapshot = useStream(backend.stream); useAnimationController hook Creates an AnimationController and disposes it automatically.\n1 2 3 final controller = useAnimationController( duration: Duration(seconds: 1) ); Benefits of Hooks State Management: Hooks simplify local state management, ensuring widgets only handle logic relevant to themselves. Reduce duplicate code: Custom hooks allow you to reuse widget logic, significantly reducing duplicate code and improving code quality. Improve Hot Reload: With hooks, hot reload is less likely to fail because the hook\u0026rsquo;s state is preserved. Convenience: Some built-in hooks like useAnimationController, useFuture, and useStream are methods that can be applied to many common use-cases. Simplify life-cycle: Managing complex life-cycles becomes much simpler with Flutter Hooks. They provide a solution for easily managing state, side-effects, and stream subscriptions. Flexible custom hooks: Besides the built-in hooks, Flutter Hooks allows you to create custom hooks, making your code more flexible. You may already know that Remi Rousselet is also the author of two famous State Management libraries: Provider and Riverpod. He has combined Riverpod and Hooks in a library called Hooks Riverpod. You can harness the power of both with this library. Riverpod is for \u0026ldquo;global\u0026rdquo; application state, while hooks are for local widget state.\nConclusion I find Flutter Hooks quite promising, but not many projects have adopted it yet. Have you ever used it? If you see any pros or cons, please share with me!\n","date":"2024-04-30T00:00:00+07:00","image":"https://namanh11611.github.io/p/flutter-hooks/hooks_hu_57a8dae1706722c8.webp","permalink":"https://namanh11611.github.io/p/flutter-hooks/","title":"Flutter Hooks - Write More Concise and Efficient Code"},{"content":"Ch·ªØ Qu·ªëc ng·ªØ v·ªën ch·ª©a ƒë·ª±ng nhi·ªÅu l·ªói Tr∆∞·ªõc h·∫øt ƒë·ªÉ m·ªçi ng∆∞·ªùi kh√¥ng nh·∫ßm l·∫´n th√¨ c·∫ßn ph√¢n bi·ªát r√µ r√†ng 2 kh√°i ni·ªám ti·∫øng Vi·ªát v√† ch·ªØ Qu·ªëc ng·ªØ. Ti·∫øng Vi·ªát l√† ng√¥n ng·ªØ c·ªßa ng∆∞·ªùi Vi·ªát v√† ƒë√£ xu·∫•t hi·ªán t·ª´ kho·∫£ng ƒë·∫ßu C√¥ng nguy√™n, l√† c√°ch m√† cha √¥ng ta n√≥i chuy·ªán, giao ti·∫øp v·ªõi nhau, g·ªçi t√™n s·ª± v·∫≠t, hi·ªán t∆∞·ª£ng nh∆∞ tr·ªùi, ƒë·∫•t, b√°nh ch∆∞ng, b√°nh d√†y\u0026hellip; C√≤n ch·ªØ Qu·ªëc ng·ªØ l√† m·ªôt lo·∫°i ch·ªØ vi·∫øt d·ª±a tr√™n ch·ªØ c√°i Latinh, ƒë∆∞·ª£c s√°ng t·∫°o b·ªüi c√°c tu sƒ© B·ªì ƒê√†o Nha d√πng ƒë·ªÉ ghi √¢m ti·∫øng Vi·ªát v√†o ƒë·∫ßu th·∫ø k·ª∑ XVII.\nM√¨nh kh√¥ng c√≥ v·∫•n ƒë·ªÅ g√¨ v·ªõi ti·∫øng Vi·ªát, nh∆∞ng ch·ªØ Qu·ªëc ng·ªØ th√¨ m√¨nh th·∫•y n√≥ c√≤n ch·ª©a ƒë·ª±ng nhi·ªÅu l·ªói. V√≠ d·ª• nh∆∞ h·ªìi ƒëi h·ªçc, c√≥ bao gi·ªù b·∫°n th·∫Øc m·∫Øc:\nT·∫°i sao t√™n m·ªôt s·ªë ƒë·ªãa danh nh∆∞ ƒê·∫Øk L·∫Øk, ƒê·∫Øk N√¥ng l·∫°i c√≥ c√°ch vi·∫øt kh√°c v·ªõi c√°c t·ª´ th√¥ng th∆∞·ªùng? T·∫°i sao ch·ªØ c, g, ng l·∫°i kh√¥ng th·ªÉ ƒë·ª©ng tr∆∞·ªõc e, √™, i, m√† ch√∫ng ta ph·∫£i d√πng k, gh, ngh? T·∫°i sao B√°c H·ªì l·∫°i vi·∫øt l√† ƒê∆∞·ªùng K√°ch m·ªánh ch·ª© kh√¥ng ph·∫£i l√† ƒê∆∞·ªùng C√°ch m·∫°ng nh∆∞ ng√†y nay ch√∫ng ta hay vi·∫øt? Ch·ªØ Qu·ªëc ng·ªØ vay m∆∞·ª£n ch·ªß y·∫øu t·ª´ ti·∫øng B·ªì ƒê√†o Nha v√† ti·∫øng √ù, v√≠ d·ª• nh∆∞ trong ti·∫øng B·ªì ƒê√†o Nha, n·∫øu ƒë·ªÉ ch·ªØ c ƒë·ª©ng tr∆∞·ªõc a,o,u s·∫Ω bi·ªÉu th·ªã ph·ª• √¢m /k/, nh∆∞ng khi ƒë·ª©ng tr∆∞·ªõc e,i s·∫Ω bi·ªÉu th·ªã ph·ª• √¢m /s/. V√¨ v·∫≠y ƒë·ªÉ tr√°nh cho nh·ªØng ng∆∞·ªùi bi·∫øt ti·∫øng bi·∫øt B·ªì ƒê√†o Nha kh·ªèi ƒë·ªçc sai, c√°c tu sƒ© m·ªõi ƒë·∫∑t ra quy t·∫Øc ph·∫£i d√πng k thay cho c khi ƒë·ª©ng tr∆∞·ªõc e,√™,i,y.\nC√≤n v·ªõi ng∆∞·ªùi Vi·ªát Nam, ch√∫ng ta kh√¥ng b·ªã hi·ªÉu nh·∫ßm nh∆∞ tr√™n, n√™n ch√∫ng ta c√≥ th·ªÉ ho√†n to√†n d√πng c thay cho k trong m·ªçi t·ª´ m√† kh√¥ng b·ªã ph√°t √¢m sai. V√≠ d·ª• nh∆∞ n·∫øu m√¨nh vi·∫øt l√† con ci·∫øn thay cho con ki·∫øn, c√°i cem thay cho c√°i kem, m·∫∑c d√π l√† vi·∫øt sai ch√≠nh t·∫£, nh∆∞ng ng∆∞·ªùi Vi·ªát v·∫´n c√≥ th·ªÉ ƒë·ªçc ƒë√∫ng, ch·ª© kh√¥ng ƒë·ªçc th√†nh con si·∫øn hay c√°i sem nh∆∞ ng∆∞·ªùi B·ªì ƒê√†o Nha.\nNh∆∞ trong ti√™u ƒë·ªÅ c·ªßa b√†i vi·∫øt n√†y, m√¨nh d√πng t·ª´ k·∫£i k√°ch thay cho c·∫£i c√°ch nh∆∞ng c√°c b·∫°n v·∫´n hi·ªÉu √Ω m√¨nh ƒëang truy·ªÅn ƒë·∫°t ƒë√∫ng kh√¥ng?\nNh·ªØng c√¥ng tr√¨nh kh√¥ng bao gi·ªù ƒë∆∞·ª£c tri·ªÉn khai Nh·∫≠n th·∫•y s·ª± b·∫•t h·ª£p l√Ω n√†y, ƒë√£ c√≥ r·∫•t nhi·ªÅu c√¥ng tr√¨nh ƒë·ªÅ xu·∫•t c·∫£i ti·∫øn ch·ªØ Qu·ªëc ng·ªØ. Trong ƒë√≥ c√≥ th·ªÉ k·ªÉ ƒë·∫øn d·ª± th·∫£o Ph∆∞∆°ng √°n c·∫£i ti·∫øn ch·ªØ Qu·ªëc ng·ªØ b∆∞·ªõc ƒë·∫ßu c·ªßa Gi√°o s∆∞ Ho√†ng Ph√™ x√¢y d·ª±ng t·ª´ nh·ªØng nƒÉm 1960-1961. Trong ƒë√≥, √¥ng ƒë·ªÅ xu·∫•t m·ªôt s·ªë ƒëi·ªÉm nh∆∞:\nB·ªè h trong gh v√† ngh. V√≠ d·ª•: gh√™ -\u0026gt; g√™, nghe -\u0026gt; nge, nghi√™ng -\u0026gt; ngi√™ng. D√πng f thay ph, d thay ƒë, z thay d v√† gi. V√≠ d·ª•: d√¢n t·ªôc -\u0026gt; z√¢n t·ªôc, ƒë·∫•t n∆∞·ªõc -\u0026gt; d·∫•t n∆∞·ªõc, ph∆∞∆°ng ph√°p -\u0026gt; f∆∞∆°ng f√°p. Nh·∫•t lu·∫≠t vi·∫øt ph·ª• √¢m /k/ b·∫±ng k trong m·ªçi tr∆∞·ªùng h·ª£p, thay cho c, v√† nghi√™n c·ª©u thay c·∫£ cho q. V√≠ d·ª• nh∆∞ ƒê∆∞·ªùng k√°ch m·ªánh. Ho·∫∑c m·ªôt tr∆∞·ªùng h·ª£p n·ªïi ti·∫øng kh√°c l√† ƒë·ªÅ xu·∫•t Ph∆∞∆°ng √°n c·∫£i ti·∫øn ch·ªØ Qu·ªëc ng·ªØ c·ªßa Ph√≥ gi√°o s∆∞ B√πi Hi·ªÅn. √îng t·ª´ng c√¥ng b·ªë ƒë·ªÅ xu·∫•t ·ªü B√°o Gi√°o d·ª•c v√† Th·ªùi ƒë·∫°i s·ªë 72 ng√†y 8/9/1995. Cu·ªëi nƒÉm 2017, sau m·ªôt cu·ªôc h·ªôi th·∫£o th√¨ ƒë·ªÅ xu·∫•t c·ªßa √¥ng ƒë∆∞·ª£c ƒë∆∞a ra truy·ªÅn th√¥ng v√† ƒë√£ c√≥ b√†n c√£i s√¥i n·ªïi do nh·ªØng kh√°c l·∫° trong l·ªëi vi·∫øt c·∫£i ti·∫øn m√† √¥ng ƒë∆∞a ra. ·ªû th·ªùi ƒëi·ªÉm ƒë√≥, khi m√† ng∆∞·ªùi ng∆∞·ªùi nh√† nh√† ch√™ tr√°ch PGS B√πi Hi·ªÅn, c√≥ l·∫Ω m√¨nh l√† m·ªôt trong s·ªë √≠t nh·ªØng ng∆∞·ªùi th·∫•y ƒë∆∞·ª£c m·ªôt s·ªë ƒëi·ªÉm h·ª£p l√Ω trong ƒë·ªÅ xu·∫•t c·ªßa √¥ng (ch·ªâ m·ªôt s·ªë th√¥i ch·ª© kh√¥ng ph·∫£i to√†n b·ªô ph∆∞∆°ng √°n).\nNh∆∞ng qua nƒÉm th√°ng, c√°c b·∫°n c√≥ th·ªÉ th·∫•y nh·ªØng c√¥ng tr√¨nh tr√™n s·∫Ω kh√¥ng bao gi·ªù ƒë∆∞·ª£c tri·ªÉn khai, b·ªüi v√¨ n√≥ s·∫Ω g√¢y t·ªën k√©m r·∫•t l·ªõn v·ªÅ th·ªùi gian, ti·ªÅn b·∫°c v√† ngu·ªìn l·ª±c c·ªßa c·∫£ x√£ h·ªôi. H√£y th·ª≠ t∆∞·ªüng t∆∞·ª£ng c·∫£ n∆∞·ªõc ph·∫£i ƒëi ƒë·ªïi CƒÉn c∆∞·ªõc c√¥ng d√¢n, S·ªï h·ªô kh·∫©u, gi·∫•y t·ªù h√†nh ch√≠nh, c√°c b·ªô g√µ ti·∫øng Vi·ªát ph·∫£i c·∫≠p nh·∫≠t l·∫°i quy t·∫Øc, c√°c ph·∫ßn m·ªÅm ph·∫£i c·∫≠p nh·∫≠t l·∫°i giao di·ªán\u0026hellip; M√¨nh nghƒ© n√≥ ph·∫£i t·ªën c·∫£ ch·ª•c nƒÉm ƒë·ªÉ ho√†n th√†nh m·∫•t.\nNh·ªØng nguy√™n l√Ω trong l·∫≠p tr√¨nh C√¢u chuy·ªán tr√™n nghe qua th√¨ c√≥ v·∫ª nh∆∞ ch·∫≥ng li√™n quan ƒë·∫øn ng√†nh C√¥ng ngh·ªá th√¥ng tin, nh∆∞ng c√°c b·∫°n h√£y th·ª≠ xoay g√≥c nh√¨n, coi ch·ªØ Qu·ªëc ng·ªØ nh∆∞ m·ªôt ng√¥n ng·ªØ l·∫≠p tr√¨nh v·ªõi b·ªô quy t·∫Øc ri√™ng v·ªÅ c√°ch ƒë·∫∑t ph·ª• √¢m, c√°ch k·∫øt n·ªëi c√°c √¢m, c√°ch ƒë√°nh d·∫•u thanh\u0026hellip; Qua ƒë√≥, ch√∫ng ta s·∫Ω c√≥ m·ªôt s·ªë g√≥c nh√¨n m·ªõi v·ªÅ s·ª± ra ƒë·ªùi v√† ph√°t tri·ªÉn c·ªßa ch·ªØ Qu·ªëc ng·ªØ v√† li√™n h·ªá n√≥ v·ªõi c√°c nguy√™n l√Ω, b√†i h·ªçc trong ng√†nh l·∫≠p tr√¨nh.\nCode lu√¥n c√≥ ƒë·∫ßy r·∫´y edge case C√≥ th·ªÉ th·∫•y, t√™n m·ªôt s·ªë ƒë·ªãa danh nh∆∞ ƒê·∫Øk L·∫Øk, ƒê·∫Øk N√¥ng ch√≠nh l√† m·ªôt edge case c·ªßa ch·ªØ Qu·ªëc ng·ªØ. Trong l·∫≠p tr√¨nh c≈©ng v·∫≠y, ch√∫ng ta lu√¥n ph·∫£i l∆∞u √Ω x·ª≠ l√Ω edge case ƒë·ªÉ tr√°nh ch∆∞∆°ng tr√¨nh g·∫∑p l·ªói sau n√†y.\nV√≠ d·ª• nh∆∞ th·ª±c hi·ªán ph√©p chia th√¨ lu√¥n ph·∫£i ki·ªÉm tra tr∆∞·ªùng h·ª£p s·ªë chia kh√°c 0, t√¨m ph·∫ßn t·ª≠ ƒë·∫ßu ti√™n c·ªßa m·∫£ng th√¨ lu√¥n ph·∫£i ki·ªÉm tra tr∆∞·ªùng h·ª£p m·∫£ng b·ªã r·ªóng.\nV√≠ d·ª• b·∫°n c√≥ m·ªôt input text field th√¨ c·∫ßn suy nghƒ© c√°c edge case nh∆∞ user kh√¥ng nh·∫≠p g√¨, user nh·∫≠p text qu√° d√†i ho·∫∑c user nh·∫≠p sai format m√† ch√∫ng ta mong mu·ªën. Vi·ªác check edge case trong tr∆∞·ªùng h·ª£p n√†y c√≤n gi√∫p ch√∫ng ta tr√°nh ƒë∆∞·ª£c cu·ªôc t·∫•n c√¥ng Cross Site Scripting (XSS).\nT√≠nh t∆∞∆°ng th√≠ch ng∆∞·ª£c (Backward Compatible) Th·ª±c ra ch·ªØ Qu·ªëc ng·ªØ v·∫´n ƒëang c√≥ nh·ªØng s·ª± c·∫£i ti·∫øn t·ª´ l√∫c ra ƒë·ªùi ƒë·∫øn ng√†y nay. V√≠ d·ª• nh∆∞ ng√†y x∆∞a B√°c H·ªì vi·∫øt ƒê∆∞·ªùng K√°ch m·ªánh nh∆∞ng ng√†y nay ch√∫ng ta l·∫°i vi·∫øt l√† ƒê∆∞·ªùng C√°ch m·∫°ng. Ho·∫∑c tr∆∞·ªõc ƒë√¢y, c√°c t·ª´ gh√©p ho·∫∑c t√™n ri√™ng th∆∞·ªùng c√≥ d·∫•u g·∫°ch n·ªëi ·ªü gi·ªØa, v√≠ d·ª• nh∆∞ ƒë·ªôc-l·∫≠p, t·ª±-do, Vi·ªát-Nam, Lu√¢n-ƒê√¥n\u0026hellip; Th·∫ø nh∆∞ng ng√†y nay, nh·ªØng d·∫•u g·∫°ch n·ªëi ƒë√≥ ƒë√£ b·ªã b·ªè ƒëi. Nh·ªØng s·ª± c·∫£i ti·∫øn nh·ªè n√†y v·∫´n ƒë·∫£m b·∫£o m·ªçi ng∆∞·ªùi c√≥ th·ªÉ hi·ªÉu ƒë∆∞·ª£c c√°ch vi·∫øt m·ªõi d·ªÖ d√†ng, kh√¥ng c·∫ßn t·ªën qu√° nhi·ªÅu th·ªùi gian ƒë·ªÉ l√†m quen.\nTrong c√°c ng√¥n ng·ªØ l·∫≠p tr√¨nh, khi c√≥ n√¢ng c·∫•p m·ªôt version m·ªõi, th∆∞·ªùng n√≥ s·∫Ω lu√¥n ƒë∆∞·ª£c ƒë·∫£m b·∫£o t√≠nh t∆∞∆°ng th√≠ch ng∆∞·ª£c ƒë·ªÉ nh·ªØng ch∆∞∆°ng tr√¨nh vi·∫øt theo c√°ch vi·∫øt code c≈© kh√¥ng b·ªã x·∫£y ra l·ªói. V√≠ d·ª• nh∆∞ c√°c function c≈© c√≥ th·ªÉ b·ªã ƒë√°nh d·∫•u l√† Deprecated, hi·ªÉn th·ªã warning cho c√°c l·∫≠p tr√¨nh vi√™n bi·∫øt r·∫±ng function n√†y s·∫Ω s·ªõm b·ªã thay th·∫ø, nh∆∞ng kh√¥ng b·ªã xo√° ngay ƒë·ªÉ ch√∫ng ta c√≥ th·ªùi gian update n√≥.\nCode ƒëang ch·∫°y ·ªïn th√¨ ƒë·ª´ng ƒë·ª•ng v√†o Vi·ªác ƒë·ªÅ xu·∫•t c·∫£i c√°ch c·ªßa PGS B√πi Hi·ªÅn b·ªã d∆∞ lu·∫≠n ph·∫£n ·ª©ng d·ªØ d·ªôi m·ªôt ph·∫ßn v√¨ n√≥ kh√°c qu√° xa v·ªõi nh·ªØng g√¨ m√† m·ªçi ng∆∞·ªùi ƒëang ƒë·ªçc, ƒëang vi·∫øt h√†ng ng√†y. N·∫øu ƒë∆∞·ª£c √°p d·ª•ng v√†o th·ª±c t·∫ø, ch·∫Øc ch·∫Øn trong qu√° tr√¨nh th·ª±c thi s·∫Ω c√≥ nh·ªØng s·ª± xung ƒë·ªôt gi·ªØa nh·ªØng vƒÉn b·∫£n, ph·∫ßn m·ªÅm ƒë∆∞·ª£c vi·∫øt b·∫±ng ki·ªÉu ch·ªØ c≈© v√† ki·ªÉu ch·ªØ c·∫£i c√°ch.\nN√≥ gi·ªëng nh∆∞ c√¢u chuy·ªán kinh ƒëi·ªÉn trong ng√†y l·∫≠p tr√¨nh m√† anh em th∆∞·ªùng n√≥i vui v·ªõi nhau \u0026ldquo;Code ƒëang ch·∫°y ·ªïn th√¨ ƒë·ª´ng ƒë·ª•ng v√†o\u0026rdquo;. H·ªìi m·ªõi ra tr∆∞·ªùng, m√¨nh t·ª´ng nhi·ªát t√¨nh xung phong refactor m·ªôt feature c√≥ flow kh√° ph·ª©c t·∫°p. Th·∫ø r·ªìi h·∫≠u qu·∫£ l√† m√¨nh m·∫•t m·ªôt m·ªõ th·ªùi gian ƒë·ªÉ ƒëi fix bug cho nh·ªØng corner case c·ªßa feature ƒë√≥ m√† khi b·∫Øt ƒë·∫ßu l√†m m√¨nh ch∆∞a l∆∞·ªùng tr∆∞·ªõc h·∫øt ƒë∆∞·ª£c.\nPh√°t hi·ªán l·ªói c√†ng mu·ªôn, chi ph√≠ s·ª≠a ƒë·ªïi c√†ng l·ªõn Nh∆∞ m√¨nh chia s·∫ª ·ªü tr√™n, nh·ªØng c√¥ng tr√¨nh c·∫£i c√°ch ch·ªØ Qu·ªëc ng·ªØ tr√™n c√≥ th·ªÉ s·∫Ω kh√¥ng bao gi·ªù ƒë∆∞·ª£c ƒë∆∞a v√†o ƒë·ªùi s·ªëng b·ªüi v√¨ s·ª± t·ªën k√©m c·ªßa n√≥. N·∫øu mu·ªën s·ª≠a, c√≥ l·∫Ω th·ªùi ƒëi·ªÉm t·ªët nh·∫•t l√† l√∫c\u0026hellip; c√°c tu s·ªπ B·ªì ƒê√†o Nha m·ªõi s√°ng t·∫°o ra n√≥.\nC√πng l√† m·ªôt bug, n·∫øu b·∫°n ph√°t hi·ªán ra n√≥ ·ªü phase develop, b·∫°n ch·ªâ c·∫ßn s·ª≠a v√†i d√≤ng code l√† xong. N·∫øu n√≥ ƒë√£ ƒë∆∞·ª£c release l√™n beta, vi·ªác ch·ªânh s·ª≠a c√≥ th·ªÉ s·∫Ω ·∫£nh h∆∞·ªüng ƒë·∫øn m·ªôt nh√≥m nh·ªè user. C√≤n n·∫øu xui h∆°n l√† s·∫£n ph·∫©m ƒë√£ ƒë∆∞·ª£c release l√™n production t·ªõi to√†n b·ªô user, m·ªôt thay ƒë·ªïi nh·ªè c√≥ th·ªÉ g√¢y ·∫£nh h∆∞·ªüng c·ª±c l·ªõn, v√≠ d·ª• nh∆∞ l√†m m·∫•t d·ªØ li·ªáu c·ªßa user ho·∫∑c g√¢y ra tr·∫£i nghi·ªám t·ªá trong qu√° tr√¨nh s·ª≠ d·ª•ng ph·∫ßn m·ªÅm.\nB·∫°n c√≥ nh·ªõ ƒë·∫øn tr∆∞·ªùng h·ª£p l·ªói pin c·ªßa ƒëi·ªán tho·∫°i Galaxy Note 7 kh√¥ng? S·ª± c·ªë n√†y ƒë√£ khi·∫øn Samsung ph·∫£i thu h·ªìi d√≤ng ƒëi·ªán tho·∫°i n√†y, g√¢y thi·ªát h·∫°i cho h√£ng 5,4 t·ª∑ USD.\nK·∫øt lu·∫≠n B√†i vi·∫øt n√†y ch·ªâ ƒë∆∞a ra m·ªôt g√≥c nh√¨n th√∫ v·ªã v·ªÅ l·∫≠p tr√¨nh v√† cu·ªôc s·ªëng, kh√¥ng nh·∫±m m·ª•c ƒë√≠ch c√¥ng k√≠ch t·ªï ch·ª©c hay c√° nh√¢n n√†o. Hy v·ªçng b·∫°n coi n√≥ nh∆∞ m·ªôt b√†i vi·∫øt mang t√≠nh gi·∫£i tr√≠ trong l√∫c tr√† d∆∞ t·ª≠u h·∫≠u.\n","date":"2024-03-20T00:00:00+07:00","image":"https://namanh11611.github.io/p/vietnamese/vietnamese_hu_593a2789458321e9.webp","permalink":"https://namanh11611.github.io/p/vietnamese/","title":"T·ª´ c√¢u chuy·ªán k·∫£i k√°ch ch·ªØ Qu·ªëc ng·ªØ ƒë·∫øn nh·ªØng nguy√™n l√Ω trong l·∫≠p tr√¨nh"},{"content":"The Old Days As you know, diagrams and documentation play an important role in projects. They act as a compass to help developers understand the ideas of PMs, tech leads, or BAs, guide the required flow, and serve as evidence for reference when there are disputes about project requirements. A picture is worth a thousand words; sometimes a clear diagram can save hours of explanation and back-and-forth discussion.\nPreviously, when drawing diagrams for projects, I often used draw.io. For those who don\u0026rsquo;t know, it\u0026rsquo;s an online tool for drawing diagrams by drag and drop. But every time I needed to update a diagram, I had to drag and drop each box or arrow again, which was quite time-consuming. Until one day, a colleague introduced me to Mermaid, and everything changed\u0026hellip;\nEnlightened by Mermaid According to the definition on the official website, Mermaid is a tool built on JavaScript that helps create diagrams and charts flexibly from text with syntax similar to Markdown.\nAdvantages This is an open-source and completely free tool. It supports many popular types of diagrams and charts such as Flowchart, Sequence diagram, Class diagram, State diagram, Git graph\u0026hellip;\nThe syntax is very simple and easy to learn. If you\u0026rsquo;re already familiar with Markdown, you just need to spend a little time to master it. Now, whenever project requirements change, you only need to edit a few lines of text and the diagram will be updated quickly.\nFor simple diagrams, you can use Mermaid Live Editor without installing anything. For company projects, Mermaid is already integrated with Notion or Atlassian products. If you want to use it locally, Mermaid works right in popular IDEs like Visual Studio Code or JetBrains family.\nComparison with PlantUML There are other tools on the market that render diagrams from text like Mermaid, the most notable being PlantUML. Below is a comparison table for an overview.\nCriteria Mermaid PlantUML GitHub Star (25/2/2024) 65,400 9,300 Diagram types Flow, Sequence, Class, State, Git graph\u0026hellip; Sequence, Usecase, Class, Object, Activity, State\u0026hellip; Online support Yes Yes Offline support Yes Yes Pricing Free Free Others Easy to learn, user-friendly for beginners Many extension libraries Installation on Visual Studio Code Currently, in my project, the team is creating a separate project for diagrams, using Git for version control and Visual Studio Code for drawing.\nYou only need to install 2 extensions: Markdown Preview Mermaid Support and Mermaid Markdown Syntax Highlighting on Visual Studio Code to get started.\nWhenever you need to draw a diagram, create a file with the .md extension and write the Mermaid syntax. You can click the Open Preview button in the top right corner to code and see the diagram updated live beside it. The result is as follows:\nJust check out the example first, and I\u0026rsquo;ll go into detail about the syntax for each type of diagram in the next section.\nSyntax for Common Diagrams Flowchart A flowchart consists of nodes and edges (which can be undirected edges or directed arrows). The Mermaid code will determine how to create the nodes and edges, with customizable edge types according to the drawer\u0026rsquo;s intention.\nSample syntax:\n1 2 3 4 5 flowchart TD A--\u0026gt;B; A--\u0026gt;C; B--\u0026gt;D; C--\u0026gt;D; flowchart: the keyword for this type of chart (you can also use graph interchangeably). TD: the direction of the chart (top to down). Other options include: TB: top to bottom (same as top to down) BT: bottom to top RL: right to left LR: left to right A, B, C, D: the names of the nodes. Besides the default rectangle, you can also use other shapes like rounded rectangles, trapezoids, circles, etc. --\u0026gt;: directed edge type. There are also undirected, bidirectional types, and types with attached text\u0026hellip; Result:\nSequence diagram A sequence diagram is an interaction diagram that shows how different processes operate with each other and in what order.\nSample syntax:\n1 2 3 4 5 6 7 8 9 10 11 12 sequenceDiagram participant Alice participant Bob participant John Alice-\u0026gt;\u0026gt;John: Hello John, how are you? loop Healthcheck John-\u0026gt;\u0026gt;John: Fight against hypochondria end Note right of John: Rational thoughts \u0026lt;br/\u0026gt;prevail! John--\u0026gt;\u0026gt;Alice: Great! John-\u0026gt;\u0026gt;Bob: How about you? Bob--\u0026gt;\u0026gt;John: Jolly good! sequenceDiagram: the keyword for the diagram. participant: defines the participants in the diagram in sequential order. In this example, we have 3 participants: Alice, Bob, and John. Each line defines the message between the participants. -\u0026gt;\u0026gt;, --\u0026gt;\u0026gt;: directed message types with solid and dashed lines. Result:\nClass diagram A class diagram in UML (Unified Modeling Language) is a type of static structure diagram that describes the structure of a system by showing the classes of the system, their attributes, operations (or methods), and the relationships between objects.\nSample syntax:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 classDiagram Class01 \u0026lt;|-- AveryLongClass : Cool Class03 *-- Class04 Class05 o-- Class06 Class07 .. Class08 Class09 --\u0026gt; C2 : Where am i? Class09 --* C3 Class09 --|\u0026gt; Class07 Class07 : equals() Class07 : Object[] elementData Class01 : size() Class01 : int chimp Class01 : int gorilla Class08 \u0026lt;--\u0026gt; C2: Cool label classDiagram: the keyword for the diagram. chimp, gorilla, elementData: attributes of the classes. size(), equals(): methods of the classes. *--, o--: relationships between classes. Result:\nState diagram A state diagram is a type of diagram that describes the behavior of a system, showing some of the system\u0026rsquo;s states.\nSample syntax:\n1 2 3 4 5 6 7 8 stateDiagram [*] --\u0026gt; Still Still --\u0026gt; [*] Still --\u0026gt; Moving Moving --\u0026gt; Still Moving --\u0026gt; Crash Crash --\u0026gt; [*] stateDiagram: the keyword for the diagram. [*]: start or end point. Still, Moving, Crash: the states of the system. --\u0026gt;: state transition steps. Result:\nGit graph A git graph illustrates git commits and git actions (commands) on different branches.\nSample syntax:\n1 2 3 4 5 6 7 8 9 10 gitGraph commit commit branch develop commit commit commit checkout main commit commit gitGraph: the keyword for the graph. commit: creates a new commit on the current branch. branch: creates and switches to a new branch, setting it as the current branch. checkout: checks out an existing branch and sets it as the current branch. merge: merges a branch into the current branch. Result:\nConclusion Mermaid is truly powerful and flexible; it provides us with many options to draw various types of diagrams. However, in this short article, I couldn\u0026rsquo;t introduce all those options to you. If you need more details, you can refer to the Mermaid documentation linked in each title section. I hope you now have an overview of Mermaid and can apply it in your projects or your team\u0026rsquo;s projects, helping save time and effort.\n","date":"2024-02-25T00:00:00+07:00","image":"https://namanh11611.github.io/p/mermaid/mermaid_hu_c8c4391643101b0.webp","permalink":"https://namanh11611.github.io/p/mermaid/","title":"Mermaid - Draw diagrams and charts as easily as candy with Markdown"},{"content":"V·∫•n ƒë·ªÅ G·∫ßn ƒë√¢y m√¨nh c√≥ tham gia luy·ªán LeetCode ƒë·ªÉ t√¨m ni·ªÅm vui sau nh·ªØng gi·ªù l√†m vi·ªác cƒÉng th·∫≥ng. Th·ªânh tho·∫£ng m√¨nh g·∫∑p m·ªôt v√†i b√†i c·∫ßn ph·∫£i √°p d·ª•ng Binary Search ƒë·ªÉ gi·∫£i. D√†nh cho anh em n√†o ch∆∞a bi·∫øt th√¨:\nBinary Search l√† thu·∫≠t to√°n t√¨m ki·∫øm m·ªôt gi√° tr·ªã target trong m·∫£ng ƒë√£ ƒë∆∞·ª£c s·∫Øp x·∫øp. N√≥ s·∫Ω so s√°nh target v·ªõi ph·∫ßn t·ª≠ ch√≠nh gi·ªØa c·ªßa m·∫£ng (middle), n·∫øu target != middle th√¨ s·∫Ω ti·∫øp t·ª•c t√¨m ki·∫øm trong m·ªôt n·ª≠a m·∫£ng c√≥ gi√° tr·ªã nh·ªè h∆°n ho·∫∑c l·ªõn h∆°n middle, tu·ª≥ theo ƒëi·ªÅu ki·ªán b√†i to√°n. Qu√° tr√¨nh n√†y ƒë∆∞·ª£c l·∫∑p l·∫°i cho ƒë·∫øn khi t√¨m ƒë∆∞·ª£c v·ªã tr√≠ c·ªßa ph·∫ßn t·ª≠ b·∫±ng v·ªõi target.\nSau m·ªói b∆∞·ªõc t√¨m ki·∫øm, s·ªë l∆∞·ª£ng ph·∫ßn t·ª≠ s·∫Ω gi·∫£m ƒëi m·ªôt n·ª≠a. V·∫≠y n√™n ƒë·ªô ph·ª©c t·∫°p c·ªßa thu·∫≠t to√°n n√†y l√† O(log n).\nTuy nhi√™n, khi √°p d·ª•ng thu·∫≠t to√°n n√†y th√¨ m√¨nh g·∫∑p m·ªôt s·ªë c√¢u h·ªèi c·∫ßn tr·∫£ l·ªùi l√†:\nKhi n√†o n√™n d·ª´ng v√≤ng l·∫∑p? Khi left \u0026lt; right hay left \u0026lt;= right? (left v√† right l√† 2 gi√° tr·ªã bi√™n c·ªßa m·∫£ng sau m·ªói v√≤ng l·∫∑p) N√™n update c√°c gi√° tr·ªã bi√™n nh∆∞ th·∫ø n√†o? D√πng left = mid hay left = mid + 1? D√πng right = mid hay right = mid + 1? Nh√¨n c√≥ v·∫ª ƒë∆°n gi·∫£n nh∆∞ng vi·ªác ch·ªçn sai c√¥ng th·ª©c c√≥ th·ªÉ d·∫´n ƒë·∫øn k·∫øt qu·∫£ sai, r·ªìi m√¨nh l·∫°i ph·∫£i s·ª≠a ƒëi s·ª≠a l·∫°i r·∫•t m·∫•t th·ªùi gian.\nCho ƒë·∫øn m·ªôt ng√†y, m√¨nh t√¨m ƒë∆∞·ª£c m·ªôt c√¥ng th·ª©c th·∫ßn th√°nh\u0026hellip;\nTemplate ƒë∆°n gi·∫£n Ta\u0026hellip; da\u0026hellip; T√°c gi·∫£ chia s·∫ª chi ti·∫øt v·ªÅ template r·∫•t ƒë∆°n gi·∫£n nh∆∞ng th·∫ßn th√°nh ·ªü b√†i vi·∫øt n√†y.\nTheo ƒë√≥, gi·∫£ s·ª≠ ch√∫ng ta c√≥ m·ªôt search space, n√≥ c√≥ th·ªÉ l√† m·ªôt m·∫£ng ho·∫∑c m·ªôt kho·∫£ng gi√° tr·ªã, th∆∞·ªùng s·∫Ω ƒë∆∞·ª£c s·∫Øp x·∫øp theo th·ª© t·ª± tƒÉng d·∫ßn. Nhi·ªám v·ª• c·ªßa ch√∫ng ta l√† t√¨m gi√° tr·ªã num nh·ªè nh·∫•t sao cho h√†m condition(num) tr·∫£ v·ªÅ gi√° tr·ªã true.\nTemplate c·ªßa ch√∫ng ta nh∆∞ sau (m√¨nh s·∫Ω vi·∫øt b·∫±ng code Java cho ƒëa s·ªë m·ªçi ng∆∞·ªùi d·ªÖ ƒë·ªçc nh√©):\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 int binarySearch() { // B·∫°n t·ª± ƒë·ªãnh nghƒ©a gi√° tr·ªã kh·ªüi t·∫°o c·ªßa 2 bi√™n int left = min(searchSpace), right = max(searchSpace); while (left \u0026lt; right) { // Vi·∫øt nh∆∞ th·∫ø n√†y ƒë·ªÉ tr√°nh tr√†n s·ªë int mid = left + (right - left) / 2; if (condition(mid)) { right = mid; } else { left = mid + 1; } } // C√≥ th·ªÉ l√† left ho·∫∑c left - 1 tu·ª≥ y√™u c·∫ßu b√†i to√°n return left; } boolean condition(int num) { // Code check condition } B·∫°n c√≥ th·ªÉ √°p d·ª•ng template n√†y v√†o t·∫•t c·∫£ c√°c b√†i binary search, khi ƒë√≥ b·∫°n c·∫ßn th·ª±c hi·ªán 3 vi·ªác:\nT√¨m gi√° tr·ªã left v√† right ph√π h·ª£p. B·∫°n c·∫ßn ch·∫Øc ch·∫Øn r·∫±ng 2 gi√° tr·ªã bi√™n n√†y ƒë√£ bao g·ªìm t·∫•t c·∫£ c√°c gi√° tr·ªã c√≥ th·ªÉ l√† k·∫øt qu·∫£ c·ªßa b√†i to√°n. ƒê·ªãnh nghƒ©a h√†m condition ch√≠nh x√°c. ƒê√¢y th∆∞·ªùng l√† ph·∫ßn kh√≥ nh·∫•t trong c√°c b√†i binary search ph·ª©c t·∫°p. Ch·ªçn gi√° tr·ªã tr·∫£ v·ªÅ l√† left hay left - 1. Nh·ªõ r·∫±ng khi k·∫øt th√∫c v√≤ng l·∫∑p while, left l√† index c·ªßa ph·∫ßn t·ª≠ nh·ªè nh·∫•t tho·∫£ m√£n h√†m condition tr·∫£ v·ªÅ true. H√£y t∆∞·ªüng t∆∞·ª£ng, ch√∫ng ta c√≥ d√£y s·ªë v·ªõi index t·ª´ 0 ƒë·∫øn n nh∆∞ sau:\n1 2 Index: 0, 1, ... left - 1, left, ... n - 1, n Condition return: False, False, ... False, True, True, True V·∫≠y n·∫øu b√†i to√°n y√™u c·∫ßu t√¨m gi√° tr·ªã nh·ªè nh·∫•t tho·∫£ m√£n condition return true th√¨ b·∫°n return left, c√≤n n·∫øu y√™u c·∫ßu t√¨m gi√° tr·ªã l·ªõn nh·∫•t tho·∫£ m√£n condition return false th√¨ b·∫°n return left - 1.\n√Åp d·ª•ng v√†o problem ƒë∆°n gi·∫£n B·∫Øt ƒë·∫ßu v·ªõi b√†i to√°n t√¨m cƒÉn b·∫≠c 2 c·ªßa s·ªë X: Sqrt(x)\nCho m·ªôt s·ªë nguy√™n kh√¥ng √¢m x, t√¨m cƒÉn b·∫≠c 2 c·ªßa x, l√†m tr√≤n xu·ªëng s·ªë nguy√™n kh√¥ng √¢m g·∫ßn x nh·∫•t.\nƒêi·ªÅu ki·ªán: $0 \u0026lt;= x \u0026lt;= 2^{31} - 1$\nV√≠ d·ª• 1:\n1 2 Input: 4 Output: 2 V√≠ d·ª• 2:\n1 2 Input: 8 Output: 2 Ch√∫ng ta d·ªÖ d√†ng nh·∫≠n th·∫•y r·∫±ng h√†m condition c√≥ th·ªÉ vi·∫øt nh∆∞ sau:\n1 2 3 boolean condition(int num) { return x / num \u0026lt; num; } V√† khi k·∫øt th√∫c v√≤ng l·∫∑p while, gi√° tr·ªã c·∫ßn t√¨m c·ªßa ch√∫ng ta s·∫Ω l√† left - 1.\nNh∆∞ v·∫≠y, ƒë√°p √°n c·ªßa ch√∫ng ta nh∆∞ sau:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public int mySqrt(int x) { if (x \u0026lt; 2) return x; int left = 0; int right = x; while (left \u0026lt; right) { int mid = left + (right - left) / 2; if (x / mid \u0026lt; mid) { right = mid; } else { left = mid + 1; } } return left - 1; } √Åp d·ª•ng v√†o problem ph·ª©c t·∫°p Ch√∫ng ta c√πng t√¨m hi·ªÉu b√†i to√°n sau: Capacity To Ship Packages Within D Days\nM·ªôt bƒÉng chuy·ªÅn g·ªìm c√°c g√≥i h√†ng ph·∫£i giao t·ª´ c·ªïng n√†y t·ªõi c·ªïng kh√°c trong v√≤ng D ng√†y. G√≥i h√†ng th·ª© i c√≥ kh·ªëi l∆∞·ª£ng l√† weights[i]. M·ªói ng√†y, ch√∫ng ta ch·∫•t c√°c g√≥i h√†ng l√™n m·ªôt khay h√†ng tr√™n bƒÉng chuy·ªÅn theo th·ª© t·ª± l·∫ßn l∆∞·ª£t ƒë∆∞·ª£c cho b·ªüi m·∫£ng weights. Ch√∫ng ta kh√¥ng th·ªÉ ch·∫•t qu√° t·∫£i tr·ªçng c·ªßa khay h√†ng.\nT√¨m t·∫£i tr·ªçng nh·ªè nh·∫•t c√≥ th·ªÉ c·ªßa khay h√†ng ƒë·ªÉ ƒë·∫£m b·∫£o t·∫•t c·∫£ c√°c g√≥i h√†ng ƒë∆∞·ª£c giao trong v√≤ng D ng√†y.\nƒêi·ªÅu ki·ªán:\n$1 \u0026lt;= D \u0026lt;= weights.length \u0026lt;= 5 * 10^4$\n$1 \u0026lt;= weights[i] \u0026lt;= 500$\nTr∆∞·ªõc ti√™n, ch√∫ng ta c√πng ph√¢n t√≠ch m·ªôt ch√∫t. V·ªõi c√°c b√†i to√°n ƒë∆°n gi·∫£n nh∆∞ v√≠ d·ª• tr∆∞·ªõc th√¨ ƒë·ªçc xong ƒë·ªÅ l√† ch√∫ng ta bi·∫øt ngay c·∫ßn ph·∫£i gi·∫£i b·∫±ng Binary Search r·ªìi. Nh∆∞ng ƒë√¥i khi ch√∫ng ta g·∫∑p nh·ªØng b√†i to√°n ph·ª©c t·∫°p h∆°n m√† m√¨nh c√≤n kh√¥ng bi·∫øt l√† c·∫ßn ph·∫£i √°p d·ª•ng Binary Search ƒë·ªÉ gi·∫£i. Th·∫ø l√† ch√∫ng ta ƒëi √°p d·ª•ng c√°c ph∆∞∆°ng ph√°p kh√°c nh∆∞ DFS, BFS hay Quy ho·∫°ch ƒë·ªông ƒë·ªÉ gi·∫£i, nh∆∞ng c√†ng l√†m c√†ng th·∫•y b√≠. Nh∆∞ trong b√†i to√°n n√†y, √Ω nghƒ© tho√°ng qua trong ƒë·∫ßu m√¨nh l√∫c m·ªõi ƒë·ªçc xong ƒë·ªÅ b√†i l√† √°p d·ª•ng Quy ho·∫°ch ƒë·ªông.\nV·∫≠y d·∫•u hi·ªáu ƒë·ªÉ nh·∫≠n bi·∫øt m·ªôt b√†i to√°n c√≥ th·ªÉ gi·∫£i b·∫±ng Binary Search l√† khi:\nCh√∫ng ta nh·∫≠n th·∫•y ƒë√°p √°n c·ªßa b√†i to√°n c√≥ t√≠nh ƒë∆°n ƒëi·ªáu, nghƒ©a l√† khi condition(k) return true th√¨ condition(k + 1) c≈©ng s·∫Ω return true.\nQuay tr·ªü l·∫°i v·ªõi b√†i to√°n tr√™n, ch√∫ng ta th·∫•y r·∫±ng n·∫øu c√≥ th·ªÉ giao to√†n b·ªô c√°c g√≥i h√†ng trong D ng√†y v·ªõi khay h√†ng c√≥ t·∫£i tr·ªçng M, th√¨ khi ch√∫ng ta s·ª≠ d·ª•ng khay h√†ng c√≥ t·∫£i tr·ªçng l·ªõn h∆°n M (v√≠ d·ª• M + 1) th√¨ ho√†n to√†n v·∫´n c√≥ th·ªÉ giao trong t·ªëi ƒëa D ng√†y.\nV·ªõi h√†m condition, ch√∫ng ta s·∫Ω s·ª≠ d·ª•ng thu·∫≠t to√°n tham lam, tham s·ªë l√† t·∫£i tr·ªçng c·ªßa khay h√†ng ƒë∆∞·ª£c cho tr∆∞·ªõc. M·ªói ng√†y ch√∫ng ta ƒë·∫∑t l·∫ßn l∆∞·ª£t c√°c g√≥i h√†ng l√™n khay ƒë·∫øn khi h·∫øt t·∫£i tr·ªçng, t·ª´ ƒë√≥ t√≠nh ra t·ªïng s·ªë ng√†y c·∫ßn thi·∫øt ƒë·ªÉ giao to√†n b·ªô h√†ng, sau ƒë√≥ ch√∫ng ta so s√°nh n√≥ v·ªõi D, n·∫øu √≠t h∆°n ho·∫∑c b·∫±ng D ng√†y th√¨ return true, v∆∞·ª£t qu√° th√¨ return false.\nV·ªõi hai gi√° tr·ªã bi√™n, t·∫£i tr·ªçng t·ªëi thi·ªÉu c·ªßa khay h√†ng b·∫±ng v·ªõi kh·ªëi l∆∞·ª£ng c·ªßa g√≥i h√†ng l·ªõn nh·∫•t, ƒë·ªÉ ƒë·∫£m b·∫£o ch√∫ng ta c√≥ th·ªÉ giao to√†n b·ªô c√°c g√≥i h√†ng; c√≤n t·∫£i tr·ªçng t·ªëi ƒëa s·∫Ω b·∫±ng t·ªïng kh·ªëi l∆∞·ª£ng c·ªßa to√†n b·ªô h√†ng, khi ƒë√≥ ch√∫ng ta ch·ªâ m·∫•t 1 ng√†y ƒë·ªÉ giao h√†ng.\nV√† ƒë√°p √°n c·ªßa ch√∫ng ta l√†:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 public int shipWithinDays(int[] weights, int days) { int left = 0; int right = 0; for (int w : weights) { left = Math.max(left, w); right += w; } while (left \u0026lt; maxCap) { int mid = left + (right - left) / 2; if (isValidTime(weights, days, mid)) { right = mid; } else { left = mid + 1; } } return left; } private boolean isValidTime(int[] weights, int days, int capacity) { int totalDay = 1; int curCap = 0; for (int w : weights) { curCap += w; if (curCap \u0026gt; capacity) { totalDay++; curCap = w; } } return totalDay \u0026lt;= days; } K·∫øt lu·∫≠n Hy v·ªçng qua b√†i vi·∫øt n√†y, c√°c b·∫°n c√≥ th√™m t·ª± tin chinh chi·∫øn tr√™n ƒë·∫•u tr∆∞·ªùng LeetCode. K·ªÉ c·∫£ khi g·∫∑p c√°c b√†i kh√≥, ch·ªâ c·∫ßn b·∫°n nh·∫≠n ra r·∫±ng b√†i n√†y c√≥ th·ªÉ √°p d·ª•ng Binary Search, th√¨ c√≥ th·ªÉ copy paste template n√†y v√†o, sau ƒë√≥ l√† ƒë·ªÉ ƒë√¥i b√†n tay l∆∞·ªõt nh·∫π tr√™n b√†n ph√≠m. M·ªçi vi·ªác c√≤n l·∫°i th·∫≠t qu√° d·ªÖ d√†ng!\n","date":"2024-02-17T00:00:00+07:00","image":"https://namanh11611.github.io/p/binary-search/binary_search_hu_f9247f1f16c62e2b.webp","permalink":"https://namanh11611.github.io/p/binary-search/","title":"LeetCode: Binary Search template chinh ph·ª•c m·ªçi problem"},{"content":"What are Stack and Heap Memory? Memory management is an important factor in programming. Knowing how to optimize memory will help our applications run smoothly, without lag or crashes. The JVM (Java Virtual Machine) divides memory into two parts: Stack and Heap (do not confuse these with the Stack and Heap data structures). In this article, we will learn about the roles, functions, and how each type of memory works.\nStack Memory How it works Stack stores variables of primitive types (int, float, char, boolean\u0026hellip;), local variables, and information about called methods. It operates on a LIFO (Last In First Out) mechanism. This means that methods called last are allocated a frame in the Stack, containing information about parameters, local variables, and the Stack will release that frame when the method returns.\nFor example, with the following code:\n1 2 3 4 5 6 7 8 9 10 11 12 public static void main(String[] args) { doSomething(); } private static void doSomething() { long id = 123456789L; doSomethingElse(); } private static void doSomethingElse() { int age = 23; } The Stack will store information in the following structure:\nThe Stack is used to execute a thread, so the JVM will create a separate stack for each thread. By default, if we do not specify the Stack size, the JVM will create it with a size depending on the operating system and computer architecture (usually 1MB). However, we can use the -Xss flag to customize the Stack size (not exceeding the max size, usually 1GB).\n1 2 3 java -Xss1048576 // 1,048,576 bytes java -Xss1024k // 1,024 KB java -Xss1m // 1 MB StackOverflow A classic error related to the Stack is StackOverflow. It occurs when the amount of data stored in the Stack exceeds its limit.\nFor example, when we call recursion without a stopping condition:\n1 2 3 void callRecursion() { callRecursion(); } You can imagine methods continuously being loaded into the Stack, and at some point, it will exceed the small 1MB size. Therefore, the above code will throw a java.lang.StackOverflowError.\nSome ways to avoid StackOverflow error:\nEnsure recursive functions have a stopping condition or are not called too many times Manage threads carefully Avoid using large local variables Avoid circular dependencies Heap Memory How it works Heap stores variables of Object or array data types. It uses a mechanism of dynamic memory allocation and deallocation. Heap is quite flexible, able to expand or shrink as needed during program execution.\nFor example, when we use the new keyword to create a Student object:\n1 2 3 4 5 6 7 8 9 10 private static void doSomething() { long id = 123456789L; Student student = new Student(); doSomethingElse(); } private static void doSomethingElse() { int age = 23; String str = \u0026#34;Hello World\u0026#34;; } Memory will find a random empty region in the Heap to allocate and store the information of the student object. On the Stack side, there will be a reference variable pointing to the information of the student object in the Heap. For Strings, Heap has a special data structure called the String pool to store them.\nHeap is created when the JVM starts and is used as long as the application is running. Unlike Stack, Heap is shared among all threads.\nBy default, the initial size of the Heap is 256MB and the maximum size is 4068MB. We can also change these parameters using the -Xms (initial size) and -Xmx (maximum size) flags.\n1 2 // Initial heap size = 512MB, Maximum heap size = 1024MB java -Xms512m -Xmx1024m Garbage Collection In Java, Garbage Collection is responsible for reclaiming memory from variables in the Heap that are no longer referenced. This process is performed automatically. In the example above, when we no longer use the student object, Garbage Collection will automatically reclaim the memory previously allocated for it.\nThanks to this mechanism, Heap allows allocation and deallocation of memory for variables with large sizes and complex structures at runtime. If we create too many variables in the Heap but poor code prevents Garbage Collection from reclaiming memory efficiently, it will cause a memory leak.\nGarbage Collection works like a manager in a restaurant. When customers arrive, staff will invite them to an empty table, bring out bowls, chopsticks, and menus (allocate memory). The manager will regularly walk around to check, and if they see a table where customers have finished and left, they will call staff to clean up and prepare for new customers (free memory).\nOutOfMemory When the Heap is full and we cannot allocate memory for a new object, it will throw a java.lang.OutOfMemoryError.\nOur solution is to analyze the code, use profiling tools to detect where memory leaks occur, remove references to objects when they are no longer needed, and let Garbage Collection do its job. Some ways to optimize memory:\nAvoid creating unnecessary objects Reuse objects if possible Choose appropriate data structures Prefer using local variables over global variables Comparison Stack Memory Heap Memory Storage primitive, local variables, method Object, array Access speed Fast Slow Size Small, Fixed Large, Dynamic Usage scope Thread corresponding to Stack All threads Allocation order LIFO Random Variable lifetime From method call to return From creation to Garbage Collection Conclusion In this article, there are still many concepts related to memory that I have not been able to convey. I hope you have a basic understanding of how Stack and Heap memory work, so you can gain more experience in optimizing your application\u0026rsquo;s performance.\n","date":"2024-01-04T00:00:00+07:00","image":"https://namanh11611.github.io/p/stack-heap/stack-heap_hu_5548e955fb394fb0.webp","permalink":"https://namanh11611.github.io/p/stack-heap/","title":"Stack and Heap Memory in Java"},{"content":"What is Pomodoro? Recently, my work has shifted a bit, and I find myself in an average of 4 meetings every day. Consequently, I often end up accomplishing very little throughout the day. So, I sought a time management method called Pomodoro to help me focus better on my tasks. It wasn\u0026rsquo;t until I applied it that I realized the actual coding time in a day is not as much as I thought.\nPomodoro is an Italian word, meaning tomato, because when Francesco Cirillo developed this method in the late 1980s, he used a tomato-shaped kitchen timer. In brief, this method consists of several steps:\nSet the tasks to be done. Set a timer for 25 minutes (this time is called a pomodoro). Work on the task. Finish the task and take a 5-minute break. After 4 pomodoros, take a 15-minute break. To apply Pomodoro, there are many apps, extensions, or even web applications available for you to use. You can find the one that suits you best. Personally, I am using the Focus To-Do app on the App Store, which is quite sufficient for my basic needs.\nNow, after applying it for 6 th√°ng, I want to share with you the benefits it brings, as well as the points I think it may not be suitable.\nImproving Focus Previously, there were days when I was extremely focused for 4-5 consecutive hours, which helped me accomplish a lot of tasks. However, after such days, I often felt quite tired.\nBut there were also days when I spent the whole hour reading news, scrolling through Facebook, and suddenly realized I hadn\u0026rsquo;t accomplished anything.\nThe human brain is truly effective when concentrated for a short period with reasonable breaks. Applying Pomodoro, knowing I only need to focus for 25 minutes, a not too long duration, allows me to fully concentrate on the task without worrying about getting tired at the end of the day. I also know that after these 25 minutes, I will have a break, so there\u0026rsquo;s no temptation to turn to Facebook during work.\nDuring one pomodoro, you should only focus on one task. For example, if you are working on task A, only work on task A. If you finish it before the pomodoro ends, spend the remaining time checking it again, but don\u0026rsquo;t jump to task B.\nImproving Health When it\u0026rsquo;s time for a 5-minute break, instead of continuing to stare at the computer, I usually take the time to go to the restroom, get more water, change my playlist, or simply stand up and move around. This helps relax my body, avoiding health issues from sitting for too long.\nHowever, I find the 5-minute duration a bit short; sometimes, I haven\u0026rsquo;t done anything, and it\u0026rsquo;s already over in 5 minutes. Therefore, in the future, I may consider adjusting it to 7 or 8 minutes and see how it goes.\nIgnoring the World According to the rule, during the 25-minute focused period, you should turn off all app notifications to avoid distraction. However, I haven\u0026rsquo;t reached the point of being able to ignore the whole world because I still need to receive chat notifications to respond to customers and colleagues promptly.\nHowever, this often disrupts my Pomodoro because I have to spend additional time checking code or documents to be able to respond to people.\nConclusion This method may be suitable for me but may not necessarily be suitable for you. Adhering to Pomodoro has helped me increase work efficiency, but sometimes it makes me feel like I\u0026rsquo;m working like a machine. Try applying it and see the results it brings for you.\n","date":"2023-12-23T00:00:00+07:00","image":"https://namanh11611.github.io/p/pomodoro/pomodoro_hu_a621620d9220d6da.webp","permalink":"https://namanh11611.github.io/p/pomodoro/","title":"6-Month Journey Applying the Pomodoro Technique"},{"content":"Besides learning through tutorials and videos, technical blogs are a great resource. By reading blogs from software engineers at major companies, you can see how they solve the problems they\u0026rsquo;ve encountered. In the age of AI, with tools like Copilot or Tabnine ready to generate code to support you, engineers are no longer distinguished by their ability to remember the syntax of a language or framework, but by their problem-solving skills. So, in this article, I will introduce you to the blogs of major companies, hoping you will gain some interesting perspectives.\nYou can click on the title of each section to go to the blog.\nMeta Meta (formerly known as Facebook) has many products like Facebook, Instagram, Whatsapp\u0026hellip; On this blog, they share about everything from Android, iOS, Web to more challenging topics like VR/AR or AI.\nGoogle On this homepage, you can choose one of four areas you are interested in: Mobile, Web, AI, or Cloud. Google will then introduce you to detailed articles in that field.\nGoogle also creates many courses about their technologies. Each course includes videos, detailed explanatory articles, and example exercises for you to follow. When you finish, you can earn a small badge. Quite fun!\nNetflix In recent years, Netflix has become a household name as a platform for movies and TV shows. Instead of just Netflix and chill, try reading their blog to see how they build a system that serves millions of users.\nDropbox Similar to Google Drive, Dropbox is a cloud storage service that helps you store files online and sync them across devices.\nThrough their blog, you can learn how to optimize memory and bandwidth when sharing files.\nTwitter \u0026ldquo;Design a system like Twitter\u0026rdquo; is a classic question in System Design interviews. So, Twitter\u0026rsquo;s blog is a useful reference when preparing for interviews. You can see if your ideas match how Twitter actually does things.\nRecently, after being acquired by Elon Musk, Twitter even open-sourced their Recommendation Algorithm.\nUber Although Uber has left the Vietnamese market after merging with Grab, it is still the largest taxi company in the world. Therefore, their blog is very suitable for those working in companies with similar business areas in Vietnam.\nSpotify I remember when Spotify first launched in Vietnam, everyone was amazed by its recommendation capabilities.\nSpotify\u0026rsquo;s recommender system is a complex system, combining many algorithms and Machine Learning models. Through this blog, hopefully you will discover part of that system.\nLINE LINE is one of my former companies. Although it may not be as top-tier as the others above, the sharing culture is very strong. So, through this article, I want to introduce you to the technical blog of engineers at LINE.\n","date":"2023-05-24T00:42:00+07:00","image":"https://namanh11611.github.io/p/technical-blog/blog_hu_5249ace72b7d41a3.webp","permalink":"https://namanh11611.github.io/p/technical-blog/","title":"Technical Blogs of Engineers at Major Companies"},{"content":"Who am I? Hello everyone!\nI\u0026rsquo;m Nam Anh, an Android developer with 5 years of experience. During those 5 years, I\u0026rsquo;ve wandered through quite a few tech companies in Hanoi.\nThis is probably the first time I\u0026rsquo;ve written an article from such a personal perspective. So you might wonder: \u0026ldquo;Who is this guy to be giving life advice?\u0026rdquo;\nOops, I\u0026rsquo;m not here to lecture anyone, just to share things that I found true for myself. Maybe for you, they\u0026rsquo;re right or wrong. But who knows, maybe some Juniors will gain a new perspective to improve their career path.\nThe Lucky Things There are things that, when they happened, I didn\u0026rsquo;t realize were right until I looked back later and thought: \u0026ldquo;Oh, turns out I did the right thing back then.\u0026rdquo; And I feel those were real strokes of luck for me.\nReading Clean Code right after graduation I have to admit, I used to love reading books and read quite a lot, all kinds of genres. But I read very few tech books, probably because my English was limited üò¢üò¢\nBut the tech book I value the most is Clean Code. As the name suggests, it teaches you how to write \u0026ldquo;clean code\u0026rdquo;, a fundamental book highly recommended by many. I don\u0026rsquo;t know who convinced me to read it right after graduation, but I read it and took notes summarizing the book. I still keep those notes to this day. Learning from the book, plus a bit of OCD, I think I\u0026rsquo;ve applied quite a bit of it to the projects I\u0026rsquo;ve worked on.\nSome people advise reading Clean Code once when you just graduate, and again after a few years of working, so you can really absorb its content. So I highly, highly recommend everyone read it, whether you\u0026rsquo;re a junior or a seasoned senior.\nWorking at product companies with strict processes There are already many articles comparing product and outsourcing companies, so I won\u0026rsquo;t repeat that. I\u0026rsquo;ve worked at both types. In this article, I just want to mention code review processes and product mindset.\nFrom my experience, big product companies have more time for thorough code reviews, not as rushed by deadlines as outsourcing companies. I\u0026rsquo;m only talking about big product companies, because I\u0026rsquo;ve also worked at small startups where the only goal was to get the code running, clean or dirty didn\u0026rsquo;t matter.\nThe knowledge I learned from Clean Code was just theory until I joined big product companies and had seniors carefully review my code. That\u0026rsquo;s when I really matured in every line I wrote.\nAnother thing I learned is the product mindset‚Äîalways thinking about the product, wanting it to be better and have more users. When I had an idea for a feature, I was ready to propose it to the leader or Product Manager. The feeling when you finish a feature and see users leaving positive comments on the App Store or Play Store is amazing üòçüòç\nDaring to step out of my comfort zone In 5 years, I\u0026rsquo;ve switched jobs many times like many others. I don\u0026rsquo;t know about you, but I fear staying at one company too long, getting too comfortable, and then struggling to catch up with the market\u0026rsquo;s demands when I want to switch.\nSo moving through many companies helped me adapt to different projects, understand what the market needs, and of course, get a better income.\nThings I Wish I Knew Sooner Stay at a company long enough Contrary to what I said above, here I want to advise young people to stay at a company long enough. In my opinion, at least 1-2 years. It gives you enough time to understand the project and be properly recognized.\nUsually, when you join a project, it takes a few months to understand it. For complex projects, it can take years. Understanding here means not just the technologies used in the source code, but also the business domain, how your app makes money, or even its competitive advantage over others. Some seniors, even when switching companies, only work in banking or fintech, for example. So besides technical skills, they\u0026rsquo;re valued for their business domain knowledge.\nCompanies often give out Best Employee awards at Year End Parties, but to be recognized, you have to stay long enough to make an impact. It\u0026rsquo;s rare for a company to give such an award to someone who just finished their probation, unless you\u0026rsquo;re a superstar. Achieving these things proves your ability and makes your profile shine.\nThere were times I only stayed at a company for a few months before leaving, and I felt that was a bit of a waste.\nTake English seriously, sooner Everyone knows how important English is for a developer\u0026rsquo;s career. If you can communicate well in English, you have more options: working for foreign companies in Vietnam, working remotely from home, or even going abroad. And a dev with good English communication skills will definitely earn more than one who can only read and understand.\nI graduated with a TOEIC 460‚Äîjust enough for basic reading. In recent years, I\u0026rsquo;ve started learning English seriously, and now I can communicate well with foreign colleagues. This has brought me many new opportunities.\nI swear this post isn\u0026rsquo;t an ad for the Elsa app, but it\u0026rsquo;s really good so I\u0026rsquo;m recommending it. Here\u0026rsquo;s my 88-day learning streak (I missed a day before and lost my streak ü•≤).\nMy English still isn\u0026rsquo;t great, so I\u0026rsquo;m learning every day. I\u0026rsquo;ve tried several apps‚ÄîDuolingo, Memrise, Cake\u0026hellip; and now I use Elsa along with others. But Elsa has helped me improve the most.\nThe difference comes after 8pm There are two devs, A and B, working at the same company from 8am to 6pm. So what makes the difference between them?\nIt comes after 8pm. Dev A spends that time learning new technologies, working on pet projects, or contributing to open source projects. Dev B spends it playing games or drinking. Maybe in the first few years, the difference isn\u0026rsquo;t clear, but after 3 or 5 years, the gap in knowledge and skills will be huge.\nWork at the company is sometimes easy, so you can only learn harder things or new technologies in your free time. For example, if your job is just UI work, you won\u0026rsquo;t need to understand systems or memory deeply. If you don\u0026rsquo;t spend time learning, how can you stand out from your colleagues?\nIn my early years, I also spent a lot of time drinking. I can\u0026rsquo;t deny the importance of building relationships through those gatherings. But if I could choose again, I\u0026rsquo;d spend more time at home learning.\nFinal Words On my journey, there were times I made the right decisions, but also plenty of times I chose wrong. But the important thing is I don\u0026rsquo;t regret or dwell on the past‚ÄîI keep learning and moving forward. I think that\u0026rsquo;s enough.\nThank you for taking the time to read my article!\n","date":"2023-05-18T18:44:00+07:00","image":"https://namanh11611.github.io/p/junior/junior_hu_dddd93cb9e5d0f9a.webp","permalink":"https://namanh11611.github.io/p/junior/","title":"Things I Wish I Knew When I Was a Junior"},{"content":"Concept First, we need to understand the purpose of DataStore.\nCurrently, in Android apps, there are 5 ways to store data, with SharedPreferences being the simplest for storing data. It only consists of key and value, where the value can be an integer, string, etc.\nWhen the app is opened for the first time, it reads all values from the SharedPreferences XML file and loads them into RAM. This file reading process happens on the UI Thread. If there are too many values and the task takes more than 5 seconds, it will cause an ANR (Application Not Responding) error.\nAnd DataStore was created to replace SharedPreferences.\nDataStore is a solution for storing data as key-value pairs or typed objects with protocol buffers.\nOf course, DataStore is still only for storing simple structured data. It uses Coroutines and Flow to store data asynchronously and consistently.\nDataStore has 2 types: Preferences DataStore and Proto DataStore. Let\u0026rsquo;s look at the comparison table:\nPreferences DataStore Proto DataStore Store and access data by key Store instances of a custom data type No need to define data type in advance Must define data type in advance with protocol buffers No type safety Has type safety Preferences DataStore Create To use Preferences DataStore, we need to create an instance of DataStore\u0026lt;Preferences\u0026gt; using a property delegate with the preferencesDataStore keyword.\n1 2 3 // At the top level of your kotlin file val Context.dataStore: DataStore\u0026lt;Preferences\u0026gt; by preferencesDataStore(name = \u0026#34;settings\u0026#34;) Read First, there are 7 functions corresponding to 7 data types:\nintPreferencesKey() longPreferencesKey() doublePreferencesKey() floatPreferencesKey() booleanPreferencesKey() stringPreferencesKey() stringSetPreferencesKey() When reading data, use the function corresponding to the value you want to store. For example, to store a counter variable as an integer to count how many times the user opens the app:\n1 2 3 4 5 6 val OPEN_APP_COUNTER = intPreferencesKey(\u0026#34;open_app_counter\u0026#34;) val openAppCounterFlow: Flow\u0026lt;Int\u0026gt; = context.dataStore.data .map { preferences -\u0026gt; // No type safety. preferences[OPEN_APP_COUNTER] ?: 0 } The difference from SharedPreferences is that here, data is returned as a Flow. Now, upper layers like Repository can observe data consistently, regardless of whether it comes from DataStore, Room database, or Server, because everything is returned as a Flow.\nWrite To write data, use the edit function, which is quite similar to SharedPreferences.\n1 2 3 4 context.dataStore.edit { settings -\u0026gt; val openAppCounterValue = settings[OPEN_APP_COUNTER] ?: 0 settings[OPEN_APP_COUNTER] = openAppCounterValue + 1 } Proto DataStore Before learning about Proto DataStore, let\u0026rsquo;s take a look at protocol buffers.\nProtocol buffers This is a data format that is independent of programming language or platform. It\u0026rsquo;s like JSON but much smaller and faster. Protocol buffers are also said to be the most widely used data format at Google.\nUsed to store compact data Fast parsing Supports many programming languages like C++, C#, Dart, Go, Java, Kotlin, Python Optimizes functionality through auto-generated classes For example, a message about user info with name, id, and email:\n1 2 3 4 5 message UserProfile { optional string name = 1; optional int32 id = 2; optional string email = 3; } To compare the performance of Protocol buffers and JSON, let\u0026rsquo;s make 500 GET requests from one Spring Boot app to another, with and without data compression. Here are the results:\nWe can see Protocol buffer is 5 to 6 times faster than JSON.\nCreate To use Proto DataStore, you must define the data type with a proto file settings.pb in the folder app/src/main/proto/ like this:\n1 2 3 4 5 6 syntax = \u0026#34;proto3\u0026#34;; option java_package = \u0026#34;com.example.application\u0026#34;; option java_multiple_files = true; message Settings { int32 open_app_counter = 1; } Next, declare an object implementing the Serializer\u0026lt;T\u0026gt; class, where T is the data type defined in the proto file.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 object SettingsSerializer : Serializer\u0026lt;Settings\u0026gt; { override val defaultValue: Settings = Settings.getDefaultInstance() override suspend fun readFrom(input: InputStream): Settings { try { return Settings.parseFrom(input) } catch (exception: InvalidProtocolBufferException) { throw CorruptionException(\u0026#34;Cannot read proto.\u0026#34;, exception) } } override suspend fun writeTo( t: Settings, output: OutputStream ) = t.writeTo(output) } Finally, use the property delegate with the dataStore keyword to create an instance of DataStore\u0026lt;T\u0026gt;.\n1 2 3 4 val Context.settingsDataStore: DataStore\u0026lt;Settings\u0026gt; by dataStore( fileName = \u0026#34;settings.pb\u0026#34;, serializer = SettingsSerializer ) Read Similar to Preferences DataStore, use DataStore.data to return a Flow.\n1 2 3 4 5 val openAppCounterFlow: Flow\u0026lt;Int\u0026gt; = context.settingDataStore.data .map { settings -\u0026gt; // The openAppCounter is generated from the proto schema. settings.openAppCounter } Write To write data to Proto DataStore, use the updateData() function.\n1 2 3 4 5 context.settingsDataStore.updateData { currentSettings -\u0026gt; currentSettings.toBuilder() .setExampleCounter(currentSettings.exampleCounter + 1) .build() } Comparison with SharedPreferences Migrate from SharedPreferences to Preferences DataStore To migrate, pass SharedPreferencesMigration to the produceMigrations parameter. DataStore will automatically migrate for you.\n1 2 3 4 5 6 7 8 9 val Context.dataStore: DataStore\u0026lt;Preferences\u0026gt; by preferencesDataStore( name = DATA_STORE_NAME produceMigrations = { context -\u0026gt; listOf(SharedPreferencesMigration( context, SHARED_PREFERENCES_NAME )) } ) Migrate from SharedPreferences to Proto DataStore First, declare UserProfile and UserProfileSerializer as above. Then write a mapping function to migrate from key-value pairs in SharedPreferences to the data type in Proto DataStore.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 val Context.dataStore: DataStore\u0026lt;UserProfile\u0026gt; by dataStore( fileName = \u0026#34;settings.pb\u0026#34;, serializer = UserProfileSerializer, produceMigrations = { context -\u0026gt; listOf( SharedPreferencesMigration( context, \u0026#34;settings_pref\u0026#34; ) { prefs: SharedPreferencesView, user: UserProfile -\u0026gt; user.toBuilder() .setName(prefs.getString(NAME_KEY)) .setId(prefs.getInt(ID_KEY)) .setEmail(prefs.getString(EMAIL_KEY)) .build() } ) } ) References https://developer.android.com/topic/libraries/architecture/datastore https://protobuf.dev/programming-guides/proto3 https://android-developers.googleblog.com/2020/09/prefer-storing-data-with-jetpack.html https://stackoverflow.com/questions/9986734/which-android-data-storage-technique-to-use https://auth0.com/blog/beating-json-performance-with-protobuf https://proandroiddev.com/is-jetpack-datastore-a-replacement-for-sharedpreferences-efe92d02fcb3 https://kinya.hashnode.dev/migrating-sharedpreferences-to-datastore-ckxzlvda101by8rs1c8bg4wdx https://amitshekhar.me/blog/jetpack-datastore-preferences ","date":"2023-05-14T15:41:00+07:00","image":"https://namanh11611.github.io/p/data-store/datastore_hu_3c09c999dfe956d7.webp","permalink":"https://namanh11611.github.io/p/data-store/","title":"DataStore - The Perfect Piece for the Kotlin Coroutines Puzzle"},{"content":"Concept I didn\u0026rsquo;t know about the Delegation Pattern until I learned Kotlin and saw people using the by keyword when declaring a variable. So I tried to learn more and discovered a whole new world of this pattern.\n~~ A bit dramatic, isn\u0026rsquo;t it? üòÖüòÖ ~~\nTo make it easy to understand, Delegation means assigning tasks to someone else. But let\u0026rsquo;s just use the terms \u0026ldquo;delegation\u0026rdquo; and \u0026ldquo;delegate\u0026rdquo; to keep things clear and professional, especially in work or interviews.\nThe Delegation Pattern is an object-oriented design pattern that allows object composition to achieve the same code reuse as inheritance.\nIn short: Delegation Pattern allows objects to reuse code similarly to inheritance.\nIn delegation, there are two components:\nReceiving object Delegate object When a request needs to be handled, the receiving object doesn\u0026rsquo;t handle it directly but delegates the task to the delegate object. It\u0026rsquo;s like having an older brother or sister who\u0026rsquo;s really good at math, and every time the teacher gives you homework, you ask them to do it for you.\nSo how is this different from Inheritance? In inheritance, you can also call methods from the parent class, right?\nThat\u0026rsquo;s true, but inheritance should only be used when the child class is truly related to the parent class. For example, a Cat class can inherit from Animal, but shouldn\u0026rsquo;t inherit from Transportation. Also, the child class must override all abstract methods of the parent, which is sometimes unnecessary. Delegation gives us more flexibility.\nExample Illustration Back to the earlier example, suppose you have a brother who\u0026rsquo;s an engineer and a sister who\u0026rsquo;s a doctor. They\u0026rsquo;re both very talented.\n1 2 3 4 5 6 7 8 9 10 11 interface TalentPerson { fun doHomework() } class Engineer : TalentPerson { override fun doHomework() {} } class Doctor : TalentPerson { override fun doHomework() {} } You\u0026rsquo;re a bit of a lazy student, so you need a helper class, with a parameter being a kind person who\u0026rsquo;s always ready to help you out.\n1 2 3 4 5 class LazyStudentHelper(private val kindPerson: TalentPerson) { fun doHomeworkByMyself() { kindPerson.doHomework() } } Now, every time the teacher gives homework, you can ask your brother or sister to do it for you.\n1 2 3 4 5 6 7 8 9 fun main() { val brother = Engineer() val lazyBoy = LazyStudentHelper(brother) lazyBoy.doHomeworkByMyself() val sister = Doctor() val lazyGirl = LazyStudentHelper(sister) lazyGirl.doHomeworkByMyself() } Delegation Pattern in Kotlin The by Keyword in Kotlin Kotlin supports the Delegation Pattern through the by keyword, which helps reduce boilerplate code.\n1 2 3 4 5 6 7 8 9 10 11 12 13 class LazyStudentHelper( private val kindPerson: TalentPerson ): TalentPerson by kindPerson fun main() { val brother = Engineer() val lazyBoy = LazyStudentHelper(brother) lazyBoy.doHomework() val sister = Doctor() val lazyGirl = LazyStudentHelper(sister) lazyGirl.doHomework() } Now, the LazyStudentHelper class must implement the TalentPerson interface, so it can delegate the doHomework method to the kindPerson instance.\nDelegated Properties There are several ways to use Delegation when declaring variables in Kotlin:\nLazy properties: the value is computed the first time it is accessed. Observable properties: listeners are notified when the property changes. Lazy properties lazy is a function that takes a lambda and returns an instance of the Lazy\u0026lt;T\u0026gt; class.\n1 2 3 4 5 6 7 8 9 val lazyValue: String by lazy { println(\u0026#34;computed!\u0026#34;) \u0026#34;Hello\u0026#34; } fun main() { println(lazyValue) println(lazyValue) } The first time lazyValue is called, the result is computed and stored. Subsequent calls just return the stored value. So the output will be:\n1 2 3 computed! Hello Hello Observable properties 1 2 3 4 5 6 7 8 9 10 11 12 13 import kotlin.properties.Delegates class User { var name: String by Delegates.observable(\u0026#34;\u0026lt;no name\u0026gt;\u0026#34;) { prop, old, new -\u0026gt; println(\u0026#34;$old -\u0026gt; $new\u0026#34;) } } fun main() { val user = User() user.name = \u0026#34;first\u0026#34; user.name = \u0026#34;second\u0026#34; } Delegates.observable() takes two arguments:\nThe initial value A function to handle changes to the name variable. It\u0026rsquo;s called every time you assign a value to the variable. The result will be:\n1 2 \u0026lt;no name\u0026gt; -\u0026gt; first first -\u0026gt; second Reference https://en.wikipedia.org/wiki/Delegation_pattern https://kotlinlang.org/docs/delegation.html https://kotlinlang.org/docs/delegated-properties.html ","date":"2023-05-12T16:50:00+07:00","image":"https://namanh11611.github.io/p/design-pattern-delegation/delegation_hu_97e770c57ee2e4c1.webp","permalink":"https://namanh11611.github.io/p/design-pattern-delegation/","title":"Design Pattern: Delegation in Kotlin - how to get someone else to do your homework"},{"content":"Ho√†n c·∫£nh H√¥m v·ª´a r·ªìi m·ªôt ng∆∞·ªùi em b√™n Nh·∫≠t chia s·∫ª v·ªõi m√¨nh r·∫±ng mu·ªën m·ªü c√¥ng ty ·ªü Vi·ªát Nam, nh∆∞ng ch∆∞a hi·ªÉu v·ªÅ th·ªã tr∆∞·ªùng hi·ªán t·∫°i ·ªü Vi·ªát Nam l·∫Øm. M√¨nh ƒë√†nh d·ªëc h·∫øt nh·ªØng ki·∫øn th·ª©c n√¥ng c·∫°n c·ªßa m√¨nh ra chia s·∫ª v·ªõi em v·ªÅ m√¥i tr∆∞·ªùng, c√¥ng vi·ªác c≈©ng nh∆∞ l∆∞∆°ng th∆∞·ªüng c·ªßa anh em dev ·ªü H√† N·ªôi, th√†nh ph·ªë H·ªì Ch√≠ Minh v√† ƒê√† N·∫µng\u0026hellip;\nD·∫´u bi·∫øt r·∫±ng th·ªã tr∆∞·ªùng ƒëang ·∫£m ƒë·∫°m, l√†n s√≥ng sa th·∫£i c≈©ng ƒë√£ lan ƒë·∫øn Vi·ªát Nam t·ª´ cu·ªëi nƒÉm 2022 ƒë·∫øn th·ªùi ƒëi·ªÉm hi·ªán t·∫°i l√† th√°ng 5/2023, nh∆∞ng th·∫≠t s·ª± ch∆∞a c√≥ m·ªôt b√°o c√°o ƒë√°ng tin c·∫≠y ƒë·ªÉ ƒë√°nh gi√° v·ªÅ t√¨nh h√¨nh nƒÉm 2023 n√†y. V·∫≠y n√™n m√¨nh s·∫Ω d·ª±a v√†o b√°o c√°o g·∫ßn nh·∫•t c·ªßa 2 b√™n TopDev v√† ITViec trong nƒÉm 2022 ƒë·ªÉ ƒë∆∞a ra g√≥c nh√¨n v·ªÅ m·ª©c l∆∞∆°ng th∆∞·ªüng c·ªßa anh em.\nTrong b√°o c√°o c·ªßa TopDev c√≥ ƒë∆∞a ra c·∫£ ƒë√°nh gi√° v·ªÅ t√¨nh h√¨nh tuy·ªÉn d·ª•ng, nh∆∞ng m√¨nh nghƒ© r·∫±ng gi√≥ ƒë√£ ƒë·ªïi chi·ªÅu n√™n nh·ªØng ƒë√°nh gi√° ƒë√≥ kh√¥ng c√≤n ch√≠nh x√°c trong nƒÉm 2023 n√†y. C√≤n v·ªÅ l∆∞∆°ng th∆∞·ªüng, kh√°c v·ªõi t√¨nh h√¨nh nƒÉm 2020 khi c√°c c√¥ng ty gi·∫£m l∆∞∆°ng nh√¢n vi√™n ƒë·ªÉ v∆∞·ª£t qua giai ƒëo·∫°n kh√≥ khƒÉn, trong nƒÉm 2023 n√†y, h·∫ßu h·∫øt c√°c c√¥ng ty ch·ªâ ƒë∆∞a ra l·ª±a ch·ªçn gi·ªØ ng∆∞·ªùi ho·∫∑c sa th·∫£i, v·∫≠y n√™n m·ª©c l∆∞∆°ng c·ªßa nh·ªØng ng∆∞·ªùi ·ªü l·∫°i s·∫Ω √≠t b·ªã ·∫£nh h∆∞·ªüng.\nITViec kh·∫£o s√°t 1.257 chuy√™n gia IT c√≤n TopDev th√¨ d·ª±a tr√™n 48.179 ·ª©ng vi√™n IT, 100.000 d·ªØ li·ªáu vi·ªác l√†m ƒë∆∞·ª£c ph√¢n t√≠ch v√† th√¥ng tin c·ªßa 2.500 nh√† tuy·ªÉn d·ª•ng. B·ªüi v√¨ kh·∫£o s√°t v·ªõi m·ªôt volumn nh·ªè th√¨ s·∫Ω c√≥ s·ª± sai l·ªách nh·∫•t ƒë·ªãnh so v·ªõi th·ªã tr∆∞·ªùng, v·∫≠y n√™n m√¨nh m·ªõi d√πng b√°o c√°o c·ªßa c·∫£ 2 b√™n ƒë·ªÉ mong r·∫±ng gi·∫£m t·ªëi ƒëa s·ª± sai l·ªách ƒë√≥ v√† gi√∫p ch√∫ng ta c√≥ m·ªôt g√≥c nh√¨n kh√°ch quan nh·∫•t.\nM·ª©c l∆∞∆°ng theo c√¥ng ngh·ªá Trong bi·ªÉu ƒë·ªì tr√™n, TopDev th·ªÉ hi·ªán m·ª©c l∆∞∆°ng c·ªßa c√°c dev t·ª´ 3 nƒÉm kinh nghi·ªám tr·ªü xu·ªëng. V·∫≠y n√™n m√¨nh th·∫•y n√≥ h∆°i th·∫•p v√† kh√¥ng ph·∫£n √°nh ƒë∆∞·ª£c m·ª©c l∆∞∆°ng c·ªßa senior dev c√≥ t·ª´ 4-5 nƒÉm kinh nghi·ªám tr·ªü l√™n.\nTop c√¥ng ngh·ªá ƒë∆∞·ª£c tr·∫£ l∆∞∆°ng cao nh·∫•t g·ªìm c√°c c√¥ng ngh·ªá theo xu h∆∞·ªõng nh∆∞ AI (Kubernetes, TensorFlows, Python), Cloud Computing (AWS, GCP, Azure). Unity c≈©ng l·ªçt top nh·ªù trend play-to-earn n·ªïi ƒë√¨nh n·ªïi ƒë√°m trong nƒÉm 2022.\nB·∫£ng s·ªë li·ªáu c·ªßa ITViec th·ªÉ hi·ªán chi ti·∫øt h∆°n m·ª©c l∆∞∆°ng cho t·ª´ng ng√¥n ng·ªØ l·∫≠p tr√¨nh theo s·ªë nƒÉm kinh nghi·ªám. Python v·∫´n l√† m·ªôt trong nh·ªØng ng√¥n ng·ªØ ƒë∆∞·ª£c tr·∫£ l∆∞∆°ng cao, nh∆∞ng Go - m·ªôt ng√¥n ng·ªØ ƒëang tr·ªü th√†nh trending - m·ªõi l√† v≈© kh√≠ gi√∫p anh em dev ƒë∆∞·ª£c tr·∫£ l∆∞∆°ng cao nh·∫•t.\nM·ª©c l∆∞∆°ng theo v·ªã tr√≠ Bi·ªÉu ƒë·ªì n√†y c·ªßa TopDev v·∫´n th·ªÉ hi·ªán m·ª©c l∆∞∆°ng c·ªßa c√°c dev t·ª´ 3 nƒÉm kinh nghi·ªám tr·ªü xu·ªëng.\nC√°c v·ªã tr√≠ CTO, CIO ho·∫∑c Tech Management v·ªën v·∫´n ƒë∆∞·ª£c coi l√† m·ª•c ti√™u ngh·ªÅ nghi·ªáp cao nh·∫•t, h·ªç ph·∫£i n·∫Øm c√°c k·ªπ nƒÉng c∆° b·∫£n v·ªØng ch·∫Øc, x·ª≠ l√Ω c√°c c√¥ng vi·ªác qu·∫£n l√Ω, t·ªëi ∆∞u h√≥a c√¥ng ngh·ªá / s·∫£n ph·∫©m v√† ƒëi·ªÅu ch·ªânh k·ªãp th·ªùi.\nC√°c v·ªã tr√≠ ƒë∆∞·ª£c tr·∫£ l∆∞∆°ng cao ti·∫øp theo y√™u c·∫ßu c√°c k·ªπ nƒÉng ƒë·∫∑c bi·ªát nh∆∞ Data, Cloud, DevOps ho·∫∑c AI.\nTrong b·∫£ng s·ªë li·ªáu c·ªßa ITViec, c√°c v·ªã tr√≠ tr√™n v·∫´n ƒë∆∞·ª£c tr·∫£ m·ª©c l∆∞∆°ng r·∫•t t·ªët. Nh∆∞ng ƒë·ªëi v·ªõi c√°c dev t·ª´ 5 nƒÉm kinh nghi·ªám tr·ªü l√™n trong lƒ©nh v·ª±c kh√°c (Front-end, Mobile), h·ªç c≈©ng ƒë∆∞·ª£c tr·∫£ m·ª©c l∆∞∆°ng kh√¥ng h·ªÅ k√©m c·∫°nh.\nƒêi·ªÅu n√†y ch·ª©ng minh r·∫±ng b·∫°n kh√¥ng c·∫ßn ph·∫£i lu√¥n ch·∫°y theo nh·ªØng c√¥ng ngh·ªá hot, ch·ªâ c·∫ßn b·∫°n ƒë·ªß gi·ªèi, th√¨ v·ªõi v·ªã tr√≠ n√†o, b·∫°n c≈©ng ƒë∆∞·ª£c tr·∫£ m·ª©c l∆∞∆°ng t∆∞∆°ng x·ª©ng.\nM·ª©c l∆∞∆°ng theo tr√¨nh ƒë·ªô TopDev ch·ªâ ƒë∆∞a ra m·ªôt bi·ªÉu ƒë·ªì chung v·ªÅ m·ª©c l∆∞∆°ng theo s·ªë nƒÉm kinh nghi·ªám. Trong 5 nƒÉm ƒë·∫ßu ti√™n, l∆∞∆°ng c·ªßa l·∫≠p tr√¨nh vi√™n dao ƒë·ªông t·ª´ $350 (Fresher) ƒë·∫øn d∆∞·ªõi $1.190 cho Mid-Senior. ƒê·ªëi v·ªõi c√°c l·∫≠p tr√¨nh vi√™n t·ª´ 5 nƒÉm kinh nghi·ªám, m·ª©c l∆∞∆°ng ch√™nh l·ªách ch·ªß y·∫øu d·ª±a tr√™n v·ªã tr√≠ v√† tr√°ch nhi·ªám ƒë·ªëi v·ªõi ho·∫°t ƒë·ªông kinh doanh. Gi√°m ƒë·ªëc ho·∫∑c c·∫•p cao h∆°n s·∫Ω c√≥ m·ª©c l∆∞∆°ng √≠t nh·∫•t l√† $2.300. M·ª©c l∆∞∆°ng c·ªßa c·∫•p qu·∫£n l√Ω k·ªπ thu·∫≠t s·∫Ω cao h∆°n so v·ªõi c·∫•p qu·∫£n l√Ω/gi√°m ƒë·ªëc theo ƒë·ªãnh h∆∞·ªõng kinh doanh.\nM·ª©c l∆∞∆°ng theo th√†nh ph·ªë C√≥ l·∫Ω nhi·ªÅu anh em c≈©ng ƒë√£ bi·∫øt tr∆∞·ªõc k·∫øt qu·∫£ v·ªÅ b·∫£ng s·ªë li·ªáu n√†y c·ªßa ITViec. Nh√¨n chung th√¨ m·ª©c l∆∞∆°ng ·ªü th√†nh ph·ªë H·ªì Ch√≠ Minh cao h∆°n H√† N·ªôi, v√† H√† N·ªôi th√¨ l·∫°i cao h∆°n ƒê√† N·∫µng.\nTheo m√¨nh c√≥ l·∫Ω v√¨ th√†nh ph·ªë H·ªì Ch√≠ Minh g·ªìm nhi·ªÅu c√¥ng ty product v√† outsource l√†m v·ªõi th·ªã tr∆∞·ªùng n√≥i ti·∫øng Anh h∆°n. C√≤n ·ªü H√† N·ªôi v·∫´n g·ªìm nhi·ªÅu c√°c c√¥ng ty l√†m cho th·ªã tr∆∞·ªùng Nh·∫≠t. Tuy nhi√™n trong giai ƒëo·∫°n g·∫ßn ƒë√¢y, ƒë√£ c√≥ nhi·ªÅu c√¥ng ty t·ª´ th√†nh ph·ªë H·ªì Ch√≠ Minh B·∫Øc ti·∫øn ra H√† N·ªôi, ƒëi·ªÅu ƒë√≥ c≈©ng ƒë√£ gi√∫p th·ªã tr∆∞·ªùng ·ªü H√† N·ªôi nh·ªôn nh·ªãp h∆°n r·∫•t nhi·ªÅu.\nL·ªùi k·∫øt C≈©ng ph·∫£i nh√¨n nh·∫≠n r·∫±ng, nh·ªØng anh em kh√¥ng may b·ªã sa th·∫£i trong giai ƒëo·∫°n n√†y s·∫Ω ph·∫£i t√¨m m·ªôt c√¥ng vi·ªác m·ªõi v√† c√≥ th·ªÉ ph·∫£i ch·∫•p nh·∫≠n m·ªôt m·ª©c l∆∞∆°ng th·∫•p h∆°n m·ª©c c≈©. ƒêi·ªÅu ƒë√≥ c≈©ng g√≥p ph·∫ßn l√†m cho m·ª©c l∆∞∆°ng c·ªßa th·ªã tr∆∞·ªùng hi·ªán t·∫°i th·∫•p h∆°n m·ª©c trong kh·∫£o s√°t.\nNh∆∞ng m√¨nh hy v·ªçng r·∫±ng d·ª±a v√†o b√°o c√°o n√†y, anh em c√≥ th√™m m·ªôt g√≥c nh√¨n kh√°c v·ªÅ th·ªã tr∆∞·ªùng, ƒë·ªÉ bi·∫øt c√°ch trau d·ªìi b·∫£n th√¢n, r√®n luy·ªán k·ªπ nƒÉng. V√† sau c∆°n m∆∞a tr·ªùi l·∫°i s√°ng, khi th·ªã tr∆∞·ªùng s√¥i ƒë·ªông tr·ªü l·∫°i, v·ªõi nh·ªØng k·ªπ nƒÉng ƒë√£ ƒë∆∞·ª£c n√¢ng c·∫•p, anh em s·∫Ω nh·∫≠n ƒë∆∞·ª£c m·ªôt m·ª©c l∆∞∆°ng x·ª©ng ƒë√°ng v·ªõi nƒÉng l·ª±c.\nReference https://topdev.vn/page/bao-cao-it-viet-nam https://itviec.com/blog/bao-cao-luong-it ","date":"2023-05-10T01:40:00+07:00","image":"https://namanh11611.github.io/p/salary/salary_hu_8be55e04a7d6056e.webp","permalink":"https://namanh11611.github.io/p/salary/","title":"T√¨nh h√¨nh l∆∞∆°ng th∆∞·ªüng c·ªßa anh em IT"},{"content":"Introduction When I first heard about Kotlin Multiplatform (hereafter KM), I thought, ‚ÄúWhat kind of technology only shares logic code? If you want to code fast, just use Flutter, the performance isn‚Äôt bad at all.‚Äù But then, life pushed me into a project using KM, and I was truly enlightened about its pros and cons. So, over a drink under the moon, let me share a few words with you.\nWhat is Kotlin Multiplatform? KM makes developing cross-platform projects as light as a feather. It helps reduce the time spent writing and maintaining code while keeping the advantages of native for each platform. Kotlin apps can run on Android, iOS, macOS, Windows, Linux, watchOS\u0026hellip;\nAlthough KM is still in Beta, it‚Äôs quite stable and has been adopted by companies like 9gag, Netflix, Philips, Baidu, VMWare, Quizlet, Memrise\u0026hellip;\nBack to the question: what advantages does KM have over other cross-platform frameworks?\nKM is really suitable for projects with complex logic code. We all know that the more code you write, the more bugs you create. The only way to avoid bugs is No Code. So instead of Android devs writing logic for Android and iOS devs writing logic for iOS, now you only need to write logic once in KM, which already cuts bugs in half.\nFor example, if a project needs 10 Android devs and 10 iOS devs, with KM you only need 5 Android devs, 5 iOS devs, and 5 KM devs (who can also be Android devs). That means the project reduces resources by 25%. Compared to Flutter, of course, you still need more resources, but in return you get native performance.\nUse Cases Android and iOS apps You can share business logic code between platforms to build a cross-platform mobile app. This is currently the main use case for KM. For example, you can write code from ViewModel to Data layer in KM, while the Android and iOS apps just build UI with Jetpack Compose and SwiftUI.\nFull-stack web app You might not know, but Kotlin can now be used to write front-end web apps. So you can build a full-stack web app with the server using Kotlin/JVM and the web client using Kotlin/JS. Therefore, you can use KM to reuse logic code for both server and client.\nMultiplatform libraries If Kotlin can build for Android, iOS, and web, why not write a library usable on all three? For projects that need both app and web, try using KM to write common code, publish it as a library, and import it as a dependency in your app or web project.\nCommon code for mobile and web apps You don‚Äôt even need to create a library; you can write code directly to share between Android, iOS, desktop, and web apps. This reduces the workload for mobile and front-end web devs, since you only write logic code once. It also reduces bugs and testing time.\nHow it works So how does KM share code across all platforms?\nCommon Kotlin is the code that includes core libraries and can run on all platforms. With KM libraries, you can reuse multiplatform logic in common and platform-specific code. Platform-specific code (Kotlin/JVM, Kotlin/JS, Kotlin/Native) includes extensions for Kotlin, platform-specific libraries, and tools. For each platform, you can leverage platform native code (JVM, JS, and Native). For example, to write a function to generate a UUID for both Android and iOS, you can declare a function with the expect keyword in the common module:\n1 2 // Common expect fun randomUUID(): String Then, for each platform, you implement the function with the actual keyword:\n1 2 3 4 // Android import java.util.* actual fun randomUUID() = UUID.randomUUID().toString() 1 2 3 4 // iOS import platform.Foundation.NSUUID actual fun randomUUID(): String = NSUUID().UUIDString() Under the Hood My project applies KM for Android and iOS apps. I wondered how Kotlin could integrate with iOS apps written in Swift.\nJetBrains‚Äô answer is that they use Kotlin/Native to compile Kotlin code to native binaries, so you can run Kotlin code without a virtual machine. It includes an LLVM-based backend for the Kotlin compiler and a native implementation of the Kotlin standard library.\nKotlin/Native is designed to compile for platforms that can‚Äôt run a virtual machine, like embedded devices or iOS.\nOn Android, Kotlin code is compiled to JVM bytecode using Kotlin/JVM.\nConclusion In the future, JetBrains isn‚Äôt stopping at Kotlin Multiplatform‚Äîthey‚Äôre planning to develop Compose Multiplatform, which means you‚Äôll be able to share UI as well as logic code, just like other cross-platform frameworks (Flutter, React Native). That‚Äôs a long journey ahead, so let‚Äôs sit down, have a big meal and a big drink, and see what the future holds.\nReference https://kotlinlang.org/docs/multiplatform.html https://kotlinlang.org/docs/multiplatform-mobile-faq.html#what-is-kotlin-native-and-how-does-it-relate-to-kotlin-multiplatform ","date":"2023-05-07T13:37:00+07:00","image":"https://namanh11611.github.io/p/kotlin-multiplatform/kotlin_hu_470f46f97ffec59c.webp","permalink":"https://namanh11611.github.io/p/kotlin-multiplatform/","title":"Kotlin Multiplatform ‚Äì A Challenger to Flutter, React Native?"},{"content":"Case study The first story At my previous company (let\u0026rsquo;s call it company A), the project source code was huge‚Äîjust cloning it was 40GB, and after compiling and building, it reached nearly 100GB. Every time someone coded a feature, they would usually checkout a new branch like feature_x. For small features, it was fine, but for big features that changed dozens or even hundreds of files, merging into the main branch was a nightmare because you had to resolve conflicts from other feature branches that had been merged earlier.\nThe second story At another company (company B), due to the nature of the project, it was split into 5 small teams, each with about 3 developers. Each team was responsible for a few features in a sprint. At the start of the sprint, the dev lead would create a branch for each team, and after the sprint, all 5 branches would be merged. The same problem occurred: merging code resulted in a lot of conflicts, and teams had to spend time retesting their features to ensure no bugs appeared after merging.\nSo what is Trunk Based Development? In short, Trunk Based Development (from now on, TBD) is a source-control branching model where all developers work on a single branch called the trunk (like the trunk of a tree), avoiding the creation of huge feature branches. The trunk branch must always be ready for release at any time. In projects, people usually name the trunk branch master or dev.\nTBD is divided into two smaller models, suitable for different team sizes. Let\u0026rsquo;s explore them.\nTBD for small teams In this model, the whole dev team pushes code directly to the trunk branch. However, this model carries a big risk for code quality, since code is pushed directly without review. To use this model, devs must have strong technical skills to ensure every line they push doesn\u0026rsquo;t introduce bugs for the team.\nPersonally, I think this model is only suitable for teams of 5 or fewer.\nTBD for large teams With TBD for a large team, feature branches are still created, but the difference is they only exist for a short time‚Äîjust a few commits before merging back to the trunk branch.\nFor example, when assigned to code the Onboarding feature, with the usual Git flow, you might:\nCreate a feature/onboarding branch Code the Welcome screen and commit Code the Register screen and commit Code the Login screen and commit After finishing, create a merge request and wait for review After review, merge feature/onboarding into dev With this process, a merge request can contain dozens of changed files, and reviewing that much code is a nightmare. Sometimes, when you create the merge request, there are conflicts with another feature that was merged into dev earlier, and you have to spend time resolving conflicts.\nFor reviewers, sometimes the only way out of the nightmare is to stop dreaming‚Äîmeaning the senior dev quickly leaves a short comment LGTM (Look good to me), and the junior dev easily merges code into dev. Or, even if the senior dev tries to review carefully, with so many changes, some bugs still slip through. In short, this process still risks letting bugs through.\nWith TBD, the process is adjusted a bit:\nCreate feature/welcome_screen branch Code the Welcome screen, commit, and create a merge request immediately While waiting for review, code the Register screen When the Welcome screen merge request is approved, checkout feature/register_screen and create a new merge request Do the same for the Login screen Now, each merge request only contains a few changed files, making it much easier for the senior dev to review.\nAnd even if the release branch has a bug and needs a hotfix, devs don\u0026rsquo;t merge directly into the release branch as in other models‚Äîeverything must be merged into the trunk branch.\nFeature flag You might wonder: doesn\u0026rsquo;t this mean the dev branch will be full of unfinished feature code? For example, the app will show the new Welcome screen UI, while Register and Login screens still have the old UI. So how can you ensure the trunk branch is always ready for release?\nThe key is the Feature flag. For each unfinished feature, you add a flag so that when it\u0026rsquo;s on, all the new feature code is active, and when it\u0026rsquo;s off, the app works as before. For example:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 if (ONBOARDING_FLAG == FLAG_ON) { displayNewWelcomeScreen() } else { displayOldWelcomeScreen() } if (ONBOARDING_FLAG == FLAG_ON) { displayNewRegisterScreen() } else { displayOldRegisterScreen() } if (ONBOARDING_FLAG == FLAG_ON) { displayNewLoginScreen() } else { displayOldLoginScreen() } Sometimes, if you want to revert a feature, just turn off its flag. Quick and easy, right?\nAdvantages Fewer conflicts, less code review time As mentioned above, TBD requires everyone to quickly merge their code into the trunk branch, which helps reduce conflicts and code review time.\nIn company B\u0026rsquo;s case study, after seeing the current model wasn\u0026rsquo;t effective, I suggested the dev lead try TBD. As expected, in each sprint, our team hardly had to spend time resolving conflicts anymore.\nCI/CD TBD is very useful for CI/CD. Now you only need to set up and run CI/CD on a single branch. Every commit is quickly checked for coding conventions and unit tests, making it easy for the team to spot and fix errors in time.\nA/B Testing With feature flags, it\u0026rsquo;s easy to turn features on and off, making it convenient for Product Managers to set up A/B Testing. This helps measure and accurately evaluate the effectiveness of new features.\nIn company A\u0026rsquo;s first case study, we actually applied feature flags to many important features for A/B testing.\nFast product delivery Since the code in the trunk branch is always ready for release, I think it\u0026rsquo;s quite suitable for startups. Whenever you want to release a new version, just checkout from the trunk branch, turn on the completed feature flags, turn off the unfinished ones, and build.\nDisadvantages Too much leftover code On the flip side, using feature flags and too many if-else statements can make your code more complex. Sometimes, unclear if-else logic can make it even harder for reviewers to understand.\nAnd when a feature is released, you have to go back and remove the old code flow, like the displayOldWelcomeScreen, displayOldRegisterScreen, and displayOldLoginScreen functions in the example above.\nNot suitable for teams with many juniors Constantly creating merge requests requires devs to be careful, ensuring every commit passes all coding convention checks and unit tests locally, and especially that there are no critical bugs. If a bug on the trunk branch prevents the app from opening, it blocks everyone else.\nIf using feature flags, devs also need to test both the old and new flows to ensure both work correctly.\nSo I think a team mostly made up of seniors is more suitable for this model.\nConclusion TBD is a workflow I\u0026rsquo;ve applied at several companies and found it quite effective for my team\u0026rsquo;s situation. You can consider the pros and cons and try it with your team.\nReference https://trunkbaseddevelopment.com/ ","date":"2023-05-03T02:07:00+07:00","image":"https://namanh11611.github.io/p/trunk-based-development/tbd_hu_66d149f05ee711c.webp","permalink":"https://namanh11611.github.io/p/trunk-based-development/","title":"Trunk Based Development ‚Äì a Git workflow to reduce the headache of resolving conflicts"},{"content":"What is a Dispatcher? Simply put, a Dispatcher decides which thread a Coroutine will run on. It could be the main thread, a background thread, or it could push the Coroutine into a thread pool.\nThere are 4 types of Dispatchers:\nDispatchers.Default Dispatchers.Main Dispatchers.IO Dispatchers.Unconfined Or you can create your own Dispatcher using newSingleThreadContext() or newFixedThreadPoolContext().\nCoroutine builder functions like launch and async have a CoroutinesContext parameter so you can pass in a Dispatcher, since all the above Dispatchers extend from CoroutinesContext.\n1 2 3 launch(Dispatchers.Default) { println(\u0026#34;I\u0026#39;m working in thread ${Thread.currentThread().name}\u0026#34;) } If you call launch or async without passing a CoroutinesContext, it will inherit the context of the CoroutineScope it was launched in.\n1 2 3 4 5 fun main() = runBlocking\u0026lt;Unit\u0026gt; { launch { println(\u0026#34;I\u0026#39;m working in thread ${Thread.currentThread().name}\u0026#34;) } } In this example, it inherits the context of runBlocking, so it runs on the main thread.\nNow, let\u0026rsquo;s look at each Dispatcher in detail.\nDispatchers.Default Dispatchers.Default is used by default by builder functions like launch and async if you don\u0026rsquo;t assign another Dispatcher. Default uses a shared background threads pool. So you can use Dispatchers.Default for CPU-intensive work. For example:\nHeavy tasks like matrix calculations Sorting, filtering, or searching a huge list in memory Bitmap operations in memory Parsing JSON in memory By default, the maximum number of threads used by Dispatchers.Default is equal to the number of CPU cores, but at least 2.\nDispatchers.Main You can guess from the name, right? Exactly, Dispatchers.Main runs on the main thread, suitable for UI-related tasks.\nUsually, Dispatchers.Main is a single thread.\nDispatchers.IO Again, the name says it all. Dispatchers.IO uses a shared pool of threads created as needed. It helps offload blocking IO tasks. So it\u0026rsquo;s suitable for disk and network operations. For example:\nCalling APIs Downloading files from a server Moving files between folders on disk Reading and writing files Querying databases Loading Shared Preferences The number of threads used by Dispatchers.IO is limited to 64 or the number of cores (whichever is greater).\nDispatchers.Unconfined I call Dispatchers.Unconfined the wild horse, because you never know which thread it will run on.\nInitially, when launched, the Coroutine runs on the thread that called it. But after being suspended and resumed, it may run on a different thread, depending on the suspend functions called. Dispatchers.Unconfined is suitable for work that doesn\u0026rsquo;t consume CPU and doesn\u0026rsquo;t update the UI. But the Kotlin documentation emphasizes:\nThe Unconfined dispatcher should not normally be used in code.\nnewSingleThreadContext This function creates a new thread for you to play with. But creating a new thread is resource-intensive, and you have to call close to release it when done. So in practice, I don\u0026rsquo;t recommend using this.\nThere\u0026rsquo;s also newFixedThreadPoolContext to create a thread pool with a fixed size.\nComparison with RxJava, RxAndroid You can see that Dispatchers are similar to Schedulers in RxJava.\nCoroutines RxJava/RxAndroid Dispatchers.Default Schedulers.computation() Dispatchers.Main AndroidSchedulers.mainThread() Dispatchers.IO Schedulers.io() Conclusion In summary, Dispatchers are an important concept in Coroutines, so you need to understand them well to choose the right Dispatcher for each function.\nReference https://kotlinlang.org/docs/coroutine-context-and-dispatchers.html https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-default.html https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-main.html https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-i-o.html https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-unconfined.html https://amitshekhar.me/blog/dispatchers-in-kotlin-coroutines ","date":"2023-05-01T00:22:00+07:00","image":"https://namanh11611.github.io/p/kotlin-coroutines-dispatchers/dispatchers_hu_99ce5eb3827534c9.webp","permalink":"https://namanh11611.github.io/p/kotlin-coroutines-dispatchers/","title":"Dispatchers in Kotlin Coroutines"},{"content":"Searching for a Satisfying Bottom Navigation Bar Recently, while working on a project at my company, I got to explore Flutter. It\u0026rsquo;s truly a framework that helps build cross-platform mobile apps very quickly. According to some benchmarks, Flutter even has performance close to native (Kotlin and Swift), and of course, it outperforms React Native.\nIn this project, I had full control over the app\u0026rsquo;s UI/UX. So, I wanted to improve the Bottom Navigation Bar, making it more colorful instead of using Flutter\u0026rsquo;s default Bottom Navigation Bar. After some Googling, I found the curved_navigation_bar package, but it only allows displaying icons in the Bottom Navigation Bar items like this:\nExample code:\n1 2 3 4 5 6 7 8 9 bottomNavigationBar: CurvedNavigationBar( items: \u0026lt;Widget\u0026gt;[ Icon(Icons.add, size: 30), Icon(Icons.list, size: 30), Icon(Icons.compare_arrows, size: 30), Icon(Icons.call_split, size: 30), Icon(Icons.perm_identity, size: 30), ], ) If I wanted to add a label for each item, I could only do so by changing each item to a Column widget:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 bottomNavigationBar: CurvedNavigationBar( items: \u0026lt;Widget\u0026gt;[ Column( children: [Icon(Icons.add, size: 30), Text(\u0026#34;Add\u0026#34;)], ), Column( children: [Icon(Icons.list, size: 30), Text(\u0026#34;List\u0026#34;)], ), Column( children: [Icon(Icons.compare_arrows, size: 30), Text(\u0026#34;Compare\u0026#34;)], ), Column( children: [Icon(Icons.call_split, size: 30), Text(\u0026#34;Split\u0026#34;)], ), Column( children: [Icon(Icons.perm_identity, size: 30), Text(\u0026#34;Person\u0026#34;)], ), ], ) And the result looks like this:\nIt doesn\u0026rsquo;t look very nice, does it? ü§î\nI wanted the label of the selected item to appear below the white background area, and when I select another Bottom Navigation Bar item, the label should stay there. So, the only way was to customize this package. That\u0026rsquo;s when we move to step 2 of this article.\nCustom Curved Navigation Bar I decided to create a new, more flexible package that can support both types: items with labels and items without labels.\nTadaa\u0026hellip; Here is my package: curved_labeled_navigation_bar\nBelow, I\u0026rsquo;ll show you how to implement both types.\nNavigation Bar with label I created a new Widget called CurvedNavigationBarItem to wrap both the Icon and the label.\nExample code:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 bottomNavigationBar: CurvedNavigationBar( items: [ CurvedNavigationBarItem( child: Icon(Icons.home_outlined), label: \u0026#39;Home\u0026#39;, ), CurvedNavigationBarItem( child: Icon(Icons.search), label: \u0026#39;Search\u0026#39;, ), CurvedNavigationBarItem( child: Icon(Icons.chat_bubble_outline), label: \u0026#39;Chat\u0026#39;, ), CurvedNavigationBarItem( child: Icon(Icons.newspaper), label: \u0026#39;Feed\u0026#39;, ), CurvedNavigationBarItem( child: Icon(Icons.perm_identity), label: \u0026#39;Personal\u0026#39;, ), ], ) UI demo:\nNavigation Bar without label Example code:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 bottomNavigationBar: CurvedNavigationBar( items: [ CurvedNavigationBarItem( child: Icon(Icons.home_outlined), ), CurvedNavigationBarItem( child: Icon(Icons.search), ), CurvedNavigationBarItem( child: Icon(Icons.chat_bubble_outline), ), CurvedNavigationBarItem( child: Icon(Icons.newspaper), ), CurvedNavigationBarItem( child: Icon(Icons.perm_identity), ), ], ) UI demo:\nConclusion I hope this little package of mine is helpful for those who want a unique Bottom Navigation Bar. You can support me by giving a like or sharing. If you have any ideas for improvements, don\u0026rsquo;t hesitate to share them with me.\nPackage link: https://pub.dev/packages/curved_labeled_navigation_bar GitHub: https://github.com/namanh11611/curved_labeled_navigation_bar Thank you very much!\n","date":"2022-10-17T22:36:00+07:00","image":"https://namanh11611.github.io/p/curved-bottom-navigation-bar/navigation_hu_767a03ced1d41bbe.webp","permalink":"https://namanh11611.github.io/p/curved-bottom-navigation-bar/","title":"Custom Curved Bottom Navigation Bar in Flutter"},{"content":"The Problem When you want to charge your iPhone with a type C cable =\u0026gt; use an Adapter with a type C port and a lightning connector.\nWhen you have data in XML format but want to use a third-party library function that only accepts JSON =\u0026gt; use an Adapter to convert XML to JSON.\nIn Android, if you have a list of items and want to display them in a RecyclerView =\u0026gt; use an Adapter to convert data into each item_view.\nConcept The Adapter pattern allows the interface of an existing class to be used as another interface. It helps the existing class work with others without changing its source code.\nStill sounds a bit abstract, right? Let\u0026rsquo;s break it down step by step.\nThere are two ways to use adapters: Object Adapter and Class Adapter. Let\u0026rsquo;s look at each in detail.\nObject Adapter Pattern Class Diagram We implement the interface by delegating to the adaptee object at run-time.\nLet me explain a bit more:\nClient is the existing class mentioned in the concept. Client Interface is now the parent interface of Client. Others wanting to interact with Client must follow this parent interface. Service is a third-party class that only accepts JSON, as in the problem statement. Adapter implements the Client Interface and contains an instance of the Service class (object adaptee). Whenever a method of Adapter is called, it calls the corresponding method of Service. This way, we can work with Service without modifying Client\u0026rsquo;s code. Code sample 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 // Client Interface interface TypeCPhone { void chargeByTypeC(); } // Service Interface interface LightningPhone { void chargeByLightning(); } // Service class IPhone implements LightningPhone { @Override public void chargeByLightning() {} } // Adapter class TypeCToLightningPhoneAdapter implements TypeCPhone { private LightningPhone lightningPhone; public TypeCToLightningPhoneAdapter(LightningPhone lightningPhone) { this.lightningPhone = lightningPhone; } @Override public void chargeByTypeC() { lightningPhone.chargeByLightning(); } } public class Demo { static void chargeMyXiaomiPhone(TypeCPhone phone) { phone.chargeByTypeC(); } public static void main(String[] args) { IPhone iPhone = new IPhone(); TypeCToLightningPhoneAdapter adapter = new TypeCToLightningPhoneAdapter(iPhone); chargeMyXiaomiPhone(adapter); } } Class Adapter pattern The Class Adapter doesn\u0026rsquo;t need to wrap any object because it inherits from both Client and Service.\nUnfortunately, Java doesn\u0026rsquo;t support multiple inheritance, so we don\u0026rsquo;t have a Java code sample for this part.\nConclusion Adapter is a fairly familiar design pattern. Through the explanation and a bit of sample code, I hope everyone understands it better.\nReference\nhttps://en.wikipedia.org/wiki/Adapter_pattern https://refactoring.guru/design-patterns/adapter ","date":"2022-10-04T22:50:00+07:00","image":"https://namanh11611.github.io/p/design-pattern-adapter/adapter_hu_a5e9f7d4d2c603d7.webp","permalink":"https://namanh11611.github.io/p/design-pattern-adapter/","title":"Design Pattern: Adapter ‚Äì how to charge an iPhone with a type C cable"},{"content":"This article will go straight to explaining how to use the @Inject, @Provides, and @Binds annotations. So I\u0026rsquo;ll skip the explanation of Dependency Injection or an introduction to Hilt. Let\u0026rsquo;s assume you already know how to use it. Let\u0026rsquo;s go!\nOverview There are 3 commonly used annotations to inject objects in Hilt:\n@Inject: annotation used on the class constructor @Provides: annotation used in a Module @Binds: another annotation also used in a Module So, when should you use each of these?\nInject We use the @Inject annotation on any constructor where we want to inject an object, from ViewModel, Repository to DataSource. For example:\n1 2 3 4 5 class ProfileRepository @Inject constructor( private val profileDataSource: ProfileDataSource ) { fun doSomething() {} } This makes it easy to inject ProfileRepository into other classes, such as a ViewModel or UseCase. However, you can only use this annotation on constructors of classes you define yourself.\nProvides To overcome the above limitation‚Äîinjecting objects of classes you don\u0026rsquo;t define (such as Retrofit, OkHttpClient, or a Room database)‚Äîwe use @Provides. First, you need to create a @Module to hold dependencies with the @Provides annotation. For example:\n1 2 3 4 5 6 7 8 9 10 @Module class NetworkModule { @Provides fun providesApiService(): ApiService = Retrofit.Builder() .addConverterFactory(GsonConverterFactory.create()) .baseUrl(BASE_URL) .build() .create(ApiService::class.java) } Since Retrofit objects are not defined by your code and are created using the Builder pattern, you can\u0026rsquo;t use the @Inject annotation and must use @Provides. Now, you can inject the ApiService interface object anywhere.\nBinds For interfaces, you can\u0026rsquo;t use the @Inject annotation because they don\u0026rsquo;t have constructors. However, if you have an interface with only one implementation (a class that implements that interface), you can use @Binds to inject that interface. Injecting interfaces instead of classes is a good practice and makes testing easier.\nBack to the ProfileRepository in the @Inject section, let\u0026rsquo;s turn it into an interface and create a class that implements it. For example:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 interface ProfileRepository { } class ProfileRepositoryImpl @Inject constructor( private val profileDataSource: ProfileDataSource ) : ProfileRepository { } @Module @InstallIn(SingletonComponent::class) abstract class RepositoryModule { @Singleton @Binds abstract fun bindProfileRepository(profileRepository: ProfileRepositoryImpl): ProfileRepository } class RegisterUseCase @Inject constructor( private val profileRepository: ProfileRepository ) The advantage of using @Binds instead of @Provides is that it reduces the amount of generated code, such as Module Factory classes. Here, you can see I still use @Inject because the constructor of ProfileRepositoryImpl still needs some parameters.\nSummary So, to summarize:\nUse @Inject for your own code Use @Provides for third-party code Use @Binds to inject interfaces, reducing unnecessary code Reference\nhttps://developer.android.com/training/dependency-injection/hilt-android https://dagger.dev/hilt https://www.valueof.io/blog/inject-provides-binds-dependencies-dagger-hilt ","date":"2022-10-02T01:33:00+07:00","image":"https://namanh11611.github.io/p/hilt/hilt_hu_dd6bbd107f0f7966.webp","permalink":"https://namanh11611.github.io/p/hilt/","title":"When to use Inject, Provides, Binds in Hilt"},{"content":"Introduction Recently, my team has been running a program called \u0026ldquo;one lesson per week,\u0026rdquo; where each week, a team member gives a seminar on a particular technique or technology. We just finished several weeks on Kotlin. Last week, my team lead gave a seminar about Flask. Oh, I found this framework builds APIs quickly and simply, true to the spirit of Python. I‚Äôve always worked on Front-end and Mobile, never really touched Back-end (well, I did some PHP in college, but I‚Äôve forgotten it all :joy::joy:). So I decided to give it a try and see how it goes.\nSetup Basic For IDE, PyCharm is probably the best, but it‚Äôs a bit heavy, so I just used Visual Studio Code with the Python extension, which is more than enough.\nFirst, install Python.\nIf you‚Äôre on Windows, download it here: Download Python.\nOn Ubuntu, just run:\n1 2 $ sudo apt-get update $ sudo apt-get install python3.9 Option You can set up Virtual environments or skip this step. Virtual environments help manage your project‚Äôs dependencies. For example, you can install different versions of a library for different projects, or even use different Python versions. Each project will have its own set of Python libraries, isolated from others.\nPython 3 uses the venv module to create virtual environments. You can run the following commands to create a project folder and a venv folder:\n1 2 3 $ mkdir myproject $ cd myproject $ python3 -m venv venv On Windows:\n1 $ py -3 -m venv venv Activate your environment:\n1 $ . venv/bin/activate Flask Next, install Flask:\n1 $ pip install Flask Let‚Äôs Code Hello World Let‚Äôs start by coding a simple Flask app. Create a file called hello.py (any name is fine, just avoid flask.py to prevent conflicts) and write the following:\n1 2 3 4 5 6 from flask import Flask app = Flask(__name__) @app.route(\u0026#39;/\u0026#39;) def hello_world(): return \u0026#39;Hello, World!\u0026#39; A quick explanation:\nFlask(__name__) creates an instance of the Flask class. route() defines the URL for the API. Run the app right away:\n1 2 $ export FLASK_APP=hello.py $ flask run Check http://127.0.0.1:5000/ to see if your app is running.\nBut now, every time you change the code and refresh the browser, you don‚Äôt see the changes applied. Why? That‚Äôs because you need to enable Debug mode.\n1 2 $ export FLASK_ENV=development $ flask run Now try editing the code and see your results.\nYou can also view your results on another device (I wanted to check on my Android phone) by changing the host (set the host address to your laptop/PC‚Äôs IP) and connecting both devices to the same Wi-Fi network:\n1 $ flask run --host=192.168.xxx.xxx JSON JSON is the data format I often use for APIs. Let‚Äôs do a quick JSON demo. First, import jsonify:\n1 from flask import Flask, jsonify Instead of returning Hello, World!, let‚Äôs return a JSON response:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 @app.route(\u0026#39;/\u0026#39;) def hello_world(): return jsonify([ { \u0026#34;id\u0026#34;: 1, \u0026#34;title\u0026#34;: \u0026#34;First Memory\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;This is first Memory\u0026#34; }, { \u0026#34;id\u0026#34;: 2, \u0026#34;title\u0026#34;: \u0026#34;Second Memory\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;This is second Memory\u0026#34; }, { \u0026#34;id\u0026#34;: 3, \u0026#34;title\u0026#34;: \u0026#34;Third Memory\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;This is third Memory\u0026#34; } ]) But I noticed the fields are all jumbled up, so let‚Äôs add a bit of config:\n1 app.config[\u0026#39;JSON_SORT_KEYS\u0026#39;] = False Okay, that looks better!\nNgrok - Demo Your App Without Deploying I‚Äôm an Android developer, so I wanted to see if Flask could be used as an API for Retrofit in Android. With the above config, my device could receive the API, but when I tried it with Retrofit, it still didn‚Äôt work. Not sure if it‚Äôs because of HTTP? If anyone knows, please help clarify this part.\nSo, let me introduce you to Ngrok, a tool that helps you quickly demo your Flask app without deploying it to a server.\nInstall ngrok:\n1 $ pip install pyngrok Run $ ngrok --help to make sure it‚Äôs installed successfully. Modify your code a bit to create a Ngrok Tunnel:\n1 2 3 4 from pyngrok import ngrok ... url = ngrok.connect(5000).public_url print(\u0026#39;Henzy Tunnel URL:\u0026#39;, url) Continue by running $ flask run to see the result. Check the printed URL and access it on your Android device. Try using it as the Retrofit URL (remember to use https), and it works pretty well.\nConclusion This is just a Quickstart guide. If you‚Äôre interested, I‚Äôll write more articles in the future.\nThank you for reading!\nReferences:\nhttps://flask.palletsprojects.com/en/1.1.x/quickstart/#quickstart https://blog.miguelgrinberg.com/post/access-localhost-from-your-phone-or-from-anywhere-in-the-world ","date":"2021-01-14T01:03:00+07:00","image":"https://namanh11611.github.io/p/flask/flask_hu_89f4c1ad9e45e232.webp","permalink":"https://namanh11611.github.io/p/flask/","title":"Building a Simple API with Flask, Demo with Ngrok"},{"content":"Introduction The Singleton pattern is probably the simplest design pattern that almost everyone knows. It helps create a single instance of a class, often used for classes like Database, Manager, etc. Today, while reading code in my current project, I discovered a really neat way to implement Singleton, called the Bill Pugh Singleton, named after its creator. So I wrote this article to share this approach to Singleton.\nLazy Initialization First, let\u0026rsquo;s look at the Singleton initialization method most people use. The Singleton pattern is implemented by creating an instance in a public method. The downside is that when running in multiple threads, multiple instances can be created. In that case, Singleton is no longer a Singleton.\n1 2 3 4 5 6 7 8 9 10 11 12 13 public class LazyInitializedSingleton { private static LazyInitializedSingleton instance; private LazyInitializedSingleton() { } public static LazyInitializedSingleton getInstance() { if (instance == null) { instance = new LazyInitializedSingleton(); } return instance; } } Thread Safe Singleton To fix the drawback of Lazy Initialization, we add synchronized to the public method. This way, only one instance is created by one thread at a time.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 public class ThreadSafeSingleton { private static ThreadSafeSingleton instance; private ThreadSafeSingleton() { } public static synchronized ThreadSafeSingleton getInstance() { if (instance == null) { instance = new ThreadSafeSingleton(); } return instance; } } However, this approach still has the drawback of reducing app performance because getInstance() is a synchronized method. So, we have another improved approach:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 public class ThreadSafeSingleton { private static ThreadSafeSingleton instance; private ThreadSafeSingleton() { } public static ThreadSafeSingleton getInstance() { if (instance == null) { synchronized (ThreadSafeSingleton.class) { if (instance == null) { instance = new ThreadSafeSingleton(); } } } return instance; } } This way, we only pay the cost on the first call to getInstance().\nBill Pugh Singleton Implementation Before Java 5, Java memory had many issues and the above methods could fail when too many threads called the Singleton class\u0026rsquo;s getInstance() method simultaneously. So, Bill Pugh introduced a new way to implement Singleton using an inner static helper class.\n1 2 3 4 5 6 7 8 9 10 11 12 13 public class BillPughSingleton { private static class SingletonHelper { static final BillPughSingleton INSTANCE = new BillPughSingleton(); } private BillPughSingleton() { } public static BillPughSingleton getInstance() { return SingletonHelper.INSTANCE; } } What do you think of this method? It\u0026rsquo;s fast, concise, and still safe. When the Singleton class is loaded, the SingletonHelper class is not loaded into memory yet. Only when the getInstance() method is called is the helper class loaded and the singleton instance created. This method also doesn\u0026rsquo;t require synchronization or multiple null checks.\nConclusion Within the scope of this article, there are a few more methods I haven\u0026rsquo;t listed, but I hope this gives you a new perspective on the Singleton pattern. Thank you for reading!\nReference\nhttps://www.journaldev.com/1377/java-singleton-design-pattern-best-practices-examples\n","date":"2020-12-29T15:00:00+07:00","image":"https://namanh11611.github.io/p/design-pattern-singleton/singleton_hu_1f752abdeb17b69d.webp","permalink":"https://namanh11611.github.io/p/design-pattern-singleton/","title":"Design Pattern: Bill Pugh Singleton in Java ‚Äì surprisingly simple"},{"content":"Introduction After some time working and moving through a few companies, I realized that each place has a different workflow with Git. This article introduces the Git workflow that I think is proper and is also being used at my current company. So, I won\u0026rsquo;t introduce all Git commands, just the ones I think are enough for your daily work.\nWorkflow First day at work Simple, right? On your first day, the only command you need is git clone. When you want to get the team\u0026rsquo;s source code, just open the terminal and type:\n1 git clone \u0026lt;url\u0026gt; A small tip: if you want the folder name after cloning to be different from the project name on remote, just add the folder name at the end:\n1 git clone \u0026lt;url\u0026gt; folder_name Normal days Working alone The boss assigns a new feature, let\u0026rsquo;s get started. But wait, if you\u0026rsquo;re on another branch, don\u0026rsquo;t forget to checkout the team\u0026rsquo;s main branch (usually called master):\n1 git checkout master Then pull the latest code:\n1 git pull To check if your local code is up to date, try using git log. I usually use this for a concise view:\n1 git log --oneline Then, checkout a new branch to start your feature. Adding the -b param will create and switch to the new branch:\n1 git checkout -b feature_branch \u0026hellip;\nCode\u0026hellip; code\u0026hellip; code\u0026hellip;\u0026hellip;\n\u0026hellip;\nDone! Now add the files you changed to the stage. Most IDEs support quick add and commit, but if you want to do it manually:\n1 git add . This adds all changed files to the stage. Then commit:\n1 git commit -m \u0026#34;Fix all bugs\u0026#34; Note: Branch and commit names should be clear, indicating what feature or bug fix they relate to. This depends on your team\u0026rsquo;s rules. Some teams use the task ID as a prefix, others use the purpose, like feature/fixbug/\u0026hellip;\nFinally, push your code to the repository:\n1 git push origin feature_branch Now go to the repository and create a merge request for your boss to review. While waiting, grab a coffee.\nFeature with multiple contributors If your branch has multiple people working on it, and someone else pushed before you, before pushing, pull like this:\n1 git pull --rebase Your commit will be placed on top of your colleague\u0026rsquo;s in the log.\nIf you want to fetch code but not merge yet, use:\n1 git fetch In my opinion, pull = fetch + merge.\nMerging code After review, your boss agrees to merge, but during review you added, changed, or deleted some files. You want to rebase those commits into one, or just edit or delete a commit. Suppose you have 3 commits to combine:\n1 git rebase -i HEAD~3 The terminal gives you options like edit, reword, squash\u0026hellip; Change \u0026lsquo;pick\u0026rsquo; to the option you want. Press Ctrl + O to save, then Ctrl + X to exit.\nAnother issue: someone else pushed to master. You can still merge, but it will create a merge commit. I usually rebase and merge fast forward.\nFirst:\n1 git fetch Then rebase. You must be on feature_branch:\n1 git rebase origin/master Simply put, rebase gets the latest code from master, then \u0026ldquo;rewrites\u0026rdquo; your feature branch to put your commits on top.\nFinally, force push to your feature branch. Force push applies your local log to the repo branch, regardless of differences:\n1 git push -f origin feature_branch If you\u0026rsquo;re the only one on the branch, force push is fine. But be careful when force pushing to a branch with multiple contributors, as it can cause conflicts for others. Only do this when you\u0026rsquo;re sure your feature is done.\nThen, merge code via the merge request on the repo. Task complete!\nCrisis days Reset Sometimes you make a mistake and need to revert code. Git reset has 3 options for you.\nReset commit but keep code in stage, ready to recommit:\n1 git reset --soft commit_id Reset commit and remove code from stage. You need to use git add before recommitting:\n1 git reset --mixed commit_id Reset commit and delete all code you did:\n1 git reset --hard commit_id Stash You can use this as a lifesaver to temporarily save code before rebasing or checking out another branch that has conflicts. Think of it as a stack-structured scratchpad.\nTo stash all current changes:\n1 git stash To apply the last stash:\n1 git stash pop I mainly use Android Studio now, which has Shelf with similar functionality, so I don\u0026rsquo;t use git stash much anymore.\nYou can read more here.\nConclusion Honestly, the title is just clickbait‚Äîthere\u0026rsquo;s no such thing as a \u0026ldquo;proper\u0026rdquo; workflow. Every company and project is different. If your project is small and speed is a priority, you might skip some steps and push straight to master. If your project is big and strict, you might not allow force pushes to remote. So, what\u0026rsquo;s your company\u0026rsquo;s workflow? Share it with me!\nThanks for reading!\n","date":"2020-11-10T17:19:00+07:00","image":"https://namanh11611.github.io/p/git-process/git_hu_7de7796ffad5fef9.webp","permalink":"https://namanh11611.github.io/p/git-process/","title":"A Proper Workflow with Git"},{"content":"The Unfortunate Situation JavaScript developers are surely familiar with Date, the object used to calculate days, months, and years. On a beautiful day, March 29, 2019, while happily and enthusiastically working overtime, I suddenly discovered a bug related to date display on the Front-end. Wait, when I pass 1 as a parameter, it returns Mar (March), passing 0 returns Jan (January), but what I wanted was Feb (February). What\u0026rsquo;s going on???\nI calmly opened F12 and debugged, only to find that the Date.getMonth() function returns such a weird result.\nIt was already 9pm, and I didn\u0026rsquo;t trust my alertness anymore, so I switched to the Console tab to try it out. Maybe someone had customized the getMonth() function in the project?\nAnd the result was as follows (reproduced on the morning of March 30):\nYou can try this in your own console to verify:\n1 2 3 4 5 var date = new Date(); date.setMonth(1); date.getMonth(); date.setMonth(0); date.getMonth(); This Mouse Trap is Huge It turns out that after calling setMonth(1), date is not set to February (index = 1), but is just moved back 28 days (from March 30 to March 2).\nYou can read more about the setMonth() function here.\nReading the Description carefully, we see that setMonth() uses the current day of the old month to set the day for the new month. If it exceeds the number of days in the new month, it rolls over to the next month. For example, if the current day is 30 or 31, setMonth(1) will definitely move to March, because February has at most 29 days. Here, our current date is March 30, so when setting to February 2019 (which has 28 days), it adds 2 days and becomes March 2.\nIndeed, this mouse trap has at least caught one fat mouse‚Äîme.\nSolution From this, we learn that to use setMonth() and getMonth() comfortably, it\u0026rsquo;s best to use the 1st day of the month.\n1 var date = new Date(\u0026#39;March 1, 2019 00:00:01\u0026#39;); Then you can freely use setMonth() and getMonth() as you wish.\nHope you always read the documentation carefully and write fewer bugs. Don\u0026rsquo;t get caught in the trap like I did.\n","date":"2019-03-30T01:33:00+07:00","image":"https://namanh11611.github.io/p/date-set-month/month_hu_60aa0de3dcf7e0d5.webp","permalink":"https://namanh11611.github.io/p/date-set-month/","title":"The Mouse Trap in Javascript's Date.setMonth()"}]
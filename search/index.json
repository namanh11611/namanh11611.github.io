[{"content":"As you may know, all Dart code runs in isolates, starting from the default main isolate. When developing Flutter applications, handling heavy tasks like image processing or complex calculations on the main isolate can cause lag and stutter. Although Flutter provides Future and Stream, they are still processed on the main isolate. The Isolate API was created to solve this problem, allowing us to offload heavy tasks to background workers and restore the app\u0026rsquo;s smoothness. In this article, I will explain how to use Isolate and provide best practices for working with it.\nWhat is an Isolate? Dart is a single-threaded language. When you use async and await, it actually runs concurrently. If a time-consuming task runs on the main thread, it will block the entire UI. Isolate is the solution for parallelism.\nAn Isolate is an independent execution thread in Dart. Each isolate has its own Heap memory, ensuring that no isolate can access another\u0026rsquo;s memory, which helps the app run smoothly without shared state.\nLet\u0026rsquo;s jump into code for a clearer picture. Here’s a simple example of creating an Isolate:\n1 2 3 4 5 6 7 8 9 10 import \u0026#39;dart:isolate\u0026#39;; void main() { Isolate.spawn(isolateMethod, \u0026#34;Hello World from Main Isolate\u0026#34;); print(\u0026#39;Main isolate\u0026#39;); } void isolateMethod(String message) { print(\u0026#39;New isolate: $message\u0026#39;); } In the example above, the main() function runs on the main isolate, often called the UI isolate. We create a new isolate by calling Isolate.spawn(), which executes the isolateMethod(). These worker isolates cannot access the UI.\nCommunication Between Isolates To exchange data between isolates, Dart provides two classes: SendPort and ReceivePort, which allow isolates to communicate via messages. Read the following code; I’ll explain it in detail below.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 void main() async { final mainReceivePort = ReceivePort(); final isolate = await Isolate.spawn(twoWayIsolate, mainReceivePort.sendPort); // Receive SendPort from the worker isolate mainReceivePort.listen((message) { if (message is SendPort) { print(\u0026#39;Main: SendPort\u0026#39;); message.send(\u0026#39;Hello\u0026#39;); } else { print(\u0026#39;Main received: $message\u0026#39;); // Output: Hello to Henry isolate.kill(); } }); } void twoWayIsolate(SendPort mainSendPort) { final receivePort = ReceivePort(); // Send the worker isolate\u0026#39;s SendPort back to main mainSendPort.send(receivePort.sendPort); receivePort.listen((message) { if (message is String) { print(\u0026#39;Worker received: $message\u0026#39;); // Output: Hello final newMessage = \u0026#39;$message to Henry\u0026#39;; mainSendPort.send(newMessage); } }); } In this example, we set up two-way communication between the main isolate and the worker isolate:\n1 2 // Send the worker isolate\u0026#39;s SendPort back to main mainSendPort.send(receivePort.sendPort); As soon as the main isolate receives a SendPort message, it sends a greeting to the worker isolate:\n1 message.send(\u0026#39;Hello\u0026#39;); The worker isolate responds by sending a greeting back to the main isolate:\n1 2 final newMessage = \u0026#39;$message to Henry\u0026#39;; mainSendPort.send(newMessage); As you can see, SendPort.send() is responsible for sending messages, while listening for messages is done via ReceivePort.listen().\nUsing compute for Simple Tasks Flutter provides the compute function to run a function in a new isolate with just one line of code:\n1 2 3 4 5 6 7 8 9 10 11 12 13 Future\u0026lt;void\u0026gt; fetchData() async { final result = await compute(_heavyProcessing, 1000000); print(\u0026#39;Result: $result\u0026#39;); } // This function will run in its own isolate int _heavyProcessing(int iterations) { int sum = 0; for (int i = 0; i \u0026lt; iterations; i++) { sum += i; } return sum; } The advantage of compute is that it automatically manages the isolate, which is destroyed as soon as it finishes.\nHowever, there are limitations: compute only accepts one parameter. If you need more, you must package them into a Map or List. Also, compute cannot do two-way communication like Isolate.spawn in the previous example.\nBest Practices Only use isolates for CPU-intensive tasks For network requests, you can use a regular HTTP client. Only use isolates for CPU-heavy tasks like image processing.\n1 2 3 4 5 // DO compute(imageProcessing, imageData); // DON\u0026#39;T compute(networkRequest, url); Avoid creating isolates continuously Creating new isolates repeatedly consumes CPU and memory, and initializing an isolate is relatively slow, taking about 30ms each time. Therefore, using a Worker Pool helps reuse existing isolates.\nUse simple data types when passing through ports Since isolates do not share memory, data passed between isolates must be serialized/deserialized. Using complex data types increases conversion time and memory usage when copying data.\n1 2 3 4 5 // Recommended sendPort.send({\u0026#39;id\u0026#39;: 1, \u0026#39;value\u0026#39;: 42}); // Not recommended sendPort.send(MyComplexClass()); Stop isolates when not needed When using Isolate.spawn, it does not automatically release resources when unused. Leaving isolates running in the background wastes CPU/memory and can cause memory leaks. Use Isolate.kill to stop them when done.\n1 isolate.kill(priority: Isolate.immediate); Conclusion Isolate is a powerful tool for handling heavy tasks in Flutter without affecting the UI. Although it has some complexity, by using it correctly with compute and supporting libraries, you can create smooth apps even when handling complex business logic.\nReference Concurrency in Dart Isolates ","date":"2025-05-25T00:00:00+07:00","image":"https://namanh11611.github.io/p/isolate/isolate_hu_b7907989028452fd.webp","permalink":"https://namanh11611.github.io/p/isolate/","title":"Isolate in Flutter: The Savior for Heavy Tasks"},{"content":" Tired of academic articles? Today, let\u0026rsquo;s enjoy a detective-style article for a change of pace.\nCase Introduction Key appears everywhere in Flutter, from StatefulWidget to StatelessWidget. It seems so close yet so far, familiar yet mysterious. Although Flutter developers often work with Widget, Key—the silent player behind all power transfers—rarely gets attention.\nToday, the Flutter Vietnam detective team will take you deep into the corners of the Flutter gang, decoding the role of Key in optimizing performance for Flutter apps, and exploring best practices for using them.\nSearching for the Mastermind The definition of Key in the documentation states:\nA Key is an identifier for Widgets, Elements and SemanticsNodes.\nA new widget will only be used to update an existing element if its key is the same as the key of the current widget associated with the element.\nTranslation:\nKey is an identifier for Widget, Element, and SemanticsNodes.\nA new widget will only be used to update an existing element if its key matches the key of the current widget associated with that element.\nAs you know, in Flutter, everything is a Widget. This Widget gang includes familiar faces like Row, Column, Container\u0026hellip; But these Widgets are just henchmen; according to our intelligence, the gang is run by a notorious boss: Element.\nHe manipulates all Widgets, from calling initState, build, dispose of Widgets to managing the Widget Tree. Element is also a crucial link between Widget and RenderObject—the one that draws the UI on the screen—to create masterpieces.\nHowever, today we\u0026rsquo;re not taking down the boss or the whole gang, just remember that Element orchestrates everything. The fish isn\u0026rsquo;t big enough yet to cast the net. The goal of this case is to investigate Key and the four masters.\nKey When you rebuild a Flutter app, do you know what happens in the shadows? Element decides which Widgets to keep, replace, or remove. This is where Key starts to show its power.\nIn the Widget world, whenever changes occur, Widgets aren\u0026rsquo;t just updated but are destroyed and reborn. Key is the identity card that helps Widgets retain their identity during rebirth. After the Widget tree is rebuilt, Element uses Widget type and Key to decide whether the Element should be rebuilt. If Widget types differ, the Element is destroyed and recreated. Rebuilding the boss is much more expensive than rebuilding the henchmen Widgets. This can cause unwanted performance issues and sometimes make your app lag.\nIf Widget types are the same, Element compares the Key. If the Key matches, Element only updates the widget. Otherwise, Element is deactivated, meaning it\u0026rsquo;s temporarily removed from the Element tree and may be reattached later.\nThere are two main types of Key: LocalKey and GlobalKey. LocalKey is further divided into UniqueKey, ValueKey, and ObjectKey. Let\u0026rsquo;s unmask each one.\nUniqueKey – The Untraceable Assassin A mysterious figure, appearing and disappearing, never showing up twice with the same value. It creates unique values to help Flutter distinguish between two Widgets even if they have the same type. Use it when you don\u0026rsquo;t want to reuse any Widget, ensuring the Widget is completely rebuilt.\nFirst, let\u0026rsquo;s create an Item widget that simply displays a Text, but we\u0026rsquo;ll use StatefulWidget so you can clearly see the init and rebuild process.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Item extends StatefulWidget { final String text; const Item({super.key, required this.text}); @override State\u0026lt;Item\u0026gt; createState() =\u0026gt; _ItemState(); } class _ItemState extends State\u0026lt;Item\u0026gt; { @override void initState() { super.initState(); debugPrint(\u0026#39;[_ItemState.initState] key = ${widget.key}, text = ${widget.text}\u0026#39;); } @override Widget build(BuildContext context) { debugPrint(\u0026#39;[_ItemState.build] key = ${widget.key}, text = ${widget.text}\u0026#39;); return Text(widget.text); } } Next, create a ListView containing those Item widgets, without passing any Key to the items.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 final names = [\u0026#39;Henry\u0026#39;, \u0026#39;Techie\u0026#39;, \u0026#39;Nam\u0026#39;, \u0026#39;Anh\u0026#39;, \u0026#39;Nguyen\u0026#39;]; class HomePage extends StatefulWidget { const HomePage({super.key}); @override State\u0026lt;HomePage\u0026gt; createState() =\u0026gt; _HomePageState(); } class _HomePageState extends State\u0026lt;HomePage\u0026gt; { int _counter = 0; void _incrementCounter() { setState(() { _counter++; }); } @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar(title: Text(\u0026#39;Demo Key\u0026#39;)), body: ListView.builder( itemCount: _counter, itemBuilder: (context, index) =\u0026gt; Item( text: names[index], ), ), floatingActionButton: FloatingActionButton( onPressed: _incrementCounter, child: Icon(Icons.add), ), ); } } Check the log: when you click the FloatingActionButton to create each item, only the newest widget calls initState, others just rebuild. Here\u0026rsquo;s the log when creating the 5th item:\n1 2 3 4 5 6 [_ItemState.build] key = null, text = Henry [_ItemState.build] key = null, text = Techie [_ItemState.build] key = null, text = Nam [_ItemState.build] key = null, text = Anh [_ItemState.initState] key = null, text = Nguyen [_ItemState.build] key = null, text = Nguyen Now, let\u0026rsquo;s assign the UniqueKey assassin. Add UniqueKey to Item:\n1 2 3 4 5 6 7 body: ListView.builder( itemCount: _counter, itemBuilder: (context, index) =\u0026gt; Item( key: UniqueKey(), text: names[index], ), ), Everything changes: when clicking FloatingActionButton to create each item, all widgets are recreated. Even the Key value changes each time. Here\u0026rsquo;s the log for the 5th item; not only item 5 but all items 1 to 4 are also re-initialized:\n1 2 3 4 5 6 7 8 9 10 [_ItemState.initState] key = [#c24b5], text = Henry [_ItemState.build] key = [#c24b5], text = Henry [_ItemState.initState] key = [#02979], text = Techie [_ItemState.build] key = [#02979], text = Techie [_ItemState.initState] key = [#0a0db], text = Nam [_ItemState.build] key = [#0a0db], text = Nam [_ItemState.initState] key = [#23d4d], text = Anh [_ItemState.build] key = [#23d4d], text = Anh [_ItemState.initState] key = [#614a4], text = Nguyen [_ItemState.build] key = [#614a4], text = Nguyen ValueKey – The Reliable Butcher A simple-minded but highly effective worker, ValueKey is perfect when you have a clear identifier value, such as a String or int. This butcher helps Element know which Widget to keep based solely on that identifier, allowing you to reuse Widgets when the Key value doesn\u0026rsquo;t change.\nLet\u0026rsquo;s update the previous ListView example to ReorderableListView. Since ReorderableListView requires each item to have a Key, we\u0026rsquo;ll start with Item using ValueKey.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 body: ReorderableListView( onReorder: (oldIndex, newIndex) { setState(() { if (newIndex \u0026gt; oldIndex) newIndex -= 1; final item = names.removeAt(oldIndex); names.insert(newIndex, item); }); }, children: names .map((item) =\u0026gt; Item( key: ValueKey(item), text: item, )) .toList(), ), Now, whenever you drag to reorder items, you\u0026rsquo;ll see the items being rebuilt:\n1 2 3 4 5 [_ItemState.build] key = [\u0026lt;\u0026#39;Henry\u0026#39;\u0026gt;], text = Henry [_ItemState.build] key = [\u0026lt;\u0026#39;Techie\u0026#39;\u0026gt;], text = Techie [_ItemState.build] key = [\u0026lt;\u0026#39;Nam\u0026#39;\u0026gt;], text = Nam [_ItemState.build] key = [\u0026lt;\u0026#39;Anh\u0026#39;\u0026gt;], text = Anh [_ItemState.build] key = [\u0026lt;\u0026#39;Nguyen\u0026#39;\u0026gt;], text = Nguyen What if you change the value of an item after dragging by updating the onReorder function? For example, when dragging \u0026lsquo;Henry\u0026rsquo;, change its value to \u0026lsquo;Henry Changed\u0026rsquo;:\n1 2 3 4 5 6 7 onReorder: (oldIndex, newIndex) { setState(() { if (newIndex \u0026gt; oldIndex) newIndex -= 1; final item = \u0026#39;${names.removeAt(oldIndex)} Changed\u0026#39;; names.insert(newIndex, item); }); }, The value changes, so the ValueKey changes, and the item is recreated:\n1 2 [_ItemState.initState] key = [\u0026lt;\u0026#39;Henry Changed\u0026#39;\u0026gt;], text = Henry Changed [_ItemState.build] key = [\u0026lt;\u0026#39;Henry Changed\u0026#39;\u0026gt;], text = Henry Changed ObjectKey – The Strategic Advisor Unlike ValueKey, this one is a master strategist, holding a complex object. ObjectKey relies on object reference. Two Keys are considered equal only if they reference the same object.\nSimilar to the ValueKey example, let\u0026rsquo;s update it to use ObjectKey instead.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class _HomePageState extends State\u0026lt;HomePage\u0026gt; { final List\u0026lt;Person\u0026gt; people = [ Person(name: \u0026#34;Henry\u0026#34;), Person(name: \u0026#34;Techie\u0026#34;), Person(name: \u0026#34;Nam\u0026#34;), Person(name: \u0026#34;Anh\u0026#34;), Person(name: \u0026#34;Nguyen\u0026#34;), ]; @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar(title: Text(\u0026#39;Demo Key\u0026#39;)), body: ReorderableListView( onReorder: (oldIndex, newIndex) { setState(() { if (newIndex \u0026gt; oldIndex) newIndex -= 1; final item = people.removeAt(oldIndex); people.insert(newIndex, item); }); }, children: people .map((item) =\u0026gt; Item( key: ObjectKey(item), text: item.name, )) .toList(), ), ); } } class Person { final String name; Person({required this.name}); } GlobalKey – The Powerful Butler In the gang, GlobalKey is the strongest. It knows everything in the Widget Tree. Not only does it store identity, but it also manages the entire state and allows direct access to State. This brings flexibility but can be easily abused.\nThe most common example is using GlobalKey to control and validate the state of a Form.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class GlobalKeyExample extends StatelessWidget { final GlobalKey\u0026lt;FormState\u0026gt; formKey = GlobalKey\u0026lt;FormState\u0026gt;(); @override Widget build(BuildContext context) { return Form( key: formKey, child: Column( children: [ TextFormField(validator: (value) =\u0026gt; value!.isEmpty ? \u0026#39;Required\u0026#39; : null), ElevatedButton( onPressed: () { if (formKey.currentState!.validate()) { print(\u0026#39;Form is valid!\u0026#39;); } }, child: Text(\u0026#39;Submit\u0026#39;), ), ], ), ); } } Best Practices for Using Key Key is not just a tool, but a treasure for controlling your app. Understanding and using Key correctly not only optimizes performance but also ensures your app\u0026rsquo;s logic remains stable and accurate. Overusing it can make your code unnecessarily complex, so use it only when needed. Remember, in the ever-changing world of Flutter, Key is the key to smooth apps you develop!\n","date":"2025-05-12T00:00:00+07:00","image":"https://namanh11611.github.io/p/key/key_hu_ba78e99ce03a5566.webp","permalink":"https://namanh11611.github.io/p/key/","title":"Investigation Case: Decoding the Mystery of Key in Flutter"},{"content":"Photo by Patrick Hendry on Unsplash\nIn the previous article Stack and Heap Memory in Java, I mentioned Memory Leaks as a cause of java.lang.OutOfMemoryError. Today, let\u0026rsquo;s dive into specific examples that cause Memory Leaks to learn how to prevent and fix them. Let\u0026rsquo;s get started and diagnose each case like an IT doctor!\nStatic Reference to Context Sometimes, by mistake, you might declare an Activity or Context as a static variable. This keeps a reference to the Activity or Context in that static variable, preventing the Garbage Collector from reclaiming memory and leading to a memory leak. You can read more about how the Garbage Collector works in this article.\n1 2 3 4 5 6 7 8 9 class MemoryLeakExample { companion object { var context: Context? = null // Static reference to Context } fun initialize(context: Context) { this.context = context } } 1 2 3 object MySingleton { var context: Context? = null } To fix this, use applicationContext instead of the Activity context.\n1 2 3 4 5 6 7 8 9 class MemorySafeExample { companion object { var context: Context? = null } fun initialize(context: Context) { this.context = context.applicationContext // Use applicationContext instead of Activity context } } Or, if you must store context in a singleton/static, use WeakReference:\n1 2 3 4 5 6 7 8 9 object MySingleton { private var weakContext: WeakReference\u0026lt;Context\u0026gt;? = null fun setContext(context: Context) { weakContext = WeakReference(context.applicationContext) } fun getContext(): Context? = weakContext?.get() } Inner Class (Non-Static) Inner classes always carry an implicit reference to the outer class. So, if a Handler, Runnable, etc. in an inner class continues to exist after the Activity is destroyed, it can cause a memory leak.\n1 2 3 4 5 6 7 8 9 10 11 class MainActivity : AppCompatActivity() { private val handler = Handler(Looper.getMainLooper()) override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) handler.postDelayed({ // Code that refers to activity }, 1000) } } To fix this, use WeakReference or a static inner class:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 class MainActivity : AppCompatActivity() { private val handler = Handler(Looper.getMainLooper()) override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) val weakActivity = WeakReference(this) handler.postDelayed({ weakActivity.get()?.let { // Safe usage of activity } }, 1000) } } Forgetting to Unregister Listener Forgetting to unregister a listener or BroadcastReceiver after an Activity/Fragment is destroyed can prevent the activity from being reclaimed by the Garbage Collector.\n1 2 3 4 5 6 7 8 9 10 11 class MainActivity : AppCompatActivity() { private lateinit var receiver: BroadcastReceiver override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) receiver = BroadcastReceiver { context, intent -\u0026gt; } registerReceiver(receiver, IntentFilter(\u0026#34;com.example.MY_ACTION\u0026#34;)) } // Forgot to unregister receiver } Always remember to unregister listeners/receivers in onDestroy():\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 class MainActivity : AppCompatActivity() { private lateinit var receiver: BroadcastReceiver override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) receiver = BroadcastReceiver { context, intent -\u0026gt; } registerReceiver(receiver, IntentFilter(\u0026#34;com.example.MY_ACTION\u0026#34;)) } override fun onDestroy() { super.onDestroy() unregisterReceiver(receiver) // Unregister when activity is destroyed } } Long-Running Async Task or Thread Background tasks like coroutine, thread, or Runnable that continue running after the Activity is destroyed and still hold a reference to the old Activity are also a common cause of memory leaks.\nSome solutions for this case:\nCancel coroutine/async tasks in onDestroy() Use lifecycleScope/viewModelScope to automatically cancel tasks when the lifecycle ends Conclusion Besides remembering and applying the best practices above, you can also use tools like LeakCanary or Memory Profiler in Android Studio to monitor and debug memory leaks. Understanding and avoiding memory leaks will help your Android app save RAM and run more smoothly.\n","date":"2025-05-11T11:00:00+07:00","image":"https://namanh11611.github.io/p/memory-leak/memory_leak_hu_722e3d3cdb0eb599.webp","permalink":"https://namanh11611.github.io/p/memory-leak/","title":"IT Doctor Diagnoses Common Memory Leak Cases in Android"},{"content":"There\u0026rsquo;s a long-standing debate: \u0026ldquo;Is grinding algorithms only for coding interviews and not really useful in real work?\u0026rdquo; Of course, there are obvious examples like ride-hailing apps, which must use pathfinding algorithms—a classic algorithm we learned in college. But writing such important algorithms seems to be the job of a small number of senior developers, while most of us do simpler tasks, not knowing when we\u0026rsquo;ll get to use the knowledge we\u0026rsquo;ve worked so hard to acquire. Are we wasting a lot of time?\nSo today\u0026rsquo;s article will share a problem I encountered in a project, and how practicing LeetCode helped me solve it. I\u0026rsquo;m not bragging—this is just a small algorithm, nothing world-changing. I just want to show that: \u0026ldquo;Oh, so grinding algorithms can sometimes be applied to real projects!\u0026rdquo; 😜\nThe Problem I\u0026rsquo;m building an English speaking app called Speakie, mainly to solve my own pain point: I can\u0026rsquo;t speak full sentences in conversation, often pausing to think about grammar. So the lessons in the app are based on common conversational sentence patterns.\nQuick ad break:\nAndroid: https://play.google.com/store/apps/details?id=com.areser.speakie\niOS: https://apps.apple.com/app/speakie/id6593695505\nThe problem: when a user says a sentence, I need to compare it to the sample sentence, coloring correct words green and incorrect words red. And I want to color as many words green as possible to encourage the user.\nExample:\nSample sentence: Hello World! Welcome to my app Speakie.\nUser\u0026rsquo;s sentence: Hello Henry! Welcome to my world.\n==\u0026gt; The sample sentence should have \u0026ldquo;Hello\u0026rdquo;, \u0026ldquo;Welcome\u0026rdquo;, \u0026ldquo;to\u0026rdquo;, \u0026ldquo;my\u0026rdquo; colored green.\nA naive solution is to use a Set to store the user\u0026rsquo;s words, then check each word in the sample—if it\u0026rsquo;s in the set, color it green, otherwise red. But this doesn\u0026rsquo;t preserve word order. For example, if \u0026ldquo;world\u0026rdquo; appears out of order, this method would still color it green.\nWhile working, I noticed some popular English learning apps still make this mistake—you can test by intentionally saying words out of order 😉\nLeetCode problem Thinking of a solution, I immediately remembered the Longest Common Subsequence problem. The problem:\nGiven two strings text1 and text2, return the length of their longest common subsequence. If there is no common subsequence, return 0.\nA subsequence of a string is a new string formed from the original by deleting some (or no) characters without changing the order of the remaining characters.\nFor example, \u0026ldquo;ace\u0026rdquo; is a subsequence of \u0026ldquo;abcde\u0026rdquo;.\nBase solution This problem requires Dynamic Programming. For example, with text1 = \u0026ldquo;XMJYAUZ\u0026rdquo;, text2 = \u0026ldquo;MZJAWXU\u0026rdquo;, we create a 2D array to store the length of the longest common subsequence as we iterate:\nYou can understand:\nRow 0: text1 is empty, text2 = \u0026ldquo;MZJAWXU\u0026rdquo;, no subsequence =\u0026gt; 0 Row 1: text1 = \u0026ldquo;X\u0026rdquo;, text2 = \u0026ldquo;MZJAWXU\u0026rdquo;, subsequence = \u0026ldquo;X\u0026rdquo; =\u0026gt; 1 Row 2: text1 = \u0026ldquo;XM\u0026rdquo;, text2 = \u0026ldquo;MZJAWXU\u0026rdquo;, subsequence = \u0026ldquo;X\u0026rdquo; or \u0026ldquo;M\u0026rdquo; =\u0026gt; 1 Row 3: text1 = \u0026ldquo;XMJ\u0026rdquo;, text2 = \u0026ldquo;MZJAWXU\u0026rdquo;, subsequence = \u0026ldquo;MJ\u0026rdquo; =\u0026gt; 2 \u0026hellip; In general, for character i of text1 and j of text2:\nIf text1[i] == text2[j], then length[i][j] = length[i - 1][j - 1] + 1 If text1[i] != text2[j], then length[i][j] = max(length[i - 1][j], length[i][j - 1]) Full source code:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 public int longestCommonSubsequence(String text1, String text2) { int n1 = text1.length(), n2 = text2.length(); int[][] length = new int[n1 + 1][n2 + 1]; for (int i = 1; i \u0026lt;= n1; ++i) { for (int j = 1; j \u0026lt;= n2; ++j) { if (text1.charAt(i - 1) == text2.charAt(j - 1)) { length[i][j] = length[i - 1][j - 1] + 1; } else { length[i][j] = Math.max(length[i - 1][j], length[i][j - 1]); } } } return length[n1][n2]; } Space Optimization solution The above is the most understandable and matches our analysis. However, there\u0026rsquo;s a more memory-efficient way—see Solutions.\nWhen iterating row i, we only need values from row i - 1 and the value of length[i][j - 1]. So instead of a 2D array, we just need 1 array and two variables prevRowCol, prevRow:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 public int longestCommonSubsequence(String text1, String text2) { int n1 = text1.length(), n2 = text2.length(); if (n1 \u0026lt; n2) { return longestCommonSubsequence(text2, text1); } int[] length = new int[n2 + 1]; for (int i = 1; i \u0026lt;= n1; ++i) { for (int j = 1, prevRow = 0, prevRowCol = 0; j \u0026lt;= n2; ++j) { prevRowCol = prevRow; prevRow = length[j]; if (text1.charAt(i - 1) == text2.charAt(j - 1)) { length[j] = prevRowCol + 1; } else { length[j] = Math.max(length[j - 1], prevRow); } } } return length[n2]; } Applying to the problem See the connection to our original problem? We just replace characters with words to find the common words in the sample and user sentences. However, the LeetCode problem only gives the length of the subsequence, while we want to know which words are in the subsequence to color them.\nBoolean array My first thought was to use a Boolean array with the length of the sample sentence, marking true for words that appear and false for those that don\u0026rsquo;t. But the problem is, at each step when considering length[i][j] = max(length[i - 1][j], length[i][j - 1]), we need the Boolean arrays of both [i - 1][j] and [i][j - 1] to set the Boolean array for [i][j] according to the larger length. This means we need another array similar to length, but each element is a Boolean array—a 2D Boolean array.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 // For simplicity, sample (the sample sentence) and input (the user\u0026#39;s sentence) have been // converted from sentences to lists of words, all lowercase, no accents... public void displaySampleSentence(String[] sample, String[] input) { int sampleLength = sample.length, inputLength = input.length; int[] length = new int[inputLength + 1]; boolean[][] match = new boolean[inputLength + 1][sampleLength + 1]; boolean[] prevRowMatch = new boolean[sampleLength + 1]; boolean[] prevRowColMatch = new boolean[sampleLength + 1]; for (int i = 1; i \u0026lt;= sampleLength; ++i) { for (int j = 1, prevRow = 0, prevRowCol = 0; j \u0026lt;= inputLength; ++j) { prevRowCol = prevRow; prevRow = length[j]; prevRowColMatch = prevRowMatch; prevRowMatch = match[j]; if (sample[i - 1].equals(input[j - 1])) { length[j] = prevRowCol + 1; match[j] = prevRowColMatch; match[j][i] = true; } else if (length[j - 1] \u0026gt;= prevRow) { length[j] = length[j - 1]; match[j] = match[j - 1]; } } } for (int i = 1; i \u0026lt;= sampleLength; ++i) { if (match[inputLength][i]) { // Display sample[i - 1] as green word } else { // Display sample[i - 1] as red word } } } Integer and Bit manipulation To make it simpler and lighter, I thought of using an int instead of a Boolean array, and using bitwise operations—set bit = 1 for true, bit = 0 for false. On Android and iOS, Dart\u0026rsquo;s int uses 64 bits. If each bit represents a word, we can store up to 64 words—more than enough for my app.\nA quick reminder about bitwise operations. To set the i-th bit to true, use OR and SHIFT LEFT:\n1 2 3 4 5 6 7 match |= 1 \u0026lt;\u0026lt; i; // Example: match = 1, i = 3 match = 0001 1 \u0026lt;\u0026lt; i = 1000 match | (1 \u0026lt;\u0026lt; i) = 1001 // =\u0026gt; match = 9 // So we\u0026#39;ve set the 3rd bit from the right (0th index) to 1 (TRUE) To get the value of the i-th bit, use SHIFT RIGHT and AND:\n1 2 3 4 5 6 7 int value = (match \u0026gt;\u0026gt; i) \u0026amp; 1; // Example: match = 25, i = 3 match = 0001 1001 match \u0026gt;\u0026gt; i = 0000 0011 (match \u0026gt;\u0026gt; i) \u0026amp; 1 = 1 // So the value of the 3rd bit from the right (0th index) is 1 (TRUE) Applying this to the above solution, we have:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 public void displaySampleSentence(String[] sample, String[] input) { int sampleLength = sample.length, inputLength = input.length; int[] length = new int[inputLength + 1]; int[] match = new int[inputLength + 1]; int prevRowMatch = 0, prevRowColMatch = 0; for (int i = 1; i \u0026lt;= sampleLength; ++i) { for (int j = 1, prevRow = 0, prevRowCol = 0; j \u0026lt;= inputLength; ++j) { prevRowCol = prevRow; prevRow = length[j]; prevRowColMatch = prevRowMatch; prevRowMatch = match[j]; if (sample[i - 1].equals(input[j - 1])) { length[j] = prevRowCol + 1; match[j] = prevRowColMatch; match[j][i] = true; } else if (length[j - 1] \u0026gt;= prevRow) { length[j] = length[j - 1]; match[j] = match[j - 1]; } } } for (int i = 1; i \u0026lt;= sampleLength; ++i) { if (match[inputLength][i]) { // Display sample[i - 1] as green word } else { // Display sample[i - 1] as red word } } } Lời kết Algorithms are still a foundational element in this programming field. Over time, technologies may become outdated or rise in popularity, but algorithms remain, standing the test of time.\nThrough this interesting example, I hope you\u0026rsquo;ll be more excited about learning algorithms and applying them to real-world problems.\nReference https://leetcode.com/problems/longest-common-subsequence https://wikipedia.org/wiki/Longest_common_subsequence https://dart.dev/guides/language/numbers ","date":"2025-05-11T01:00:00+07:00","image":"https://namanh11611.github.io/p/speakie/speakie_hu_35d8794dea494a10.webp","permalink":"https://namanh11611.github.io/p/speakie/","title":"Applying LeetCode Algorithms to the Speakie English Learning App"},{"content":"Photo by 7 on Unsplash\nRecently, I\u0026rsquo;ve spent time building apps like Habit Tree and Speakie (you can see more at Areser), or occasionally working on some outsource projects for clients. Every time I start a new project, I spend a whole day setting up architecture, routing, auth, state management\u0026hellip; for the app. So, from real needs, I thought about building a lightweight Flutter base project to start as quickly as possible. And that\u0026rsquo;s why Flutter MVVM Riverpod Starter was born.\nCheck it out here: https://github.com/namanh11611/flutter_mvvm_riverpod\n🚀 Why choose this starter? My goal is to create a lightweight template, but powerful enough for indie hackers and solo developers. That\u0026rsquo;s why I didn\u0026rsquo;t choose Clean Architecture—it\u0026rsquo;s too bulky for my target users. Think about it: for projects done solo or with a small team of 2-3 people, 99.99% of the time you won\u0026rsquo;t need an Abstract Repository for multiple implementations. Andrea—a well-known Flutter developer—also mentioned this in Flutter App Architecture: The Repository Pattern.\nAfter weighing the options, I chose the MVVM (Model - View - ViewModel) architecture, simply using ViewModel to separate logic from UI.\nI also chose Riverpod, a state management solution for flexible state handling. I know most of you use BloC more, but I\u0026rsquo;m not judging which is better—it\u0026rsquo;s just that Riverpod lets me write shorter code than BloC.\nNext is the Backend. I know most solo developers will integrate Firebase, but it has one issue\u0026hellip; EXPENSIVE (when your project starts to scale). So I chose Supabase, similar to Firebase but CHEAPER. I\u0026rsquo;ve already integrated setup code and some authentication functions.\nIf you want to monetize your app, you can\u0026rsquo;t miss RevenueCat, which helps manage in-app purchases and subscriptions.\nThere\u0026rsquo;s also Dark/Light Theme, Localization, routing, local storage, analytics, crashlytics\u0026hellip; all ready to go.\n📚 Libraries Used Purpose Libraries State flutter_riverpod, riverpod_annotation Auth \u0026amp; Backend supabase_flutter, google_sign_in, sign_in_with_apple Navigation go_router UI/UX google_fonts, flutter_svg, shimmer, lottie Storage shared_preferences, sqflite HTTP dio, connectivity_plus Utils uuid, envied, easy_localization Monetization purchases_flutter, in_app_purchase Analytics firebase_analytics, firebase_crashlytics 🏗 Project Architecture For project architecture, I chose Feature-first (layer folders inside feature folders). For each feature like authentication, onboarding\u0026hellip; I create a folder inside features. Then inside that folder, I create layer folders like model, repository, ui.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 lib/ ├── constants/ # Constants, global config ├── environment/ # Environment variables ├── extensions/ # Extension/helper methods ├── features/ # Feature modules by folder │ ├── authentication/ │ ├── model/ │ ├── repository/ │ ├── ui/ │ ├── onboarding/ │ ├── home/ │ ├── profile/ │ ├── premium/ ├── routing/ # Route config with go_router ├── theme/ # UI config └── utils/ # Common utilities You\u0026rsquo;ll notice there are no layers like domain or data.\nUsually with Clean Architecture, your domain would have model, abstract repository, use case, but now, without needing abstract repository and use case, I can simplify it to just model.\nAs for data, for features that only need to access remote or local data, I\u0026rsquo;ll call functions directly in the repository. For features needing both types of data, I\u0026rsquo;ll consider creating a data source if necessary.\n🎉 Conclusion The vibe coding movement is growing, but I still want to vibe code with control. With this base project, I can guide AI to code the way I want. If it goes off track, I can quickly adjust.\nAs mentioned from the start, this project is for indie hackers and solo developers who want to launch an MVP quickly, helping you focus on business logic instead of spending all day setting up and writing boilerplate. So it might not be suitable for your team if you have many members and need a base project with standard Clean Architecture.\nIf you find it useful, don\u0026rsquo;t hesitate to give me a star!\nGitHub Link: https://github.com/namanh11611/flutter_mvvm_riverpod\n","date":"2025-05-11T00:00:00+07:00","image":"https://namanh11611.github.io/p/flutter-mvvm-riverpod/fmr_hu_93b1567eadced1c2.webp","permalink":"https://namanh11611.github.io/p/flutter-mvvm-riverpod/","title":"Flutter MVVM Riverpod Starter: Build Apps Lightning Fast for Vibe Coders"},{"content":"Photo by Frames For Your Heart on Unsplash\nIn the programming world, Builder Pattern is known as one of the popular design patterns in the Creational Pattern group, helping to create complex objects in a flexible and readable way. You may have encountered it in your code but not noticed. In older programming languages, implementing the Builder Pattern could be lengthy and complicated, but newer languages have made it much easier. Today, let\u0026rsquo;s explore the journey of Builder Pattern from 60 lines of Java code to just 1 line in Kotlin.\nWhat is the Builder Pattern? In software development, there are many classes that need to be initialized with various properties. For example, a House class might have properties like wall, door, window, roof, garage\u0026hellip;\nNormally, to initialize an instance of this class, you might write:\n1 House myHouse = new House(4, 2, 4, 1, 1); Reading this code, you might wonder what 4 and 2 mean. If you use a regular constructor or setters for each property, you may encounter issues like:\nHard to read and easy to confuse: Calling a constructor with many parameters without knowing their meaning can be confusing. Prone to errors: If the order of parameters is wrong, the compiler may not catch it if the parameters have the same type. Lack of flexibility: If some properties are optional, you\u0026rsquo;ll need many overloaded constructors or setters, making the code messy. Risk of creating objects in an invalid state: If not all necessary setters are called, the object may lack required data. That\u0026rsquo;s why the Builder Pattern was created to solve these problems by moving the code for initializing properties out of the class and into another class called the Builder. You can see the illustration below:\nSeparating the code into HouseBuilder allows you to create objects step by step, clearly and flexibly. You can choose which properties to set and which to skip.\nLet\u0026rsquo;s look at the implementation in Java next.\nJava: Full Builder Pattern Leaving houses aside, let\u0026rsquo;s look at another classic example: the User class.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 public class User { private final String name; private final int age; private final String address; private final boolean isVerified; private final boolean isDeleted; private User(Builder builder) { this.name = builder.name; this.age = builder.age; this.address = builder.address; this.isVerified = builder.isVerified; this.isDeleted = builder.isDeleted; } public static class Builder { private String name; private int age; private String address; private boolean isVerified; private boolean isDeleted; public Builder setName(String name) { this.name = name; return this; } public Builder setAge(int age) { this.age = age; return this; } public Builder setAddress(String address) { this.address = address; return this; } public Builder setVerified(boolean verified) { this.isVerified = verified; return this; } public Builder setDeleted(boolean deleted) { this.isDeleted = deleted; return this; } public User build() { return new User(this); } } } User user = new User.Builder() .setName(\u0026#34;Henry Techie\u0026#34;) .setAge(30) .setAddress(\u0026#34;Hanoi\u0026#34;) .setVerified(true) .setDeleted(false) .build(); As you can see, it takes 60 lines of code to set up the Builder Design Pattern in Java. For classes with more properties, the boilerplate code increases.\nSimplified in Kotlin With Kotlin and other modern languages (Python, Swift, Dart\u0026hellip;), things are simplified thanks to Named Arguments.\nKotlin natively supports named arguments and default values, so you don\u0026rsquo;t need to implement the Builder Pattern manually:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 data class User( val name: String, val age: Int, val address: String = \u0026#34;\u0026#34;, val isVerified: Boolean = false, val isDeleted: Boolean = false ) val user = User( name = \u0026#34;Henry Techie\u0026#34;, age = 30, address = \u0026#34;Hanoi\u0026#34; ) val user = User( name = \u0026#34;Henry Techie\u0026#34;, age = 30, isVerified = true ) Tada\u0026hellip; No need for a builder class, no need for 60 lines of setters. Just 1 line of code to create an object with flexible parameters. You can declare or skip address, isVerified, and isDeleted as you wish.\nConclusion From the full Builder Pattern in Java to data class and named arguments in Kotlin, we\u0026rsquo;ve witnessed a wonderful simplification. That\u0026rsquo;s why I said Builder Pattern appears in every breath of our code, you just haven\u0026rsquo;t noticed it yet.\nHave a great weekend!\n","date":"2025-05-10T00:00:00+07:00","image":"https://namanh11611.github.io/p/design-pattern-builder/builder_hu_7c0f5b1a827702db.webp","permalink":"https://namanh11611.github.io/p/design-pattern-builder/","title":"Design Pattern: The Journey of Builder Pattern - from 60 lines of Java to 1 line of Kotlin"},{"content":"Photo by AltumCode on Unsplash\nWill AI Replace Developers Soon? Many people have asked me whether AI is about to replace developers. My answer, as of now, is NO. There still needs to be someone to verify the code that AI produces.\nHowever, the tech industry evolves rapidly. Technologies that are hot today might become obsolete tomorrow. For example, six years ago when I graduated, coding for Android was primarily done using Java. But now, if you only know Java without Kotlin, it’s incredibly difficult to find a job.\nSo, will AI replace developers in the next 5 years or 10 years? I can’t say for certain.\nAI is Changing the Way We Work That said, it’s clear that AI is transforming how we work.\nIn the past, a developer’s primary job was to convert requirements and designs into code. Tech leads and seniors would spend additional time in meetings to clarify requirements, but junior developers spent most of their time coding. It could take months or even years to deliver a product.\nRecently, I’ve been working on a new personal project. Today marks day 10, but with the help of Cursor, the code I’ve written or directly modified accounts for just 5%.\nIn the past, using ChatGPT, you could only generate small components and then copy them into your project. Even then, you’d need to spend a lot of time fixing them to fit. But with Cursor, it’s different. It understands the project context. By providing it with a base project and some pre-written files, it can replicate 99% of the format, and the code is almost ready to use with little or no modifications.\nCursor acts as an AI Agent: after generating code, it even creates new files, runs the project to check for errors, and fixes them automatically before asking me to review the changes.\nMy role now resembles that of a technical lead: I define tasks for Cursor, review its output, and ask it to fix anything suboptimal. Once I’m satisfied, I merge the code.\nBut to review AI-generated code, you must understand what each line means and identify what isn’t optimized so you can instruct it to make corrections. Blindly applying AI-generated solutions can be risky. If bugs arise later, you may not know how to fix them.\nThe Reality Currently, a barrier to adoption in large companies is their hesitation to use AI due to data security concerns. Additionally, their codebases are vast, and using general AI tools to train on them can be token-intensive. AI has limitations in the number of tokens it can retain.\nFor me, AI isn’t much help in my company projects. However, for small companies or indie hackers, these barriers are less significant, creating opportunities to accelerate software development. Imagine cutting down the time to build an MVP from months to just weeks, or even days.\nThe numbers don’t lie—traffic to StackOverflow is declining. Developers are now asking AI for help more often than they use Google.\nReturning to the question at the start: if a team once required 3 seniors and 7 juniors, but after adopting AI, productivity improves and the team now only needs 3 seniors and 4 juniors, hasn’t AI effectively replaced 3 juniors? More accurately, those who effectively leverage AI are taking over the roles of those who don’t.\nConclusion As the new year begins, I’m reflecting on my work so that future me can look back on this. During the First Industrial Revolution, machines replaced humans in tedious manual labor, freeing us to focus our intellect on other tasks. Let’s see where AI will take us in the next 5 years or 10 years.\n","date":"2025-01-01T00:00:00+07:00","image":"https://namanh11611.github.io/p/ai-change-work/ai_change_work_hu_263b09d000dc13fa.webp","permalink":"https://namanh11611.github.io/p/ai-change-work/","title":"AI is Changing How Software Engineers Work"},{"content":"Photo by Dillon Shook on Unsplash\nHave you ever struggled to choose one of the seven types of providers in Riverpod for specific use cases in your project? For instance, the documentation explains that both NotifierProvider and StateNotifierProvider are used when:\nA complex state object that is immutable except through an interface.\nOn the other hand, ChangeNotifierProvider are not recommended for scalable applications.\nWhat is going on??? The author really knows how to make developers feel confused…\nBut now, Remi Rousselet has introduced a new way to use Riverpod with code generation, making developers\u0026rsquo; lives a bit easier.\nSyntax In simple terms, code generation in Riverpod allows us to declare providers using the @riverpod annotation, and most of the code is automatically generated using Dart\u0026rsquo;s built-in build_runner tool.\nInstead of defining providers as before:\n1 2 3 4 final fetchUserProvider = FutureProvider.autoDispose.family\u0026lt;User, int\u0026gt;((ref, userId) async { final json = await http.get(\u0026#39;api/user/$userId\u0026#39;); return User.fromJson(json); }); Now, you only need to write:\n1 2 3 4 5 @riverpod Future\u0026lt;User\u0026gt; fetchUser(FetchUserRef ref, {required int userId}) async { final json = await http.get(\u0026#39;api/user/$userId\u0026#39;); return User.fromJson(json); } Instead of deliberating over which of the seven providers to use, you can now use the following table to quickly choose the appropriate provider for your use case:\nFunctional (Can’t perform side-effects using public methods) Class-Based (Can perform side-effects using public methods) Sync Async - Future Async - Stream keepAlive In this new approach, all providers are auto-dispose by default, meaning their state is destroyed when no listeners observe them. This is the opposite of the old approach (where you had to explicitly add autoDispose, and the default was no dispose).\nTo disable auto-dispose and keep your provider alive, use:\n1 @Riverpod(keepAlive: true) Parameters As seen in the earlier example, adding parameters to a provider is now as straightforward as adding parameters to a regular function. There’s no need to use family like in the old approach.\nFor functional providers, parameters are added directly to the function:\n1 2 3 4 5 6 7 8 @riverpod String example( ExampleRef ref, int param1, { String param2 = \u0026#39;foo\u0026#39;, }) { return \u0026#39;Hello $param1 \u0026amp; param2\u0026#39;; } For class-based providers, parameters are added to the build method:\n1 2 3 4 5 6 7 8 9 10 11 12 @riverpod class Example extends _$Example { @override String build( int param1, { String param2 = \u0026#39;foo\u0026#39;, }) { return \u0026#39;Hello $param1 \u0026amp; param2\u0026#39;; } // Add methods to mutate the state } Advantages Currently, using code generation or the old approach is optional. If you’re considering why you should switch, here are some reasons provided by the author:\nBetter syntax, more readable/flexible, and with a reduced learning curve. No need to worry about the type of provider. Write your logic, and Riverpod will pick the most suitable provider for you. The syntax no longer looks like we\u0026rsquo;re defining a \u0026ldquo;dirty global variable\u0026rdquo;. Instead we are defining a custom function/class. Passing parameters to providers is now unrestricted. Instead of being limited to using .family and passing a single positional parameter, you can now pass any parameter. This includes named parameters, optional ones, and even default values. Stateful hot-reload of the code written in Riverpod. Better debugging, through the generation of extra metadata that the debugger then picks up. Some Riverpod features will be available only with code generation. Disadvantages However, when applied to real-world projects, there are some drawbacks to consider.\nCurrently, as code generation is relatively new, few projects have adopted it, making it hard to find reference source code. For the most part, you’ll rely on Riverpod’s documentation during development.\nIn this AI-driven era, developers often use tools to generate code. With limited adoption, most tools generate Riverpod code in the old style. But don’t worry! Android Studio has the Flutter Riverpod Snippets plugin, which helps you write code faster. Just type riverpod, and it will suggest the four main provider types.\nThese drawbacks are temporary. As code generation becomes more popular, these issues will be resolved. So there’s no need to worry too much.\nReference https://riverpod.dev/docs/concepts/about_code_generation ","date":"2024-10-11T00:00:00+07:00","image":"https://namanh11611.github.io/p/riverpod/riverpod_hu_1fc05793d40a1e68.webp","permalink":"https://namanh11611.github.io/p/riverpod/","title":"Using Code Generation Providers in Flutter Riverpod to Simplify Life"},{"content":"Photo by Etienne Girardet on Unsplash\nIn Android, performing heavy tasks like network requests or database operations on the main thread can cause the app to freeze or crash. To ensure smoother app performance, these tasks should be executed on a background thread to avoid blocking the main thread. For instance, when a user clicks the Submit button on the main thread, the network request will be processed on a background thread, and the result will be sent back to the main thread. Android provides tools such as Looper, MessageQueue, and Handler to manage concurrent tasks and handle message passing between threads.\nWait a second! Isn’t Kotlin Coroutines already solving these problems? That’s true; nowadays, Kotlin Coroutines are widely used for such use cases. However, in certain projects, for example Android Automotive, the trio of Looper, MessageQueue, and Handler is still essential.\nIn this article, I’ll explain the role and responsibilities of each component and how they interact with one another. Since these components are closely intertwined, you might need to refer back to earlier sections to fully grasp the concepts. Take your time!\nLooper Looper is a class that manages the message loop for a thread, with each thread having exactly one Looper. If we dive into the Android SDK code, we can see the Looper class defined as follows:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 public final class Looper { // Looper contains the MessageQueue final MessageQueue mQueue; // The relationship between Looper and Thread is one-to-one final Thread mThread; public static void prepare() { prepare(true); } private static void prepare(boolean quitAllowed) { // Each thread can have only one Looper if (sThreadLocal.get() != null) { throw new RuntimeException(\u0026#34;Only one Looper may be created per thread\u0026#34;); } sThreadLocal.set(new Looper(quitAllowed)); } private Looper(boolean quitAllowed) { mQueue = new MessageQueue(quitAllowed); mThread = Thread.currentThread(); } } By default, threads are not associated with any message loop. To create a message loop, we need to call the Looper.prepare() method, as shown above. Then, we invoke the Looper.loop() method to process messages until the loop stops.\nHere’s an example of a Looper implementation:\n1 2 3 4 5 6 class LooperExampleThread extends Thread { public void run() { Looper.prepare(); Looper.loop(); } } MessageQueue MessageQueue is a data structure that holds a list of Message and Runnable objects to be processed. It operates on a FIFO (First-In-First-Out) basis. You can access the MessageQueue of the current thread using the Looper.myQueue() method.\nIn the Looper code above, you’ll notice that each Looper has exactly one MessageQueue:\n1 2 3 4 public final class Looper { // Looper contains the MessageQueue final MessageQueue mQueue; } Messages are not added directly to the MessageQueue. Instead, they are added through a Handler. The Looper continuously extracts and processes messages from the queue.\nHandler Handler is a class used to send and process Message and Runnable objects linked to a thread’s MessageQueue. Each Handler is associated with a specific thread and its MessageQueue.\nWhen creating a Handler, you must pass a Looper to its constructor. Here’s an example of a typical constructor:\n1 public Handler(@NonNull Looper looper) {} The MessageQueue we mentioned earlier belongs to the Looper passed here, and messages will be executed on the same thread as that Looper.\nSome commonly used methods of Handler include:\npost(Runnable) postAtTime(java.lang.Runnable, long) postDelayed(Runnable, Object, long) sendEmptyMessage(int) sendMessage(Message) sendMessageAtTime(Message, long) sendMessageDelayed(Message, long) Handler serves two main purposes:\nScheduling tasks to run in the future. You can use methods like ...AtTime or ...Delayed. Executing tasks on a different thread from the current one. As mentioned earlier, you can specify the desired thread by passing its Looper when initializing the Handler. Communication Between Components When a Message or Runnable is sent via a Handler, it is added to the MessageQueue. The Looper continuously checks the MessageQueue for new messages. Upon finding a message, the Looper extracts it from the queue and forwards it to the corresponding Handler for processing. The Handler processes the message on the thread it is associated with. Here’s an illustrative code example:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class ProcessingThread extends Thread { public Handler mHandler; public void run() { Looper.prepare(); // Looper.myLooper() return the Looper object // associated with the current thread mHandler = new Handler(Looper.myLooper()) { public void handleMessage(Message msg) { // Process received messages } }; Looper.loop(); } } // ClientThread has a reference to the mHandler object // of ProcessingThread class ClientThread extends Thread { private void sendMessageExample() { Message msg = Message.obtain(mHandler, 1); msg.obj = \u0026#34;New message\u0026#34;; mHandler.sendMessage(msg); } private void sendRunnableExample() { mHandler.post(new Runnable() { @Override public void run() { // Task executed on ProcessingThread } }); } } HandlerThread In practice, developers rarely create and manage threads and Loopers manually. Android provides HandlerThread, a special type of thread with a built-in Looper property. You can retrieve its Looper using the getLooper() method.\n1 2 3 4 HandlerThread thread = new HandlerThread(\u0026#34;ProcessingThread\u0026#34;); thread.start(); Looper looper = thread.getLooper(); Handler handler = new Handler(looper); Main Thread The Main thread (UI thread) in Android already has a built-in Looper, which can be accessed via Looper.getMainLooper(). A common example is creating a Handler to delay a task on the UI thread, as follows:\n1 2 3 4 5 6 7 Handler handler = new Handler(Looper.getMainLooper()); handler.postDelayed(new Runnable() { @Override public void run() { // Delayed task } }, 3000); Conclusion Looper, MessageQueue, and Handler are essential components of Android’s asynchronous processing system. They work together to facilitate efficient and safe inter-thread communication. Understanding their operations can help you build robust Android applications. Thank you for reading!\nReference https://developer.android.com/reference/android/os/Looper https://developer.android.com/reference/android/os/MessageQueue https://developer.android.com/reference/android/os/Handler ","date":"2024-10-10T00:00:00+07:00","image":"https://namanh11611.github.io/p/looper-message-queue-handler/looper_message_queue_handler_hu_3a5c44d0c0799128.webp","permalink":"https://namanh11611.github.io/p/looper-message-queue-handler/","title":"All About Looper, MessageQueue, and Handler in Android"},{"content":"Photo by Felix Mittermeier on Unsplash\nGit Branching Strategy refers to the way we create branches, merge branches, and decide which branches are used for releases.\nWhen starting a project, beyond setting up the environment and building a solid codebase, selecting the right Git Branching Strategy is crucial. A wrong choice can lead to significant challenges. The right strategy helps the team manage and maintain source code effectively, reduce conflict resolution time, and ensure production code remains stable.\nOver time, various strategies have emerged. This article explores some popular Git Branching Strategies like Gitflow, GitHub Flow, GitLab Flow, and Trunk-Based Development. Finally, we’ll discuss how to choose the right strategy for your project.\nGitflow Gitflow, introduced by Vincent Driessen, is well-suited for projects with clear and complex release cycles. Gitflow uses multiple branch types to manage the development and release phases.\nIn this flow, there are two main branches: master and develop. The master branch contains stable code ready for release, while develop contains the latest changes for the next release. It’s the main branch for feature integration.\nAdditionally, there are feature branches that are checkout from develop and used to develop new features. Once completed, they are merge back into develop.\nWhen ready for release, a branch is checked out from develop to a release branch with the corresponding version to prepare for the release. Bug fixes can be added as commits on this branch. Once finalized, the release branch is merge into both master and develop to keep the two main branches updated.\nFinally, there are hotfix branches. When production code encounters a critical bug that needs an immediate fix, a hotfix branch is checkout from master for the fix. Similar to release branches, hotfix branches must also be merge into both master and develop.\nAdvantages Provides a clear structure, ideal for large projects. Efficiently manages development and release phases with versioned release branches. Hotfix branches allow quick fixes without disrupting ongoing development. Disadvantages Complex and requires multiple branches and merges. For example, each release or hotfix branch needs to be merged into both master and develop. Unsuitable for projects requiring CI/CD. Challenging for small teams due to its cumbersome nature. GitHub Flow GitHub Flow is a lightweight, simple strategy ideal for CI/CD and commonly used in open-source projects or small teams.\nUnlike Gitflow, it has a single main branch, main, which contains thoroughly tested and stable code ready for production.\nFeatures are developed in feature branches, tested, reviewed, and merged into main via pull requests.\nAdvantages Simple and easy to understand, making it quick to implement. Perfect for CI/CD workflows, ensuring the main branch is always deployable. Fewer branches mean reduced conflicts and merge errors. Disadvantages Lacks the structure of Gitflow. Unsuitable for large projects or those requiring support for multiple versions. Does not define clear processes for releases or bug fixes. GitLab Flow GitLab Flow combines elements of Gitflow and GitHub Flow. It introduces environment branches like staging and production, making it suitable for CI/CD and tightly integrated with GitLab’s CI/CD tools.\nSimilar to GitHub Flow, GitLab Flow works directly with the primary branch, main, which contains stable source code ready for release. This flow also includes feature branches for developing new features.\nWhen the code on the main branch is ready for testing, we merge it into the staging branch. After testing and confirming it is ready for deployment, we merge the code from the staging branch into the production branch. GitLab Flow often uses release branches, such as release/v1 and release/v2, to independently manage and deploy different versions of the application.\nHowever, when there is a bug in production, you need to merge the code into the main branch first, then merge or cherry-pick it into other branches following the above process.\nAdvantages Simpler than Gitflow, but more structured than GitHub Flow. Well-suited for CI/CD projects with multiple environments. Supports independent management of different application versions using release branches. Disadvantages Best suited for GitLab and its CI/CD tools. Requires careful setup to leverage its full potential. Not ideal for projects without CI/CD requirements. Trunk-Based Development For a detailed discussion, refer to my article: Trunk-Based Development - A Git Workflow to Reduce Merge Conflicts. Trunk-Based Development (TBD) is a strategy where all developers work on a single main branch, typically main. Changes are continuously and quickly committed to this branch, minimizing the lifespan of feature branches.\nAdvantages Encourages CI and minimizes merge conflicts. Ideal for Agile and DevOps projects requiring CD. Easy to manage and track the codebase. Disadvantages Higher risk of directly committing errors to the main branch. Requires robust code reviews and automation tests to maintain stability. Unsuitable for large, distributed teams. Choosing the Right Strategy There’s no one-size-fits-all solution. The choice of Git branching strategy depends on factors like project scale, team structure, and development requirements. Below are some suggestions:\nProject Type Team Size Recommended Strategy Small to medium projects with continuous delivery Small, Medium GitHub Flow, TBD Scheduled and periodic releases Medium GitFlow, GitLab Flow CI/CD projects with multiple environments Medium, Large GitLab Flow Long-term maintenance projects Large GitFlow Each strategy has its pros and cons. The key is selecting one that aligns with your team’s workflow and project requirements. Doing so optimizes productivity and minimizes risks in source code management.\nReferrence https://nvie.com/posts/a-successful-git-branching-model https://docs.github.com/en/get-started/using-github/github-flow https://about.gitlab.com/topics/version-control/what-is-gitlab-flow https://www.gitkraken.com/learn/git/best-practices/git-branch-strategy https://www.geeksforgeeks.org/branching-strategies-in-git https://www.abtasty.com/blog/git-branching-strategies ","date":"2024-09-08T00:00:00+07:00","image":"https://namanh11611.github.io/p/git-branching-strategy/strategy_hu_8f54243dcfa96e4e.webp","permalink":"https://namanh11611.github.io/p/git-branching-strategy/","title":"Gitflow, GitHub Flow, GitLab Flow, Trunk-Based Development: Which Git Branching Strategy is Right for You?"},{"content":"Photo by Ana Cruz on Unsplash\nTiếp nối serie Kotlin cheat sheet, chúng ta cùng đi đến với cheat sheet cuối cùng dành cho SharedFlow và StateFlow.\nSharedFlow và StateFlow là hai loại flow đặc biệt trong Kotlin Flow, cung cấp các tính năng mạnh mẽ cho việc chia sẻ trạng thái và sự kiện giữa các thành phần khác nhau trong ứng dụng. Trong phần cuối của loạt bài viết này, chúng ta sẽ tìm hiểu sâu về cách sử dụng SharedFlow và StateFlow, những lợi ích của chúng, và cách tích hợp vào ứng dụng Android của bạn để xử lý luồng dữ liệu một cách hiệu quả và mượt mà hơn.\nBạn có thể đọc toàn bộ serie tại đây:\nKotlin Coroutines cheat sheet nâng cao dành cho Android Engineer Kotlin Flow cheat sheet phần 1: Channel Kotlin Flow cheat sheet phần 2: Flow Kotlin Flow cheat sheet phần 3: SharedFlow và StateFlow SharedFlow Nguyên tắc chính Là một hot stream. Có thể có nhiều receiver và tất cả chúng sẽ nhận được cùng một giá trị. Hữu ích khi bạn cần truyền các giá trị tới nhiều consumer hoặc muốn chia sẻ trạng thái/sự kiện giữa các phần khác nhau trong ứng dụng của mình. Không bao giờ hoàn thành cho đến khi chúng ta close toàn bộ scope. Có phiên bản có thể thay đổi MutableSharedFlow cho phép chúng ta cập nhật state bằng cách emit các giá trị mới với suspend function emit. Chúng ta cũng có thể sử dụng phiên bản non suspend tryEmit. Hỗ trợ cấu hình replay và tràn buffer. Tất cả các phương thức của shared flow đều thread-safe và có thể được gọi một cách an toàn từ các coroutine đồng thời mà không cần đồng bộ hóa bên ngoài. Các tham số cấu hình Kotlin đang cung cấp cho chúng ta một phương thức hữu ích để tạo MutableSharedFlow và xác định cách chúng ta muốn buffer hoạt động:\n1 2 3 4 5 6 7 8 9 public fun \u0026lt;T\u0026gt; MutableSharedFlow( // số lượng giá trị được replayed cho subscriber mới replay: Int = 0, // số lượng giá trị được lưu vào buffer ngoài `replay` extraBufferCapacity: Int = 0, // hành động khi tràn buffer // Các giá trị: SUSPEND, DROP_OLDEST, DROP_LATEST onBufferOverflow: BufferOverflow = BufferOverflow.SUSPEND ): MutableSharedFlow\u0026lt;T\u0026gt; shareIn Biến đổi Flow thành SharedFlow. Hữu ích khi chúng ta muốn biến một flow thành nhiều flow Yêu cầu coroutine scope làm tham số đầu tiên (scope) để bắt đầu coroutine và collect phần tử của flow. Tham số thứ hai started xác định thời điểm SharedFlow sẽ bắt đầu listen giá trị do flow emit. Nó lấy một object SharingStarted. Tham số thứ ba, replay, (mặc định là 0) xác định số lượng giá trị được replay cho subscriber mới. SharingStarted option SharingStarted.Eagerly: bắt đầu listen các phần tử ngay lập tức và không bao giờ dừng lại cho đến khi scope bị cancel. SharingStarted.Lazily: bắt đầu listen khi subscriber đầu tiên xuất hiện và không bao giờ dừng cho đến khi scope bị cancel. SharingStarted.WhileSubscribed(): bắt đầu listen khi subscriber đầu tiên xuất hiện và dừng ngay khi subscriber cuối cùng biến mất. Chúng ta config delay (tính bằng mili giây) giữa thời điểm subscriber cuối cùng biến mất và thời điểm dừng coroutine bằng tham số stopTimeoutMillis. Lưu ý về WhileSubscribed: nếu bạn mở một Intent mới từ màn hình của mình, chẳng hạn như ứng dụng máy ảnh, màn hình của bạn sẽ bị tạm dừng và do đó SharedFlow của bạn sẽ không còn subscriber nữa và sẽ ngừng emit. Khi quay lại màn hình ban đầu, bạn sẽ subscribe lại màn hình của mình và có thể chạy lại tác vụ bên trong flow của mình. Điều này có thể gây ra sự cố hoặc trigger lại một tác vụ không cần thiết.\nLưu ý về SharingStarted.Eagerly và SharingStarted.Lazily: nếu bạn đang sử dụng ViewModelScope hoặc LifecycleScope thì SharedFlow sẽ ngừng gửi các phần tử khi màn hình bị destroy.\nBiến flow thành SharedFlow 1 2 3 4 5 6 7 8 9 10 11 12 13 14 // từ một viewModel hoặc một class có lifeCycleScope myFlow.shareIn( scope = viewModelScope started = SharingStarted.Lazily ) // từ một class không có lifeCycleScope (repository hoặc use case) suspend fun myFunction() = coroutineScope { myFlow.shareIn( scope = this, started = SharingStarted.Lazily ) } Use case: Observe database thay đổi từ nhiều vị trí Nếu bạn sử dụng Room cho cơ sở dữ liệu của mình thì bạn có thể đã biết rằng nó đã hỗ trợ Flow. Vì vậy, bạn có thể observe các thay đổi trong database của mình và nhận dữ liệu mới ngay khi có. Nhưng việc đọc dữ liệu từ disk có thể khá nặng. Nếu cần nhận dữ liệu ở nhiều màn hình, bạn có thể sử dụng SharedFlow để tránh phải fetch dữ liệu cho mọi màn hình.\nTrong ví dụ này, mình sẽ trình bày cách để fetch một UserSettings một lần nhưng vẫn nhận được update trên nhiều màn hình:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 // DAO đơn giản để fetch dữ liệu từ Room @Dao interface UserSettingsDao { // fetch tất cả user settings từ database và emit một flow @Query(\u0026#34;SELECT * FROM user_settings\u0026#34;) fun getAll(): Flow\u0026lt;List\u0026lt;UserSettings\u0026gt;\u0026gt; } class UserSettingsRepository @Inject constructor( private val dao: UserSettingsDao ) { // Chúng ta chỉ đọc từ DB một lần và tất cả receiver sẽ nhận được // data được tính toán ở đây. suspend fun getAll(): SharedFlow\u0026lt;List\u0026lt;UserSettings\u0026gt;\u0026gt; = coroutineScope { dao.getAll.shareIn( // truyền xuống scope scope = this, // chỉ bắt đầu emit khi chúng ta có receiver started = SharingStarted.Lazily, // replay phần tử mới nhất khi một receiver mới subscribe nó replay = 1 ) } } StateFlow Nguyên tắc chính Hoạt động tương tự như a SharedFlow với tham số replay được đặt thành 1. Luôn chỉ lưu trữ một giá trị. Giá trị được lưu trữ có thể được truy cập bằng thuộc tính value. Chúng ta cần đặt giá trị ban đầu trong constructor. Sự thay thế hiện đại cho LiveData. Sẽ không emit phần tử mới nếu nó bằng phần tử trước đó. Thiết lập và đọc một giá trị 1 2 3 4 val state = MutableStateFlow(\u0026#34;A\u0026#34;) // giá trị ban đầu là A state.value = \u0026#34;B\u0026#34; // đặt giá trị thành B state.value = \u0026#34;B\u0026#34; // giá trị này sẽ không emit phần tử mới vì giá trị đã là B val myValue = state.value // đọc giá trị từ state, ở đây là \u0026#34;B\u0026#34; stateIn Chuyển đổi một flow thành một StateFlow. Cần xác định scope. Có 2 loại, một loại suspend và một loại không suspend stateIn suspend suspend cho đến khi phần tử đầu tiên của flow được emit và giá trị mới được tính toán 1 2 3 suspend fun myFunction() = coroutineScope { myFlow.stateIn(this) } stateIn not suspend Yêu cầu một giá trị ban đầu trong tham số initialValue của nó. Tham số thứ hai của nó là started và mong đợi một phần tử SharingStarted. 1 2 3 4 5 myFlow.stateIn( scope = viewModelScope, started = SharingStarted.Lazily, initValue = \u0026#34;A\u0026#34; ) Use case: Emit data từ viewModel sang view Đoạn code về cách chuyển flow thành StateFlow để emit state từ view model sang view mà đang observe:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class MyViewModel @Inject constructor( private val fetchDataUseCase: FetchDataUseCase ) : ViewModel() { val myState: StateFlow\u0026lt;MyState\u0026gt; = fetchDataUseCase.dataState .map { when (it) { is FetchDataUseCase.FetchDataState.Loading -\u0026gt; MyState.Loading is FetchDataUseCase.FetchDataState.Success -\u0026gt; MyState.Success(it.data) is FetchDataUseCase.FetchDataState.Error -\u0026gt; MyState.Error(it.message) } } // chuyển flow thành state flow .stateIn( // đặt scope thành viewModel vì vậy chúng ta sẽ stop // listening khi viewModel bị destroy scope = viewModelScope, started = SharingStarted.WhileSubscribed(5_000), initialValue = MyState.Loading ) sealed interface MyState { data object Loading : MyState data class Success(val data: List\u0026lt;String\u0026gt;) : MyState data class Error(val message: String) : MyState } } @Composable fun MyScreen(viewModel = MyViewModel()) { val state = viewModel.myState.collectAsStateWithLifecycle() when (state) { is MyState.Loading -\u0026gt; // show loading view is MyState.Success -\u0026gt; // show success view is MyState.Error -\u0026gt; // show error view } } Cảm ơn bạn đã đồng hành cùng mình đến hết serie Kotlin cheat sheet này. Hy vọng những kiến thức hữu ích này sẽ giúp bạn tự tin hơn khi làm việc với Kotlin Coroutines và Flow.\nReference https://medium.com/@galou.minisini/advanced-kotlin-flow-cheat-sheet-for-android-engineer-cb8157d4f848 ","date":"2024-08-18T06:00:00+07:00","image":"https://namanh11611.github.io/p/kotlin-flow-cheat-sheet-3/cheat_sheet_hu_dcb8eedc627a97f6.webp","permalink":"https://namanh11611.github.io/p/kotlin-flow-cheat-sheet-3/","title":"Kotlin Flow cheat sheet phần 3: SharedFlow và StateFlow"},{"content":"Photo by Ana Cruz on Unsplash\nTiếp nối serie Kotlin cheat sheet, chúng ta cùng đi đến với cheat sheet tiếp theo dành cho Flow.\nKotlin Flow là một API mạnh mẽ giúp quản lý luồng dữ liệu bất đồng bộ một cách rõ ràng và dễ dàng. Trong phần 2 này, chúng ta sẽ khám phá Flow từ cơ bản đến nâng cao, tìm hiểu cách tạo, chuyển đổi và thu thập các luồng dữ liệu, cũng như các best practice để áp dụng trong dự án Android của bạn.\nBạn có thể đọc toàn bộ serie tại đây:\nKotlin Coroutines cheat sheet nâng cao dành cho Android Engineer Kotlin Flow cheat sheet phần 1: Channel Kotlin Flow cheat sheet phần 2: Flow Kotlin Flow cheat sheet phần 3: SharedFlow và StateFlow Flow Nguyên tắc chính Là một cold stream. Hỗ trợ sẵn structured concurrency. Tác vụ cuối cùng của flow được gọi là tác vụ terminal (collect, first… ). Một flow có thể có các tác vụ trung gian để sửa đổi flow (map, onEach, flatMapLastest… ). Terminal operation là suspend và yêu cầu một scope. Các Exception chưa được bắt sẽ ngay lập tức cancel một flow và collect sẽ throw lại Exception đó. Theo mặc định, context của flow sẽ lấy từ context mà collect được gọi. Kết hợp các flow với nhau merge, combine và zip là các hàm trung gian cho phép chúng ta kết hợp 2 (hoặc nhiều) flow thành 1. Vậy điểm khác biệt chính giữa 3 hàm đó là gì?\nmerge Không sửa đổi bất kỳ phần tử nào. Các phần tử được emit ngay khi chúng được tạo ra, chúng ta không đợi flow khác để tạo ra giá trị. Sử dụng nó khi bạn có nhiều nguồn event sẽ tạo ra cùng một action. flowA emit: 1\nflowB emit: 2\nflowA emit: 3\nmerge(flowA, flowB) tạo ra 1, 2, 3\nzip Kết hợp các phần tử từ các flow khác nhau để tạo ra giá trị mới. Chúng ta cần một hàm để xác định cách các phần tử được kết hợp với nhau. Chúng ta cần đợi mỗi flow emit một giá trị để có thể tạo cặp. Các phần tử chỉ có thể là một phần của một cặp. Các phần tử còn lại không có cặp sẽ bị mất. flowA emit: 1\nflowB emit: 2\nflowA emit: 4\nflowA.zip(flowB) {fA, fB -\u0026gt; fA + fB } tạo ra 3 (1+2 = 3, còn 4 từ flowA sẽ bị loại bỏ)\ncombine Kết hợp các phần tử từ các flow khác nhau để tạo ra giá trị mới. Chúng ta cần một hàm xác định cách các phần tử được kết hợp với nhau. Chúng ta cần đợi flow chậm hơn emit giá trị lần đầu tiên trước khi tạo phần tử mới. Khi một flow tạo ra một phần tử mới, nó sẽ thay thế phần tử trước đó và một giá trị mới sẽ được emit ngay lập tức (chúng ta không đợi mỗi flow emit một phần tử mới). flowA emit: 1\nflowB emit: 2\nflowA emit: 3\nflowA.combines(flowB) { fA, fB -\u0026gt; fA + fB } tạo ra 3 (1+2 = 3) rồi 5 (3+2 = 5, trong đó phần tử 3 đã thay thế cho 1 trước đó)\nSự khác biệt giữa fold và scan Cả fold và scan kết hợp tất cả các giá trị do một flow emit thành một phần tử bằng cách áp dụng thao tác kết hợp các giá trị lại với nhau.\nfold là một tác vụ terminal. Nó suspend cho đến khi flow hoàn thành và tạo ra giá trị cuối cùng scan là một tác vụ trung gian và tạo ra tất cả các giá trị trung gian 1 2 3 4 5 val myflow = flowOf(1, 2, 3, 4) myFlow.fold(0) { acc, newElement -\u0026gt; acc + newElement } // tạo ra 10 myFlow.scan(0) { acc, newElement -\u0026gt; acc + newElement } // tạo ra 1, 3 (1+2), 6 (3+3), 10 (6+4) flatMapConcat, flatMapMerge và flatMapLatest Chúng đều là những tác vụ trung gian Chúng biến đổi các phần tử được emit bởi flow ban đầu bằng cách áp dụng một flow khác lên phần tử đó và trả về một flow khác 1 myFlowA.flatMapConcat { fA -\u0026gt; myFlowB(fA) } // giá trị trả về do flow B tạo ra flatMapConcat Chuyển đổi từng giá trị được emit thành một flow và nối các flow kết quả một cách tuần tự. Emit hoàn toàn các giá trị từ inner flow đầu tiên trước khi bắt đầu flow tiếp theo. Use Case: khi bạn cần xử lý các flow bên trong theo thứ tự, không bị chồng chéo. flatMapMerge Chuyển đổi từng giá trị được emit thành một flow và hợp nhất các flow kết quả một cách đồng thời. Emit các giá trị từ tất cả các inner flow khi chúng có sẵn, có khả năng không theo thứ tự. Use Case: khi bạn muốn xử lý đồng thời các flow bên trong và không quan tâm đến thứ tự của các giá trị được emit. flatMapLatest Chuyển đổi từng giá trị được emit thành một flow, hủy các flow trước đó khi một giá trị mới đã được emit, và emit các giá trị từ flow mới nhất. Chỉ flow mới nhất được hoạt động và các giá trị của nó được emit. Các flow trước đó bị hủy bỏ. Use Case: khi bạn chỉ quan tâm đến giá trị mới nhất và muốn hủy các thao tác trước đó. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 data class User(val id: Int, val name: String) data class UserDetails(val userId: Int, val address: String) fun fetchUserData(): Flow\u0026lt;User\u0026gt; = flow { emit(User(1, \u0026#34;Alice\u0026#34;)) delay(500) emit(User(2, \u0026#34;Bob\u0026#34;)) delay(500) emit(User(3, \u0026#34;Charlie\u0026#34;)) } fun fetchUserDetails(userId: Int): Flow\u0026lt;UserDetails\u0026gt; = flow { delay(1000) // Giả lập network delay emit(UserDetails(userId, \u0026#34;$userId\u0026#39;s address\u0026#34;)) } // flatMapConcat fetchUserData() .flatMapConcat { user -\u0026gt; fetchUserDetails(user.id) } .collect { userDetails -\u0026gt; println(\u0026#34;flatMapConcat: ${userDetails}\u0026#34;) } // Mỗi thông tin user được trả về tuần tự. // flatMapConcat: UserDetails(userId=1, address=1\u0026#39;s address) // flatMapConcat: UserDetails(userId=2, address=2\u0026#39;s address) // flatMapConcat: UserDetails(userId=3, address=3\u0026#39;s address) // flatMapMerge fetchUserData() .flatMapMerge { user -\u0026gt; fetchUserDetails(user.id) } .collect { userDetails -\u0026gt; println(\u0026#34;flatMapMerge: ${userDetails}\u0026#34;) } // Thông tin user có thể bị xen kẽ do trả về đồng thời. // flatMapMerge: UserDetails(userId=1, address=1\u0026#39;s address) // flatMapMerge: UserDetails(userId=2, address=2\u0026#39;s address) // flatMapMerge: UserDetails(userId=3, address=3\u0026#39;s address) // flatMapLatest fetchUserData() .flatMapLatest { user -\u0026gt; fetchUserDetails(user.id) } .collect { userDetails -\u0026gt; println(\u0026#34;flatMapLatest: ${userDetails}\u0026#34;) } // Chỉ thông tin của user cuối cùng được trả về // do user mới sẽ cancel fetch trước đó. // flatMapLatest: UserDetails(userId=3, address=3\u0026#39;s address) Chuyển đổi function thành Flow 1 2 3 4 5 6 val function = suspend { // đây là biểu thức lambda suspend // định nghĩa hàm ở đây } function.asFlow() Hoặc\n1 2 3 4 5 suspend fun myFunction(): Flow\u0026lt;T\u0026gt; { // định nghĩa hàm ở đây } ::myFunction.asFlow() Tạo flow tạo ra các phần tử trước khi chúng ta subscribe Hàm channelFlow tạo ra sự kết hợp giữa flow và channel. Nó tạo ra một hot stream data nhưng cũng implement Flow interface.\n1 2 3 4 5 6 7 8 val myChannelFlow = channelFlow { val myData = // fetch dữ liệu tại đây send(myData) } suspend fun fetchData() { myData.first() } Sửa đổi context của Flow 1 2 3 4 5 myFlow.flowOn(Dispatchers.IO) // Hoặc myFlow.flowOn(CoroutineName( \u0026#34;NewName\u0026#34; )) Tránh lồng nhau khi khởi chạy flow 1 2 3 4 5 6 7 // thay vì viewModelScope.launch { myFlow.collect() } // làm như này myFlow.launchIn(viewModelScope) Cảm ơn các bạn đã đọc đến đây, cùng chờ đón những phần tiếp theo nhé.\nReference https://medium.com/@galou.minisini/advanced-kotlin-flow-cheat-sheet-for-android-engineer-cb8157d4f848 ","date":"2024-08-18T05:00:00+07:00","image":"https://namanh11611.github.io/p/kotlin-flow-cheat-sheet-2/cheat_sheet_hu_dcb8eedc627a97f6.webp","permalink":"https://namanh11611.github.io/p/kotlin-flow-cheat-sheet-2/","title":"Kotlin Flow cheat sheet phần 2: Flow"},{"content":"Photo by Ana Cruz on Unsplash\nSau khi làm việc với Kotlin Flows một thời gian, có thể bạn đã quen với các khái niệm cơ bản. Nhưng nếu chưa bao giờ sử dụng Channel, bạn sẽ không biết sự khác nhau giữa merge, combine và zip, hoặc có thể bạn chưa hiểu rõ SharedFlow và StateFlow cũng như cách sử dụng chúng.\nCheat sheet này hệ thống lại những kiến thức quan trọng mà mình đã góp nhặt được trong quá trình làm việc với Kotlin Flow. Nó được thiết kế để trở thành một tài liệu tham khảo hữu ích, giúp bạn giải quyết các tình huống phức tạp.\nTrong phần 1, chúng ta sẽ tìm hiểu chi tiết về Channel, cách thức hoạt động, và cách ứng dụng trong các trường hợp thực tế để giao tiếp giữa các coroutine một cách an toàn và hiệu quả.\nBạn có thể đọc toàn bộ serie tại đây:\nKotlin Coroutines cheat sheet nâng cao dành cho Android Engineer Kotlin Flow cheat sheet phần 1: Channel Kotlin Flow cheat sheet phần 2: Flow Kotlin Flow cheat sheet phần 3: SharedFlow và StateFlow Hot streams và Cold streams Hot streams Ví dụ: channel, Collections (List, Set… ). Bắt đầu ngay lập tức: bắt đầu emit các giá trị bất kể có subscriber hay không. Lưu các phần tử: chúng không cần phải tính toán lại và tất cả subscriber đều nhận được cùng một chuỗi giá trị. Cold streams Ví dụ: Sequence, Flow Bắt đầu theo yêu cầu: cold streams chỉ bắt đầu emit các giá trị khi subscriber chủ động đăng ký stream đó. Nguồn dữ liệu là lazy. Phát độc lập: mỗi subscriber nhận được chuỗi giá trị độc lập của riêng mình. Không có phần tử nào được lưu trữ. Channel Nguyên tắc chính Là một hot stream. Đảm bảo không có xung đột (không có vấn đề với trạng thái chia sẻ) và công bằng nên rất hữu ích khi các coroutine khác nhau cần liên lạc với nhau. Hỗ trợ bất kỳ số lượng sender và receiver. Mỗi giá trị gửi tới channel chỉ được nhận một lần. Nếu có nhiều receiver subscribe cùng lúc, các phần tử sẽ được phân bổ công bằng giữa các receiver. (Hàng đợi FIFO của receiver). Channel có 3 receiver, subscribe theo thứ tự: Receiver1, Receiver2, Receiver3.\nTất cả receiver đã subscribe channel.\nChannel emit ra 4 giá trị: \u0026ldquo;A\u0026rdquo;, \u0026ldquo;B\u0026rdquo;, \u0026ldquo;C\u0026rdquo; rồi \u0026ldquo;D\u0026rdquo;.\nReceiver1 nhận được \u0026ldquo;A\u0026rdquo; và \u0026ldquo;D\u0026rdquo;\nReceiver2 nhận được \u0026ldquo;B\u0026rdquo;\nReceiver3 nhận được \u0026ldquo;C\u0026rdquo;\nChúng có 2 suspend function là send và receive. receive bị suspend nếu không có phần tử nào trong channel và sẽ đợi một phần tử sẵn sàng để tiếp tục. send bị suspend nếu channel đạt đến capacity. Chúng ta cũng có thể sử dụng phiên bản không bị suspend là trySend và tryReceive, chúng trả về một ChannelResult (cho chúng ta biết thao tác có thành công hay không). Chúng cần được close thủ công sau khi chúng ta gửi xong dữ liệu hoặc khi xảy ra Exception: myChannel.close(). Nếu không, receive sẽ đợi các phần tử mãi mãi. Các loại channel capacity 1 2 3 4 5 6 7 val myChannel = Channel\u0026lt;Int\u0026gt;(capacity = 3) // hoặc val myChannel = produce(capacity = 3) { // emit các giá trị ở đây } Channel.UNLIMITED: buffer không giới hạn và send không bao giờ bị suspend. Channel.BUFFERED: buffer capacity là 64. Giá trị mặc định này có thể được override bằng thuộc tính hệ thống kotlinx.coroutines.channels.defaultBuffer trong JVM. Channel.RENDEZVOUS: (behavior mặc định) buffer capacity là 0. Receiver sẽ chỉ nhận được dữ liệu nếu nó đã subscribe với sender khi dữ liệu được emit. Channel.CONFLATED: buffer capacity là 1. Mỗi phần tử mới sẽ thay thế phần tử trước đó. Giá trị intbất kỳ: buffer sẽ có capacity bằng giá trị được set. Xử lý lỗi tràn buffer Các channel có một tham số onBufferOverflow kiểm soát những gì xảy ra khi buffer đầy. Có 3 lựa chọn:\nBufferOverflow.SUSPEND: (behavior mặc định) tạm dừng phương thức send khi buffer đầy. BufferOverflow.DROP_OLDEST: loại bỏ phần tử cũ nhất khi buffer đầy. BufferOverflow.DROP_LATEST: loại bỏ phần tử mới nhất khi buffer đầy. Tạo Channel tự động close Coroutine builder produce sẽ close channel bất cứ khi nào builder coroutine kết thúc (finish, stop hoặc cancel).\n1 2 3 4 5 suspend fun myFunction() = coroutineScope { val channel = produce { // emit các giá trị ở đây và không cần gọi close() khi kết thúc } } Tự động dọn dẹp nếu một phần tử không thể xử lý Nếu channel đã bị close, cancel hoặc khi send, receive, hastNext có lỗi\n1 2 3 4 val myChannel = Channel( capacity, onUnderliveredElement = { /* các tác vụ dọn dẹp ở đây */ } ) Use case: trigger một refresh Trong Android, trường hợp sử dụng phổ biến cho các channel là trigger khi một screen được refresh (pull to refresh hoặc button retry). Đoạn code bên dưới trình bày cách fetch data từ API khi chúng ta subscribe flow lần đầu tiên hoặc khi trigger một refresh.\nRất nhiều người sử dụng SharedFlow để trigger refresh và nó hoạt động ổn, nhưng đó không phải là giải pháp tốt nhất vì SharedFlow được thiết kế để có nhiều receiver.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 // Đây là phiên bản đơn giản hóa để minh họa cách chúng ta có thể sử dụng channel. // Trong trường hợp sử dụng thực tế, chúng ta sẽ yêu cầu một số logic bổ sung để tránh // làm mới nếu dữ liệu đã được tải chẳng hạn. interface ApiService { suspend fun fetchData(): List\u0026lt;String\u0026gt; } class FetchDataUseCase @Inject constructor ( private val apiService: ApiService ) { // tạo một channel có buffer là 1 và sẽ loại bỏ dữ liệu mới nhất // vì vậy nếu chúng ta trigger refresh nhiều lần liên tiếp // chúng ta sẽ chỉ giữ phần tử đầu tiên. private val refreshChannel = Channel\u0026lt;Unit\u0026gt;( capacity = 1, onBufferOverflow = BufferOverflow.DROP_LATEST ) // viewModel có thể receive flow này để build UI state val dataState: Flow\u0026lt;FetchDataState\u0026gt; = refreshChannel // convert channel thành flow .consumeAsFlow() // emit một phần tử khi bắt đầu fetch data ngay khi chúng ta subscribe flow .onStart { emit(Unit) } .map { fetchData() } fun refresh() { // Chúng ta sử dụng trySend ở đây để không phải tạo suspend function // và vì vậy chúng ta không cần scope để gọi nó. // Phương thức này có thể được gọi từ viewModel để trigger refresh refreshChannel.trySend(Unit) } private suspend fun fetchData(): FetchDataState = try { val data = apiService.fetchData() FetchDataState.Success(data) } catch (e: Exception) { FetchDataState.Error(e.message ?: \u0026#34;An error occurred\u0026#34;) } sealed interface FetchDataState { data object Loading : FetchDataState data class Success(val data: List\u0026lt;String\u0026gt;) : FetchDataState data class Error(val message: String) : FetchDataState } } Cảm ơn các bạn đã đọc đến đây, cùng chờ đón những phần tiếp theo nhé.\nReference https://medium.com/@galou.minisini/advanced-kotlin-flow-cheat-sheet-for-android-engineer-cb8157d4f848 ","date":"2024-08-18T04:00:00+07:00","image":"https://namanh11611.github.io/p/kotlin-flow-cheat-sheet-1/cheat_sheet_hu_dcb8eedc627a97f6.webp","permalink":"https://namanh11611.github.io/p/kotlin-flow-cheat-sheet-1/","title":"Kotlin Flow cheat sheet phần 1: Channel"},{"content":"Photo by Ana Cruz on Unsplash\nSau khi làm việc với Kotlin Coroutines một thời gian, có thể anh em đã quen với các khái niệm cơ bản như suspend function và các hàm launch, async\u0026hellip;, có thể giải quyết các use case đơn giản một cách ngon ơ. Nhưng khi dự án trở nên phức tạp hơn, anh em có thể thường xuyên cần các giải pháp nâng cao hơn và phải nhờ sự trợ giúp đến từ Google hoặc AI.\nCheat sheet này hệ thống lại những kiến thức quan trọng mà mình đã góp nhặt được trong quá trình làm việc với Kotlin Coroutines. Nó được thiết kế để trở thành một tài liệu tham khảo hữu ích, giúp anh em giải quyết các trường hợp phức tạp của coroutine.\nBạn có thể đọc toàn bộ serie tại đây:\nKotlin Coroutines cheat sheet nâng cao dành cho Android Engineer Kotlin Flow cheat sheet phần 1: Channel Kotlin Flow cheat sheet phần 2: Flow Kotlin Flow cheat sheet phần 3: SharedFlow và StateFlow Các khái niệm trong Coroutines Coroutine Context: tập hợp các thành phần khác nhau. Trong đó, các thành phần chính là Job và Dispatcher của coroutine.\nJob: thứ có thể hủy được với vòng đời đạt đến đỉnh khi nó hoàn thành. Mỗi coroutine đều tạo một Job của riêng nó (đó là coroutine context duy nhất không được kế thừa từ coroutine cha).\nDispatcher: cho phép chúng ta quyết định thread nào (hoặc pool của thread) mà coroutine sẽ chạy trên đó (khi start và resume). Bạn có thể đọc bài viết chi tiết của mình về Dispatchers trong Kotlin Coroutines\nCoroutine scope: xác định thời gian tồn tại và context của coroutine. Nó chịu trách nhiệm quản lý vòng đời của coroutine, bao gồm cả việc hủy và xử lý lỗi.\nCoroutine builder: các extension function của CoroutineScope, cho phép chúng ta start một coroutine bất đồng bộ (ví dụ như launch, async… ).\nCác quy tắc chính của Coroutines Bạn cần một CoroutineScope để start một coroutine (với function launch hoặc async). viewModelScope được sử dụng phổ biến nhất trong Android, nhưng bạn cũng có thể tự xây dựng scope của riêng bạn. Coroutine con (một coroutine bắt đầu từ một coroutine khác) kế thừa coroutine context từ coroutine cha (ngoại trừ Job). Job của coroutine cha được sử dụng làm cha của Job của coroutine con. Coroutine cha suspend cho đến khi tất cả các coroutine con của nó kết thúc. Khi một coroutine cha bị hủy thì tất cả các coroutine con của nó cũng bị hủy. Khi một coroutine con bị lỗi vì một Exception chưa được xử lý, nó sẽ cancel coroutine cha của nó (trừ khi bạn sử dụng một SupervisorJob). Bạn không nên sử dụng GlobalScope, nó có thể gây memory leak và giữ coroutine tồn tại ngay cả sau khi Activity hoặc Fragment khởi chạy nó đã bị bỏ qua. Bạn không nên truyền coroutine scope như một tham số, thay vào đó hãy sử dụng function coroutineScope. Các function của Coroutine scope coroutineScope: suspend function, dùng để bắt đầu một scope và trả về giá trị do tham số của function tạo ra. supervisorScope: tương tự coroutineScope nhưng nó override Job của context, vì vậy function không bị cancel khi coroutine con throw một Exception. withContext: tương tự coroutineScope nhưng cho phép thực hiện một số thay đổi trong scope (thường được sử dụng để set Dispatcher). withTimeout: tương tự coroutineScope nhưng đặt giới hạn thời gian cho phần body và nếu quá lâu sẽ bị hủy. Throw một TimeoutCancellationException. withTimeoutOrNull: tương tự withTimeout nhưng sẽ trả về null thay vì throw Exception khi hết thời gian. Chạy song song Khi bạn muốn thực hiện hai tác vụ cùng lúc và đợi kết quả của cả hai trước khi trả về kết quả:\nKhi bạn có quyền truy cập vào một scope (ví dụ từ ViewModel) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 suspend fun getConfigFromAPI(): UserConfig { // thực hiện lệnh gọi API tại đây hoặc bất kỳ suspend fun nào } suspend fun getSongsFromAPI(): List\u0026lt;Song\u0026gt; { // thực hiện lệnh gọi API tại đây hoặc bất kỳ suspend fun nào } fun getConfigAndSongs() { // scope có thể là bất kỳ scope nào bạn muốn, trường hợp điển hình sẽ là viewModelScope scope.launch { val userConfig = async { getConfigFromAPI() } val songs = async { getSongsFromAPI() } return Pair(userConfig.await(), songs.await()) } } Giả sử bạn có API được phân trang và bạn muốn tải xuống tất cả các trang trước khi hiển thị chúng cho người dùng, nhưng bạn muốn tải song song tất cả các trang:\n1 2 3 4 5 6 7 8 9 10 11 12 13 suspend fun getSongsFromAPI(page: Int): List\u0026lt;Song\u0026gt; { // thực hiện lệnh gọi API } const val totalNumberOfPages = 10 fun getAllSongs() { // scope có thể là bất kỳ scope nào bạn muốn, trường hợp điển hình là viewModelScope scope.launch { val allNews = (0 until totalNumberOfPages) .map { page -\u0026gt; async { getSongsFromAPI(page) } } .flatMap { it.await } } } Lưu ý về async/await: coroutine sẽ được bắt đầu ngay lập tức khi nó được gọi. async trả về một object thuộc loại Deferred\u0026lt;T\u0026gt; (trong ví dụ của chúng ta là Deferred\u0026lt;List\u0026lt;Song\u0026gt;\u0026gt;). Deferred có suspend function await trả về giá trị khi nó sẵn sàng.\nKhi bạn không có quyền truy cập vào một scope (ví dụ từ một repository) Từ repository hoặc use case của bạn, bạn muốn định nghĩa một coroutine sẽ bắt đầu song song 2 (hoặc nhiều) lệnh gọi. Vấn đề là bạn cần một scope để sử dụng async nhưng bạn không ở trong viewModel hoặc presenter nên bạn không có quyền truy cập vào scope của mình ở đây (hãy nhớ quy tắc của chúng ta là không nên truyền scope như một tham số).\nTừ ví dụ ở trên, chúng ta sửa lại một chút như sau:\n1 2 3 4 5 suspend fun getConfigAndSongs(): Pair\u0026lt;UserConfig, List\u0026lt;Song\u0026gt; = coroutineScope { val userConfig = async { getConfigFromAPI() } val songs = async { getSongsFromAPI()} Pair(userConfig.await(), songs.await()) } Dọn dẹp khi Coroutine bị cancel Nếu một coroutine bị hủy thì nó sẽ có trạng thái cancelling trước khi chuyển sang cancelled. Khi một coroutine bị hủy, chúng ta sẽ có thời gian để thực hiện một số tác vụ dọn dẹp nếu cần thiết (chẳng hạn như dọn dẹp local database hoặc gọi API để cho server biết rằng tác vụ không thành công).\nChúng ta có thể sử dụng finally để thực hiện một tác vụ:\n1 2 3 4 5 6 7 viewModelScope.launch { try { // gọi một số suspend function tại đây } finally { // thực hiện tác vụ dọn dẹp tại đây } } Nhưng không được phép gọi suspend function trong quá trình dọn dẹp. Nếu bạn cần gọi suspend function, bạn sẽ cần phải làm như sau:\n1 2 3 4 5 6 7 8 9 viewModelScope.launch { try { // gọi một số suspend function tại đây } finally { withContext(NonCancellable) { // thực hiện suspend function dọn dẹp tại đây } } } Lưu ý: Việc cancel sẽ xảy ra tại điểm suspend đầu tiên. Vì vậy việc cancel sẽ không xảy ra nếu chúng không có bất kỳ suspend function nào.\nDọn dẹp Coroutine khi hoàn thành Tương tự như việc dọn dẹp khi một coroutine bị hủy, bạn có thể muốn thực hiện một thao tác khi coroutine đạt đến trạng thái cuối cùng (completed hoặc cancelled).\n1 2 3 4 5 6 suspend fun myFunction() = coroutineScope { val job = launch { /* suspend function tại đây */ } job.invokeOnCompletion { exception: Throwable -\u0026gt; // do something here } } Làm cách nào để KHÔNG cancel Coroutine khi một trong các phần tử con của nó bị lỗi Bạn có thể sử dụng SupervisorJob và nó sẽ bỏ qua tất cả các exception ở con của nó.\nTạo coroutine scope của bạn 1 2 3 4 val scope = CoroutineScope(SupervisorJob()) // nếu một coroutine mắc lỗi thì coroutine còn lại sẽ không bị hủy scope.launch { myFirstCoroutine() } scope.launch { mySecondCoroutine() } Sử dụng scope function 1 2 3 4 5 suspend fun myFunction() = supervisorScope { // nếu một coroutine xảy ra lỗi thì coroutine kia sẽ không bị hủy launch { myFirstCoroutine() } launch { mySecondCoroutine() } } Bắt exception 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 suspend fun myFunction() { try { coroutineScope { launch { myFirstCoroutine() } } } catch (e: Exception) { // xử lý lỗi tại đây } try { coroutineScope { launch { mySecondCoroutine() } } } catch (e: Exception) { // xử lý lỗi tại đây } } CancellationException không truyền tới coroutine cha, chỉ coroutine hiện tại bị cancel. Có thể kế thừa CancellationException để tạo loại exception của riêng bạn, và nó cũng sẽ không truyền tới coroutine cha.\nĐịnh nghĩa tác vụ mặc định trong trường hợp có exception Chúng ta có thể sử dụng CoroutineExceptionHandler. Ví dụ, dùng để tự động đăng xuất người dùng khi server trả về lỗi 401.\n1 2 3 4 5 6 val handler = CoroutineExceptionHandler { context, exception -\u0026gt; // định nghĩa tác vụ mặc định như hiển thị hộp thoại hoặc thông báo lỗi } val scope = CoroutineScope(SupervisorJob() + handler) scope.launch { /* gọi suspend function tại đây */ } scope.launch { /* gọi suspend function tại đây */ } Chạy một tác vụ không cần thiết Nếu bạn muốn chạy một suspend function mà không ảnh hưởng đến các function khác (ví dụ nếu nó gây ra lỗi thì chỉ hàm này sẽ KHÔNG cancel coroutine, nhưng các hàm khác nếu gây ra lỗi thì vẫn sẽ cancel coroutine bình thường). Ví dụ điển hình là các function analytics.\n1 2 3 4 5 6 7 val nonEssentialOperationScope = CoroutineScope(SupervisorJob()) suspend fun getConfigAndSongs(): Pair\u0026lt;UserConfig, List\u0026lt;Song\u0026gt; = coroutineScope { val userConfig = async { getConfigFromAPI() } val songs = async { getSongsFromAPI()} nonEssentialOperationScope.launch { /* tác vụ không cần thiết ở đây */ } Pair(userConfig.await(), songs.await()) } Lý tưởng nhất là bạn nên inject nonEssentialOperationScope vào class để dễ test hơn.\nChạy một tác vụ trên single thread để tránh các sự cố đồng bộ 1 2 3 4 suspend fun myFunction() = withContext(Dispatchers.Default.limiteParallelism(1)) { // suspend function tại đây } // Cũng có thể sử dụng Dispatchers.IO Các cách tiếp cận khác để tránh sự cố đồng bộ hóa với multithreading Bạn có thể sử dụng AtomicReference (từ Java)\n1 2 3 4 5 6 private val myList = AtomicReference(listOf( /* thêm object vào đây */ )) suspend fun fetchNewElement() { val myNewElement = // fetch phần tử mới tại đây myList.getAndSet { it + myNewElement } } Hoặc với Mutex\n1 2 3 4 5 6 7 8 9 val mutex = Mutex() private var myList = listOf( /* thêm object vào đây */ ) suspend fun fetchNewElement() { mutex.withLock { val myNewElement = // fetch phần tử mới tại đây myList += myNewElement } } Tránh gửi lại một coroutine đến cùng một dispatcher Tránh chi phí không cần thiết khi chuyển đổi dispatcher nếu chúng ta đã sử dụng Dispatcher.Main:\n1 2 3 4 // điều này sẽ chỉ dispatch nếu cần thiết suspend fun myFunction() = withContext(Dispatcher.Main.immediate) { // suspend fun tại đây } Hiện tại chỉ Dispatchers.Main hỗ trợ immediate dispatching.\nCảm ơn bạn đã đọc đến đây. Nếu bạn có kiến thức hay ho hoặc tip về Kotlin Coroutines, đừng ngần ngại comment chia sẻ với mình nhé!\nReference https://medium.com/@galou.minisini/advanced-kotlin-coroutine-cheat-sheet-for-android-engineer-15e0d180fc1f ","date":"2024-08-12T00:00:00+07:00","image":"https://namanh11611.github.io/p/kotlin-coroutines-cheat-sheet/cheat_sheet_hu_dcb8eedc627a97f6.webp","permalink":"https://namanh11611.github.io/p/kotlin-coroutines-cheat-sheet/","title":"Kotlin Coroutines cheat sheet nâng cao dành cho Android Engineer"},{"content":"Photo by Ashley Batz on Unsplash\nThe Journey Begins LeetCode is likely familiar to many of you—a platform for solving algorithm problems and preparing for coding interviews, especially for foreign companies and a few in Vietnam.\nI started my journey the same way, simply to prepare for interviews. I realized that practicing problems on LeetCode not only improved my coding skills but also gave me more confidence when facing algorithm and data structure-related interview questions.\nI began solving problems by topic. This approach helped me systematically organize my knowledge and master specific types of problems. By focusing on one topic at a time, I could deepen my understanding and solve problems more efficiently. Since I didn’t specialize in Computer Science and didn’t participate in algorithm competitions during university, I could manage problems involving BFS, DFS, Hash Table, Stack, or Queue, but initially struggled with topics like Dynamic Programming and Union Find. However, as the saying goes, \u0026ldquo;Practice makes perfect\u0026rdquo;, after solving about ten problems, it became much easier.\nIn this initial phase, I solved around 100 problems, which I found sufficient to interview with companies that typically ask easy-to-medium-level questions.\nSustaining as a Hobby After passing my interview and joining a good company, I stopped solving problems for about a year. Then, on a beautiful day, I felt inspired to pick it up again. During this second phase, I treated solving LeetCode problems as a daily hobby. I spent around 30 minutes a day solving one problem from the Daily Coding Challenge. This not only helped maintain my algorithm skills but also served as a form of relaxation and self-challenge. Moreover, solving random problems daily better mimicked real-life interview scenarios.\nI usually set a 30-minute timer, and if I couldn’t figure out a solution, I’d read the Editorial (solutions provided by LeetCode), then try to memorize and code it myself. After every problem, whether solved independently or with help, I would check the Solutions section to see how others approached it. The top-voted solutions often showcased creative and optimized methods, sometimes even better than the Editorial solutions.\nAs the saying goes, \u0026ldquo;If you want to go fast, go alone. If you want to go far, go together.\u0026rdquo; To find companions and exchange experiences, I frequently joined discussions on the voz forum. This not only motivated me but also allowed me to learn various approaches from the community. To maintain motivation, I set a specific goal: reaching 6000 points to earn the LeetCode T-shirt. Setting clear goals gave me a reason to keep pushing forward every day.\nAchieving the Goal and Deciding to Pause After about 1.5 years of consistent effort, on July 26, 2024, I finally achieved my goal of 6000 points and claimed the T-shirt.\nHowever, with work becoming busier, I decided to take a break and focus on current responsibilities. Interestingly, the number of problems I solved happened to be 555—a perfect milestone. Maybe it’s a signal from the universe.\nWhen working with Thai colleagues, I learned that 555 in Thai is pronounced like laughter, Hahaha. Isn’t this universal signal quite amusing?\nTaking a break doesn’t mean giving up. In the future, if I feel inspired or need to prepare for companies that demand higher algorithm expertise, I’ll return to solving problems. The journey of solving 555 LeetCode problems has significantly enhanced my programming skills and logical thinking.\nWishing you all an energetic week ahead!\n","date":"2024-07-28T00:00:00+07:00","image":"https://namanh11611.github.io/p/leetcode/leetcode_hu_4d59592fa750c1c1.webp","permalink":"https://namanh11611.github.io/p/leetcode/","title":"Journey of Solving 555 LeetCode Problems"},{"content":"Introduction Process is a fundamental but essential concept in Android. When we launch an application, by default, all components like Activity, Service, BroadcastReceiver, and ContentProvider run within a single Linux Process unless we specify a separate process in the AndroidManifest file, as shown below:\n1 2 3 4 \u0026lt;activity android:process=\u0026#34;new_process_name\u0026#34; ...\u0026gt; \u0026lt;/activity\u0026gt; By default, the process name matches the app ID declared in the build.gradle file. Both the application and the four main components have an android:process tag. Therefore, if you declare android:process for the \u0026lt;application\u0026gt; tag, that process name will apply to all components of that application.\nPriority Levels We cannot manage Process lifetime directly. Android automatically calculates which components of running applications are active, their importance to the user, and the remaining memory to decide the Process lifetime.\nWhen Android runs out of resources, it shuts down a Process, and naturally, the components running on that Process are destroyed as well. What determines which Process gets shut down?\nAndroid prioritizes Processes based on their importance to the user. It classifies Processes into four priority levels:\nForeground Process This is the highest priority Process. It contains components the user is actively interacting with, such as:\nActivity at the top of the screen that the user is engaging with, where the onResume() method has been called. BroadcastReceiver running, with its onReceive() method currently executing. Service executing code in one of its callbacks: onCreate(), onStart(), or onDestroy(). Only a few Processes like this exist in the system, and they are only killed when memory is so low that even these cannot continue running.\nVisible Process This Process performs tasks that the user is aware of. If killed, it would impact the user experience. Examples include:\nActivity displayed on the screen but not in the foreground, where the onPause() method has been called. For example, an Activity partially covered by a dialog. Foreground Service running via the startForeground() method, making it visible to the user. A service running a feature visible to the user, such as a live wallpaper or keyboard. Service Process This Process contains a Service running via the startService() method. The user does not see it directly but is aware of the tasks it performs, such as uploading or downloading data in the background.\nA long-running Service (e.g., more than 30 minutes) may have its importance reduced to a cached state.\nCached Process These Processes are no longer necessary, and the system can safely kill them without hesitation when more resources are required.\nAn efficient system will have many Cached Processes to facilitate smooth app transitions and frequently kill Cached apps when needed.\nAndroid uses LRU Cache (Least Recently Used Cache) to manage Cached Processes, prioritizing the removal of Processes least recently used.\nIn summary, understanding how components like Activity, Service, and BroadcastReceiver impact priority levels is crucial. Select the appropriate component for your use case to avoid a Process being killed during important tasks.\nInter-Process Communication (IPC) Inter-Process Communication, or IPC, is a mechanism that allows Processes to communicate and synchronize their actions in Android.\nEach app runs in a separate Process, but many apps need to communicate with each other to share data or perform collaborative tasks, making IPC essential for safe and efficient inter-Process communication.\nIntent Intent is the standard mechanism for asynchronous communication between Activities and BroadcastReceivers. Depending on the need, you can use sendBroadcast, sendOrderedBroadcast, or explicit intents.\nAndroid Interface Definition Language (AIDL) AIDL is a tool for defining interfaces between Android applications. It enables apps to communicate safely and efficiently, regardless of the programming languages they are written in.\nMessenger Messenger is a class in the Android SDK that allows applications to send and receive messages. It provides a simple interface for inter-application communication.\nThe main difference between AIDL and Messenger is that AIDL supports concurrent tasks, while Messenger is limited to sequential tasks.\nBroadcast Receiver BroadcastReceiver handles asynchronous requests from Intents. By default, any app can call the receiver. If you intend to use BroadcastReceiver for a specific application, you can secure it by using the \u0026lt;receiver\u0026gt; tag in the AndroidManifest. This prevents unauthorized apps from sending Intents to the BroadcastReceiver.\nReference https://developer.android.com/guide/components/processes-and-threads https://developer.android.com/guide/components/activities/process-lifecycle https://developer.android.com/privacy-and-security/security-tips#interprocess-communication ","date":"2024-06-21T00:00:00+07:00","image":"https://namanh11611.github.io/p/process/process_hu_a9318d03867efebf.webp","permalink":"https://namanh11611.github.io/p/process/","title":"Everything About Process in Android"},{"content":"Có thể nói, trong quá trình làm LeetCode thì Dynamic Programming (DP), hay còn gọi là Quy hoạch động trong tiếng Việt, là một dạng bài mọi người thường xuyên gặp nhất, nhưng cũng là một trong những dạng khó nhằn nhất. Khi gặp một bài mới, nếu bạn nhận ra nó có thể giải bằng DP là bạn đã đi được 80% quãng đường rồi. Vậy nên, để giúp cho quá trình \u0026ldquo;nhận ra\u0026rdquo; đấy trở nên dễ dàng hơn, trong bài viết này, mình sẽ chia sẻ với các bạn 5 dạng phổ biến của DP trên LeetCode.\nTìm giá trị nhỏ nhất / lớn nhất Đề bài thường có dạng:\nCho một mục tiêu, tìm giá trị nhỏ nhất / lớn nhất để đạt mục tiêu đó.\nHướng giải:\nTìm giá trị nhỏ nhất / lớn nhất trong số tất cả các cách có thể trước đó, sau đó cộng với giá trị của trạng thái hiện tại.\n1 routes[i] = min(routes[i-1], ... , routes[i-k]) + cost[i] Khi giải một bài DP, chúng ta có 2 hướng làm là Top-Down và Bottom-Up.\nTheo hướng tiếp cận Top-Down, chúng ta sẽ bắt đầu bằng bài toán lớn nhất hay là bài toán ở mức trên cùng sau đó dùng phương pháp đệ quy để gọi lời giải cho các bài toán con ở mức thấp hơn tiếp theo. Quá trình tiếp tục cho đến khi gặp bài toán nhỏ nhất. Đệ quy sẽ tự động tổ hợp kết quả của các bài toán con để được kết quả bài toán ban đầu. Chúng ta thường sẽ dùng một mảng memo để lưu kết quả các bài toán con, tránh việc phải tính đi tính lại chúng gây ra lỗi Time Limit Exceeded.\n1 2 3 4 for (int j = 0; j \u0026lt; ways.size(); ++j) { result = min(result, topDown(target - ways[j]) + cost[i]); } return memo[/*state parameters*/] = result; Còn theo hướng Bottom-Up, chúng ta sẽ giải các bài toán con ở mức thấp nhất, sau đó dùng các kết quả này để tính bài toán ở mức trên. Quá trình tiếp tục cho đến khi chúng ta tìm được kết quả bài toán mức cao nhất. Cá nhân mình thì thường làm theo hướng nay hơn.\n1 2 3 4 5 6 7 8 for (int i = 1; i \u0026lt;= target; ++i) { for (int j = 0; j \u0026lt; ways.size(); ++j) { if (ways[j] \u0026lt;= i) { dp[i] = min(dp[i], dp[i - ways[j]] + cost[i]); } } } return dp[target] Chúng ta cùng áp dụng vào bài Min Cost Climbing Stairs\nCho mảng cost, trong đó cost[i] là chi phí của bước thứ i trên cầu thang. Khi bạn trả phí, bạn có thể bước 1 hoặc 2 bước. Bạn được chọn bước từ vị trí 0 hoặc 1.\nTìm chi phí nhỏ nhất để đi hết cầu thang.\nBạn có thể nhận thấy rằng, khi xét bước thứ i, bạn chỉ có thể bước đến đây từ bước thứ i - 1 (bước 1 bước) hoặc từ bước thứ i - 2 (bước 2 bước). Vậy nên, chi phí nhỏ nhất khi bước đến bước thứ i sẽ bằng tổng của giá trị nhỏ hơn trong 2 bước trước đó cộng với cost[i]. Từ đó chúng ta có 2 cách giải tương ứng như sau.\nTop-Down\n1 2 3 int result = min(minCost(n-1, cost, memo), minCost(n-2, cost, memo)) + (n == cost.size() ? 0 : cost[n]); return memo[n] = result; Bottom-Up\n1 2 3 4 for (int i = 2; i \u0026lt;= n; ++i) { dp[i] = min(dp[i-1], dp[i-2]) + (i == n ? 0 : cost[i]); } return dp[n] Tìm số cách khác nhau Đề bài thường có dạng:\nCho một mục tiêu, tìm số cách khác nhau để đạt mục tiêu đó.\nHướng giải:\nTính tổng tất cả các cách có thể để đạt đến mục tiêu.\n1 routes[i] = routes[i-1] + routes[i-2] + ... + routes[i-k] Top-Down\n1 2 3 4 for (int j = 0; j \u0026lt; ways.size(); ++j) { result += topDown(target - ways[j]); } return memo[/*state parameters*/] = result; Bottom-Up\n1 2 3 4 5 6 7 8 for (int i = 1; i \u0026lt;= target; ++i) { for (int j = 0; j \u0026lt; ways.size(); ++j) { if (ways[j] \u0026lt;= i) { dp[i] += dp[i - ways[j]]; } } } return dp[target] Chúng ta cùng áp dụng vào bài Climbing Stairs\nBạn đang leo lên một chiếc cầu thang. Nó cần n bước để leo đến đỉnh. Mỗi lần bạn chỉ có thể leo 1 hoặc 2 bước.\nHãy tính bạn có bao nhiêu cách khác nhau để leo đến đỉnh?\nTương tự như bài trên, khi xét bước thứ i, bạn chỉ có thể bước đến đây từ bước thứ i - 1 (bước 1 bước) hoặc từ bước thứ i - 2 (bước 2 bước). Vậy nên, số cách khác nhau leo đến bước thứ i sẽ bằng tổng của số cách đến bước i - 1 và số cách đến bước i - 2. Từ đó chúng ta có 2 cách giải tương ứng như sau.\nTop-Down\n1 2 int result = climbStairs(n-1, memo) + climbStairs(n-2, memo); return memo[n] = result; Bottom-Up\n1 2 3 for (int stair = 2; stair \u0026lt;= n; ++stair) { dp[stair] = dp[stair-1] + dp[stair-2]; } Hợp nhất các khoảng giá trị Đề bài thường có dạng:\nCho một bộ số, tìm giải pháp tối ưu cho một bài toán mà xét số hiện tại và kết quả tốt nhất bạn có thể nhận được từ bên trái và bên phải.\nHướng giải:\nTìm tất cả giải pháp tối ưu cho mỗi khoảng và trả về kết quả tốt nhất có thể.\n1 2 // From i to j dp[i][j] = dp[i][k] + result[k] + dp[k+1][j] Top-Down\n1 2 3 4 for (int k = i; k \u0026lt;= j; ++k) { result = max(result, topDown(nums, i, k) + result[k] + topDown(nums, k+1, j)); } return memo[/*state parameters*/] = result; Bottom-Up\n1 2 3 4 5 6 7 8 9 for(int l = 1; l\u0026lt;n; l++) { for(int i = 0; i\u0026lt;n-l; i++) { int j = i+l; for(int k = i; k\u0026lt;j; k++) { dp[i][j] = max(dp[i][j], dp[i][k] + result[k] + dp[k+1][j]); } } } return dp[0][n-1]; Chúng ta cùng áp dụng vào bài Minimum Cost Tree From Leaf Values\nCho một mảng arr các số dương. Chọn tất cả cây nhị phân thoả mãn điều kiện:\nMỗi node có 0 hoặc 2 node con Giá trị các phần tử của mảng arr tương ứng với giá trị của mỗi lá (node không có con) khi duyệt cây theo in-order Giá trị của mỗi node không phải lá thì bằng tích của lá lớn nhất trong cây con trái và phải của nó Trong tất cả các cây được chọn, tìm cây có tổng các node không phải lá nhỏ nhất.\n1 2 3 4 5 6 7 8 9 for (int l = 1; l \u0026lt; n; ++l) { for (int i = 0; i \u0026lt; n - l; ++i) { int j = i + l; dp[i][j] = INT_MAX; for (int k = i; k \u0026lt; j; ++k) { dp[i][j] = min(dp[i][j], dp[i][k] + dp[k+1][j] + maxs[i][k] * maxs[k+1][j]); } } } String Đề bài cho String thường có rất nhiều dạng, nhưng hầu hết đều là cho 1 hoặc 2 string với độ dài không quá lớn.\nCho 2 string s1 và s2, trả về kết quả gì đấy.\nHướng giải:\nHầu hết các bài toán dạng này có thể giải với kết quả có độ phức tạp về thời gian là O(n).\n1 2 3 4 5 6 7 8 9 10 11 // i - indexing string s1 // j - indexing string s2 for (int i = 1; i \u0026lt;= m; ++i) { for (int j = 1; j \u0026lt;= n; ++j) { if (s1[i-1] == s2[j-1]) { dp[i][j] = /*code*/; } else { dp[i][j] = /*code*/; } } } Nếu đề bài chỉ cho 1 string thì cách giải sẽ hơi khác một chút:\n1 2 3 4 5 6 7 8 9 10 for (int l = 1; l \u0026lt; n; ++l) { for (int i = 0; i \u0026lt; n-l; ++i) { int j = i + l; if (s[i] == s[j]) { dp[i][j] = /*code*/; } else { dp[i][j] = /*code*/; } } } Chúng ta cùng áp dụng vào bài Longest Common Subsequence\nCho 2 string text1 và text2, tìm chiều dài lớn nhất của subsequence chung.\nXét ký tự thứ i của text1 và ký tự thứ j của text2.\nNếu chúng giống nhau, chúng ta tăng chiều dài subsequence chung thêm 1 Nếu chúng khác nhau, chúng ta sẽ lấy chiều dài lớn hơn trong 2 trường hợp i - 1 với j hoặc i với j - 1 1 2 3 4 5 6 7 8 9 for (int i = 1; i \u0026lt;= m; ++i) { for (int j = 1; j \u0026lt;= n; ++j) { if (text1[i-1] == text2[j-1]) { dp[i][j] = dp[i-1][j-1] + 1; } else { dp[i][j] = max(dp[i-1][j], dp[i][j-1]); } } } Với bài toán 1 string, chúng ta sẽ áp dụng vào bài Palindromic Substrings\nCho 1 string s, tính số lượng palindromic substring của nó.\nChúng ta xét ký tự thứ i và j, nếu chúng giống nhau và substring từ i + 1 đến j - 1 đã là palindromic thì chúng ta tìm được một palindromic mới.\n1 2 3 4 5 6 7 8 9 10 for (int l = 1; l \u0026lt; n; ++l) { for (int i = 0; i \u0026lt; n-l; ++i) { int j = i + l; if (s[i] == s[j] \u0026amp;\u0026amp; dp[i+1][j-1] == j-i-1) { dp[i][j] = dp[i+1][j-1] + 2; } else { dp[i][j] = 0; } } } Ra quyết định Dạng bài thì nổi tiếng với loạt bài House Robber và Best Time to Buy and Sell Stock.\nĐề bài thường có dạng:\nCho một tập giá trị, tìm đáp án với tuỳ chọn là chọn hoặc bỏ qua giá trị hiện tại.\nHướng giải:\nNếu bạn quyết định chọn giá trị hiện tại, hãy sử dụng kết quả trước đó, trong đó giá trị trước đó bị bỏ qua. Ngược lại, nếu bạn quyết định bỏ qua giá trị hiện tại, hãy sử dụng giá trị trước đó, trong đó giá trị trước đó được sử dụng.\n1 2 3 4 5 6 7 8 // i - indexing a set of values // j - options to ignore j values for (int i = 1; i \u0026lt; n; ++i) { for (int j = 1; j \u0026lt;= k; ++j) { dp[i][j] = max({dp[i][j], dp[i-1][j] + arr[i], dp[i-1][j-1]}); dp[i][j-1] = max({dp[i][j-1], dp[i-1][j-1] + arr[i], arr[i]}); } } Chúng ta cùng áp dụng vào bài House Robber\nBạn là một tên trộm chuyên nghiệp đang có kế hoạch ăn trộm cả một dãy phố. Tuy nhiên dãy phố này có hệ thống an ninh liên kết với nhau, và nó sẽ tự động báo cảnh sát nếu 2 ngôi nhà cạnh nhau cùng bị trộm.\nCho một mảng nums đại diện cho số tiền trong mỗi ngôi nhà. Hãy tính số tiền tối đa bạn có thể trộm được mà không bị báo cảnh sát.\nChúng ta tạo 1 mảng 2 chiều với công thức:\ndp[i][1] là tổng số tiền nếu quyết định trộm nhà thứ i dp[i][0] là tổng số tiền nếu quyết định không trộm nhà thứ i 1 2 3 4 for (int i = 1; i \u0026lt; n; ++i) { dp[i][1] = max(dp[i-1][0] + nums[i], dp[i-1][1]); dp[i][0] = dp[i-1][1]; } Reference https://leetcode.com/discuss/general-discussion/458695/Dynamic-Programming-Patterns ","date":"2024-05-05T00:00:00+07:00","image":"https://namanh11611.github.io/p/dynamic-programming/dynamic_programming_hu_844ec0c40a171afb.webp","permalink":"https://namanh11611.github.io/p/dynamic-programming/","title":"LeetCode: Dễ dàng nhận biết 5 dạng bài Dynamic Programming"},{"content":"Clean Code is probably a classic topic in programming. I once mentioned the book Clean Code by Uncle Bob in the article Things I Wish I Knew When I Was a Junior. However, this time I won\u0026rsquo;t rewrite the contents of that book—you should read it directly for the best experience. I just want to share a few tips that I often use to keep my code tidy and clean.\nUse return to avoid if/else hell Have you ever encountered if/else hell like this in your code?\n1 2 3 4 5 6 7 8 9 10 11 void doSomething() { if (condition1) { doFirstTask(); if (condition2 != null) { doSecondTask(); if (condition3.isNotEmpty()) { doThirdTask(); } } } } In theory, the above code is fine. But I don\u0026rsquo;t like looking at code with so many nested layers. So I often use return to avoid writing too many nested braces {}. We can refactor the code above as follows:\n1 2 3 4 5 6 7 8 void doSomething() { if (!condition1) return doFirstTask(); if (condition2 == null) return doSecondTask(); if (condition3.isEmpty()) return doThirdTask(); } The logic is equivalent, but the meaning is slightly different. In the first case, when your colleague reads the code, they\u0026rsquo;ll understand: \u0026ldquo;If this condition is met, the code will continue to process like this.\u0026rdquo; In the second case, they\u0026rsquo;ll understand: \u0026ldquo;If this condition is not met, the code will not continue.\u0026rdquo; Thinking in the second way can sometimes feel a bit reversed, so apply this tip as appropriate, don\u0026rsquo;t use it mechanically in all cases.\nUse Map or Set instead of List Map and Set are two special data structures that you probably learned in university. However, in projects, people often always use List because it\u0026rsquo;s \u0026ldquo;convenient.\u0026rdquo; For me, before choosing a data type for a list, I always ask whether using Map or Set would make the code shorter and improve performance. If yes, I definitely prioritize these two types.\nFor example, I have a variable existingValueList which is a list of existing values. When a user enters a new value, I need to check if it already exists, and if so, return an error. If existingValueList is a List, I\u0026rsquo;d write the check like this:\n1 boolean isExisting = existingValueList.contains(value); But if it\u0026rsquo;s a Set, we\u0026rsquo;d write:\n1 boolean isExisting = existingValueSet.contains(value); \u0026ldquo;So, what\u0026rsquo;s the difference?\u0026rdquo; The way you write it is the same, but the difference lies in the contains() method: the runtime for List is O(n), while for Set it\u0026rsquo;s only O(1).\n99% of you probably know this, but sometimes you use List out of habit. So next time, before creating a List, pause for a moment to consider whether you should use Map or Set.\nThere are also other data structures like Stack, Queue, Tree\u0026hellip; But in real projects, I rarely encounter use-cases for these.\nDon\u0026rsquo;t comment out unused code—just delete it I\u0026rsquo;ve noticed some people have the habit of commenting out old code when modifying a feature instead of deleting it. Or there are old functions that are no longer used, but they don\u0026rsquo;t bother to comment or delete them, just leaving them there forever. But trust me, a few months or even a few years later, you\u0026rsquo;ll probably never uncomment that code again. A few lines each time, but over the years it becomes a mountain of dead code.\nIf you want to review old code, Git can help you very well. So be bold and delete it—not just a few lines of code, a function, but also any resources of the app that you no longer use. This will help reduce your source code size significantly.\nIf you have any cool tips that you use, please share them with me!\n","date":"2024-05-01T00:00:00+07:00","image":"https://namanh11611.github.io/p/clean-code/tidy_hu_9a6f9a0b35a0bcfa.webp","permalink":"https://namanh11611.github.io/p/clean-code/","title":"3 Ways I Apply to Write Cleaner and Tidier Code"},{"content":"What is Flutter Hooks? When searching for the keyword Hooks on Google, you\u0026rsquo;ll find many results related to React. Indeed, as mentioned in the introduction, the flutter_hooks library by Remi Rousselet was built inspired by React.\nHooks are objects that help manage the life-cycle of a Widget. Their sole purpose is to increase the ability to share source code between Widgets by eliminating duplicated code.\nYou might wonder: \u0026ldquo;Wait, doesn\u0026rsquo;t StatefulWidget in Flutter already have initState and dispose methods to handle life-cycle management? Why do we need Hooks?\u0026rdquo; That\u0026rsquo;s correct, but it\u0026rsquo;s very difficult to reuse code in these two methods. Hooks were created to solve that problem.\nUsage Guide A simple example of Hooks is as follows:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class MyHookWidget extends HookWidget { const MyHookWidget({super.key}); @override Widget build(BuildContext context) { final counter = useState(0); return Scaffold( body: Center( child: Text(\u0026#39;Counter: ${counter.value}\u0026#39;), ), floatingActionButton: FloatingActionButton( onPressed: () =\u0026gt; counter.value++, child: const Icon(Icons.add), ), ); } } You can see that our Widget now extends HookWidget instead of StatefulWidget or StatelessWidget. In the build method, there\u0026rsquo;s a new keyword useState, which is one of the hooks in Flutter Hooks. We\u0026rsquo;ll explore some basic hooks below.\nNow, when you click the FloatingActionButton, the text value will change as the counter variable increases, similar to how StatefulWidget works, right?\nuseEffect hook This is similar to the useEffect hook in React, used to perform side effects synchronously during rendering. The effect can return a function, which will be called when the effect is recalled or the widget is disposed.\nBy default, the effect is called every build, unless you pass a key parameter. In that case, the effect is only called when the key changes.\nSide effects can include stream subscriptions, opening a WebSocket connection, or making an HTTP request. You can cancel them when the widget is disposed.\n1 2 3 4 5 6 useEffect(() { performSideEffect(); return () { cleanUp(); }; }, [key]); useState hook This is the most basic hook when you want to convert a StatelessWidget to a StatefulWidget. When called in the build method, it maintains state between widget rebuilds.\n1 final counter = useState(0); In this example, we pass an initial value of 0. The counter variable is an instance of ValueNotifier. The state is stored in the value property of ValueNotifier. Whenever the value changes, the useState hook will rebuild the widget to display the new value.\nuseMemoized hook This is a useful method when you need to create a complex object and want to return the same object across multiple child widget rebuilds. useMemoized helps cache that object; the value is only computed on the first call, and subsequent calls return the previously stored value.\n1 2 3 4 final complexObject = useMemoized( () =\u0026gt; createComplexObject(), [] ); useRef hook Creates an object containing a mutable property. However, changing the property of the object does not trigger an effect. It\u0026rsquo;s suitable for use-cases where you need to share state between build method calls, but want to avoid unnecessary rebuilds.\n1 2 3 4 5 6 7 8 9 10 11 12 final textController = useTextEditingController(); /// Using useState() in this case /// would cause the widget to rebuild on every character input // final name = useState(\u0026#39;\u0026#39;); final name = useRef(\u0026#39;\u0026#39;); useEffect(() { textController.addListener(() { name.value = textController.text; }); return null; }, []); useCallback hook Caches the instance of an entire function, if that function is recalled.\n1 2 3 final cachedFun = useCallback(() { Statements }, []); useContext hook Keeps the BuildContext of the HookWidget, so you don\u0026rsquo;t have to pass the context parameter through methods.\n1 2 3 4 5 Widget createSizedBox() { return SizedBox( height: MediaQuery.sizeOf(useContext()).height / 10 ); } useValueChanged hook Monitors a value and triggers a callback whenever its value changes. Returning to the initial example, let\u0026rsquo;s modify it a bit:\n1 2 3 4 5 6 7 final count = useState(0); final newCount = useState(0); useValueChanged(count.value, (oldValue, oldResult) { print(\u0026#39;oldValue = $oldValue, oldResult = $oldResult\u0026#39;); newCount.value += 5; return newCount.value; }); When you click the FloatingActionButton, the output will be printed as follows:\n1 2 3 4 oldValue = 0, oldResult = null oldValue = 1, oldResult = 5 oldValue = 2, oldResult = 10 ... As you can see, whenever the value of count changes, newCount also changes accordingly.\nuseStream hook Helps subscribe to a Stream and returns its current state.\n1 final snapshot = useStream(backend.stream); useAnimationController hook Creates an AnimationController and disposes it automatically.\n1 2 3 final controller = useAnimationController( duration: Duration(seconds: 1) ); Benefits of Hooks State Management: Hooks simplify local state management, ensuring widgets only handle logic relevant to themselves. Reduce duplicate code: Custom hooks allow you to reuse widget logic, significantly reducing duplicate code and improving code quality. Improve Hot Reload: With hooks, hot reload is less likely to fail because the hook\u0026rsquo;s state is preserved. Convenience: Some built-in hooks like useAnimationController, useFuture, and useStream are methods that can be applied to many common use-cases. Simplify life-cycle: Managing complex life-cycles becomes much simpler with Flutter Hooks. They provide a solution for easily managing state, side-effects, and stream subscriptions. Flexible custom hooks: Besides the built-in hooks, Flutter Hooks allows you to create custom hooks, making your code more flexible. You may already know that Remi Rousselet is also the author of two famous State Management libraries: Provider and Riverpod. He has combined Riverpod and Hooks in a library called Hooks Riverpod. You can harness the power of both with this library. Riverpod is for \u0026ldquo;global\u0026rdquo; application state, while hooks are for local widget state.\nConclusion I find Flutter Hooks quite promising, but not many projects have adopted it yet. Have you ever used it? If you see any pros or cons, please share with me!\n","date":"2024-04-30T00:00:00+07:00","image":"https://namanh11611.github.io/p/flutter-hooks/hooks_hu_de74ce846ed4c387.webp","permalink":"https://namanh11611.github.io/p/flutter-hooks/","title":"Flutter Hooks - Write More Concise and Efficient Code"},{"content":"Chữ Quốc ngữ vốn chứa đựng nhiều lỗi Trước hết để mọi người không nhầm lẫn thì cần phân biệt rõ ràng 2 khái niệm tiếng Việt và chữ Quốc ngữ. Tiếng Việt là ngôn ngữ của người Việt và đã xuất hiện từ khoảng đầu Công nguyên, là cách mà cha ông ta nói chuyện, giao tiếp với nhau, gọi tên sự vật, hiện tượng như trời, đất, bánh chưng, bánh dày\u0026hellip; Còn chữ Quốc ngữ là một loại chữ viết dựa trên chữ cái Latinh, được sáng tạo bởi các tu sĩ Bồ Đào Nha dùng để ghi âm tiếng Việt vào đầu thế kỷ XVII.\nMình không có vấn đề gì với tiếng Việt, nhưng chữ Quốc ngữ thì mình thấy nó còn chứa đựng nhiều lỗi. Ví dụ như hồi đi học, có bao giờ bạn thắc mắc:\nTại sao tên một số địa danh như Đắk Lắk, Đắk Nông lại có cách viết khác với các từ thông thường? Tại sao chữ c, g, ng lại không thể đứng trước e, ê, i, mà chúng ta phải dùng k, gh, ngh? Tại sao Bác Hồ lại viết là Đường Kách mệnh chứ không phải là Đường Cách mạng như ngày nay chúng ta hay viết? Chữ Quốc ngữ vay mượn chủ yếu từ tiếng Bồ Đào Nha và tiếng Ý, ví dụ như trong tiếng Bồ Đào Nha, nếu để chữ c đứng trước a,o,u sẽ biểu thị phụ âm /k/, nhưng khi đứng trước e,i sẽ biểu thị phụ âm /s/. Vì vậy để tránh cho những người biết tiếng biết Bồ Đào Nha khỏi đọc sai, các tu sĩ mới đặt ra quy tắc phải dùng k thay cho c khi đứng trước e,ê,i,y.\nCòn với người Việt Nam, chúng ta không bị hiểu nhầm như trên, nên chúng ta có thể hoàn toàn dùng c thay cho k trong mọi từ mà không bị phát âm sai. Ví dụ như nếu mình viết là con ciến thay cho con kiến, cái cem thay cho cái kem, mặc dù là viết sai chính tả, nhưng người Việt vẫn có thể đọc đúng, chứ không đọc thành con siến hay cái sem như người Bồ Đào Nha.\nNhư trong tiêu đề của bài viết này, mình dùng từ kải kách thay cho cải cách nhưng các bạn vẫn hiểu ý mình đang truyền đạt đúng không?\nNhững công trình không bao giờ được triển khai Nhận thấy sự bất hợp lý này, đã có rất nhiều công trình đề xuất cải tiến chữ Quốc ngữ. Trong đó có thể kể đến dự thảo Phương án cải tiến chữ Quốc ngữ bước đầu của Giáo sư Hoàng Phê xây dựng từ những năm 1960-1961. Trong đó, ông đề xuất một số điểm như:\nBỏ h trong gh và ngh. Ví dụ: ghê -\u0026gt; gê, nghe -\u0026gt; nge, nghiêng -\u0026gt; ngiêng. Dùng f thay ph, d thay đ, z thay d và gi. Ví dụ: dân tộc -\u0026gt; zân tộc, đất nước -\u0026gt; dất nước, phương pháp -\u0026gt; fương fáp. Nhất luật viết phụ âm /k/ bằng k trong mọi trường hợp, thay cho c, và nghiên cứu thay cả cho q. Ví dụ như Đường kách mệnh. Hoặc một trường hợp nổi tiếng khác là đề xuất Phương án cải tiến chữ Quốc ngữ của Phó giáo sư Bùi Hiền. Ông từng công bố đề xuất ở Báo Giáo dục và Thời đại số 72 ngày 8/9/1995. Cuối năm 2017, sau một cuộc hội thảo thì đề xuất của ông được đưa ra truyền thông và đã có bàn cãi sôi nổi do những khác lạ trong lối viết cải tiến mà ông đưa ra. Ở thời điểm đó, khi mà người người nhà nhà chê trách PGS Bùi Hiền, có lẽ mình là một trong số ít những người thấy được một số điểm hợp lý trong đề xuất của ông (chỉ một số thôi chứ không phải toàn bộ phương án).\nNhưng qua năm tháng, các bạn có thể thấy những công trình trên sẽ không bao giờ được triển khai, bởi vì nó sẽ gây tốn kém rất lớn về thời gian, tiền bạc và nguồn lực của cả xã hội. Hãy thử tưởng tượng cả nước phải đi đổi Căn cước công dân, Sổ hộ khẩu, giấy tờ hành chính, các bộ gõ tiếng Việt phải cập nhật lại quy tắc, các phần mềm phải cập nhật lại giao diện\u0026hellip; Mình nghĩ nó phải tốn cả chục năm để hoàn thành mất.\nNhững nguyên lý trong lập trình Câu chuyện trên nghe qua thì có vẻ như chẳng liên quan đến ngành Công nghệ thông tin, nhưng các bạn hãy thử xoay góc nhìn, coi chữ Quốc ngữ như một ngôn ngữ lập trình với bộ quy tắc riêng về cách đặt phụ âm, cách kết nối các âm, cách đánh dấu thanh\u0026hellip; Qua đó, chúng ta sẽ có một số góc nhìn mới về sự ra đời và phát triển của chữ Quốc ngữ và liên hệ nó với các nguyên lý, bài học trong ngành lập trình.\nCode luôn có đầy rẫy edge case Có thể thấy, tên một số địa danh như Đắk Lắk, Đắk Nông chính là một edge case của chữ Quốc ngữ. Trong lập trình cũng vậy, chúng ta luôn phải lưu ý xử lý edge case để tránh chương trình gặp lỗi sau này.\nVí dụ như thực hiện phép chia thì luôn phải kiểm tra trường hợp số chia khác 0, tìm phần tử đầu tiên của mảng thì luôn phải kiểm tra trường hợp mảng bị rỗng.\nVí dụ bạn có một input text field thì cần suy nghĩ các edge case như user không nhập gì, user nhập text quá dài hoặc user nhập sai format mà chúng ta mong muốn. Việc check edge case trong trường hợp này còn giúp chúng ta tránh được cuộc tấn công Cross Site Scripting (XSS).\nTính tương thích ngược (Backward Compatible) Thực ra chữ Quốc ngữ vẫn đang có những sự cải tiến từ lúc ra đời đến ngày nay. Ví dụ như ngày xưa Bác Hồ viết Đường Kách mệnh nhưng ngày nay chúng ta lại viết là Đường Cách mạng. Hoặc trước đây, các từ ghép hoặc tên riêng thường có dấu gạch nối ở giữa, ví dụ như độc-lập, tự-do, Việt-Nam, Luân-Đôn\u0026hellip; Thế nhưng ngày nay, những dấu gạch nối đó đã bị bỏ đi. Những sự cải tiến nhỏ này vẫn đảm bảo mọi người có thể hiểu được cách viết mới dễ dàng, không cần tốn quá nhiều thời gian để làm quen.\nTrong các ngôn ngữ lập trình, khi có nâng cấp một version mới, thường nó sẽ luôn được đảm bảo tính tương thích ngược để những chương trình viết theo cách viết code cũ không bị xảy ra lỗi. Ví dụ như các function cũ có thể bị đánh dấu là Deprecated, hiển thị warning cho các lập trình viên biết rằng function này sẽ sớm bị thay thế, nhưng không bị xoá ngay để chúng ta có thời gian update nó.\nCode đang chạy ổn thì đừng đụng vào Việc đề xuất cải cách của PGS Bùi Hiền bị dư luận phản ứng dữ dội một phần vì nó khác quá xa với những gì mà mọi người đang đọc, đang viết hàng ngày. Nếu được áp dụng vào thực tế, chắc chắn trong quá trình thực thi sẽ có những sự xung đột giữa những văn bản, phần mềm được viết bằng kiểu chữ cũ và kiểu chữ cải cách.\nNó giống như câu chuyện kinh điển trong ngày lập trình mà anh em thường nói vui với nhau \u0026ldquo;Code đang chạy ổn thì đừng đụng vào\u0026rdquo;. Hồi mới ra trường, mình từng nhiệt tình xung phong refactor một feature có flow khá phức tạp. Thế rồi hậu quả là mình mất một mớ thời gian để đi fix bug cho những corner case của feature đó mà khi bắt đầu làm mình chưa lường trước hết được.\nPhát hiện lỗi càng muộn, chi phí sửa đổi càng lớn Như mình chia sẻ ở trên, những công trình cải cách chữ Quốc ngữ trên có thể sẽ không bao giờ được đưa vào đời sống bởi vì sự tốn kém của nó. Nếu muốn sửa, có lẽ thời điểm tốt nhất là lúc\u0026hellip; các tu sỹ Bồ Đào Nha mới sáng tạo ra nó.\nCùng là một bug, nếu bạn phát hiện ra nó ở phase develop, bạn chỉ cần sửa vài dòng code là xong. Nếu nó đã được release lên beta, việc chỉnh sửa có thể sẽ ảnh hưởng đến một nhóm nhỏ user. Còn nếu xui hơn là sản phẩm đã được release lên production tới toàn bộ user, một thay đổi nhỏ có thể gây ảnh hưởng cực lớn, ví dụ như làm mất dữ liệu của user hoặc gây ra trải nghiệm tệ trong quá trình sử dụng phần mềm.\nBạn có nhớ đến trường hợp lỗi pin của điện thoại Galaxy Note 7 không? Sự cố này đã khiến Samsung phải thu hồi dòng điện thoại này, gây thiệt hại cho hãng 5,4 tỷ USD.\nKết luận Bài viết này chỉ đưa ra một góc nhìn thú vị về lập trình và cuộc sống, không nhằm mục đích công kích tổ chức hay cá nhân nào. Hy vọng bạn coi nó như một bài viết mang tính giải trí trong lúc trà dư tửu hậu.\n","date":"2024-03-20T00:00:00+07:00","image":"https://namanh11611.github.io/p/vietnamese/vietnamese_hu_7bf3b1051682fc1b.webp","permalink":"https://namanh11611.github.io/p/vietnamese/","title":"Từ câu chuyện kải kách chữ Quốc ngữ đến những nguyên lý trong lập trình"},{"content":"The Old Days As you know, diagrams and documentation play an important role in projects. They act as a compass to help developers understand the ideas of PMs, tech leads, or BAs, guide the required flow, and serve as evidence for reference when there are disputes about project requirements. A picture is worth a thousand words; sometimes a clear diagram can save hours of explanation and back-and-forth discussion.\nPreviously, when drawing diagrams for projects, I often used draw.io. For those who don\u0026rsquo;t know, it\u0026rsquo;s an online tool for drawing diagrams by drag and drop. But every time I needed to update a diagram, I had to drag and drop each box or arrow again, which was quite time-consuming. Until one day, a colleague introduced me to Mermaid, and everything changed\u0026hellip;\nEnlightened by Mermaid According to the definition on the official website, Mermaid is a tool built on JavaScript that helps create diagrams and charts flexibly from text with syntax similar to Markdown.\nAdvantages This is an open-source and completely free tool. It supports many popular types of diagrams and charts such as Flowchart, Sequence diagram, Class diagram, State diagram, Git graph\u0026hellip;\nThe syntax is very simple and easy to learn. If you\u0026rsquo;re already familiar with Markdown, you just need to spend a little time to master it. Now, whenever project requirements change, you only need to edit a few lines of text and the diagram will be updated quickly.\nFor simple diagrams, you can use Mermaid Live Editor without installing anything. For company projects, Mermaid is already integrated with Notion or Atlassian products. If you want to use it locally, Mermaid works right in popular IDEs like Visual Studio Code or JetBrains family.\nComparison with PlantUML There are other tools on the market that render diagrams from text like Mermaid, the most notable being PlantUML. Below is a comparison table for an overview.\nCriteria Mermaid PlantUML GitHub Star (25/2/2024) 65,400 9,300 Diagram types Flow, Sequence, Class, State, Git graph\u0026hellip; Sequence, Usecase, Class, Object, Activity, State\u0026hellip; Online support Yes Yes Offline support Yes Yes Pricing Free Free Others Easy to learn, user-friendly for beginners Many extension libraries Installation on Visual Studio Code Currently, in my project, the team is creating a separate project for diagrams, using Git for version control and Visual Studio Code for drawing.\nYou only need to install 2 extensions: Markdown Preview Mermaid Support and Mermaid Markdown Syntax Highlighting on Visual Studio Code to get started.\nWhenever you need to draw a diagram, create a file with the .md extension and write the Mermaid syntax. You can click the Open Preview button in the top right corner to code and see the diagram updated live beside it. The result is as follows:\nJust check out the example first, and I\u0026rsquo;ll go into detail about the syntax for each type of diagram in the next section.\nSyntax for Common Diagrams Flowchart A flowchart consists of nodes and edges (which can be undirected edges or directed arrows). The Mermaid code will determine how to create the nodes and edges, with customizable edge types according to the drawer\u0026rsquo;s intention.\nSample syntax:\n1 2 3 4 5 flowchart TD A--\u0026gt;B; A--\u0026gt;C; B--\u0026gt;D; C--\u0026gt;D; flowchart: the keyword for this type of chart (you can also use graph interchangeably). TD: the direction of the chart (top to down). Other options include: TB: top to bottom (same as top to down) BT: bottom to top RL: right to left LR: left to right A, B, C, D: the names of the nodes. Besides the default rectangle, you can also use other shapes like rounded rectangles, trapezoids, circles, etc. --\u0026gt;: directed edge type. There are also undirected, bidirectional types, and types with attached text\u0026hellip; Result:\nSequence diagram A sequence diagram is an interaction diagram that shows how different processes operate with each other and in what order.\nSample syntax:\n1 2 3 4 5 6 7 8 9 10 11 12 sequenceDiagram participant Alice participant Bob participant John Alice-\u0026gt;\u0026gt;John: Hello John, how are you? loop Healthcheck John-\u0026gt;\u0026gt;John: Fight against hypochondria end Note right of John: Rational thoughts \u0026lt;br/\u0026gt;prevail! John--\u0026gt;\u0026gt;Alice: Great! John-\u0026gt;\u0026gt;Bob: How about you? Bob--\u0026gt;\u0026gt;John: Jolly good! sequenceDiagram: the keyword for the diagram. participant: defines the participants in the diagram in sequential order. In this example, we have 3 participants: Alice, Bob, and John. Each line defines the message between the participants. -\u0026gt;\u0026gt;, --\u0026gt;\u0026gt;: directed message types with solid and dashed lines. Result:\nClass diagram A class diagram in UML (Unified Modeling Language) is a type of static structure diagram that describes the structure of a system by showing the classes of the system, their attributes, operations (or methods), and the relationships between objects.\nSample syntax:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 classDiagram Class01 \u0026lt;|-- AveryLongClass : Cool Class03 *-- Class04 Class05 o-- Class06 Class07 .. Class08 Class09 --\u0026gt; C2 : Where am i? Class09 --* C3 Class09 --|\u0026gt; Class07 Class07 : equals() Class07 : Object[] elementData Class01 : size() Class01 : int chimp Class01 : int gorilla Class08 \u0026lt;--\u0026gt; C2: Cool label classDiagram: the keyword for the diagram. chimp, gorilla, elementData: attributes of the classes. size(), equals(): methods of the classes. *--, o--: relationships between classes. Result:\nState diagram A state diagram is a type of diagram that describes the behavior of a system, showing some of the system\u0026rsquo;s states.\nSample syntax:\n1 2 3 4 5 6 7 8 stateDiagram [*] --\u0026gt; Still Still --\u0026gt; [*] Still --\u0026gt; Moving Moving --\u0026gt; Still Moving --\u0026gt; Crash Crash --\u0026gt; [*] stateDiagram: the keyword for the diagram. [*]: start or end point. Still, Moving, Crash: the states of the system. --\u0026gt;: state transition steps. Result:\nGit graph A git graph illustrates git commits and git actions (commands) on different branches.\nSample syntax:\n1 2 3 4 5 6 7 8 9 10 gitGraph commit commit branch develop commit commit commit checkout main commit commit gitGraph: the keyword for the graph. commit: creates a new commit on the current branch. branch: creates and switches to a new branch, setting it as the current branch. checkout: checks out an existing branch and sets it as the current branch. merge: merges a branch into the current branch. Result:\nConclusion Mermaid is truly powerful and flexible; it provides us with many options to draw various types of diagrams. However, in this short article, I couldn\u0026rsquo;t introduce all those options to you. If you need more details, you can refer to the Mermaid documentation linked in each title section. I hope you now have an overview of Mermaid and can apply it in your projects or your team\u0026rsquo;s projects, helping save time and effort.\n","date":"2024-02-25T00:00:00+07:00","image":"https://namanh11611.github.io/p/mermaid/mermaid_hu_f3716417371c9c1.webp","permalink":"https://namanh11611.github.io/p/mermaid/","title":"Mermaid - Draw diagrams and charts as easily as candy with Markdown"},{"content":"Vấn đề Gần đây mình có tham gia luyện LeetCode để tìm niềm vui sau những giờ làm việc căng thẳng. Thỉnh thoảng mình gặp một vài bài cần phải áp dụng Binary Search để giải. Dành cho anh em nào chưa biết thì:\nBinary Search là thuật toán tìm kiếm một giá trị target trong mảng đã được sắp xếp. Nó sẽ so sánh target với phần tử chính giữa của mảng (middle), nếu target != middle thì sẽ tiếp tục tìm kiếm trong một nửa mảng có giá trị nhỏ hơn hoặc lớn hơn middle, tuỳ theo điều kiện bài toán. Quá trình này được lặp lại cho đến khi tìm được vị trí của phần tử bằng với target.\nSau mỗi bước tìm kiếm, số lượng phần tử sẽ giảm đi một nửa. Vậy nên độ phức tạp của thuật toán này là O(log n).\nTuy nhiên, khi áp dụng thuật toán này thì mình gặp một số câu hỏi cần trả lời là:\nKhi nào nên dừng vòng lặp? Khi left \u0026lt; right hay left \u0026lt;= right? (left và right là 2 giá trị biên của mảng sau mỗi vòng lặp) Nên update các giá trị biên như thế nào? Dùng left = mid hay left = mid + 1? Dùng right = mid hay right = mid + 1? Nhìn có vẻ đơn giản nhưng việc chọn sai công thức có thể dẫn đến kết quả sai, rồi mình lại phải sửa đi sửa lại rất mất thời gian.\nCho đến một ngày, mình tìm được một công thức thần thánh\u0026hellip;\nTemplate đơn giản Ta\u0026hellip; da\u0026hellip; Tác giả chia sẻ chi tiết về template rất đơn giản nhưng thần thánh ở bài viết này.\nTheo đó, giả sử chúng ta có một search space, nó có thể là một mảng hoặc một khoảng giá trị, thường sẽ được sắp xếp theo thứ tự tăng dần. Nhiệm vụ của chúng ta là tìm giá trị num nhỏ nhất sao cho hàm condition(num) trả về giá trị true.\nTemplate của chúng ta như sau (mình sẽ viết bằng code Java cho đa số mọi người dễ đọc nhé):\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 int binarySearch() { // Bạn tự định nghĩa giá trị khởi tạo của 2 biên int left = min(searchSpace), right = max(searchSpace); while (left \u0026lt; right) { // Viết như thế này để tránh tràn số int mid = left + (right - left) / 2; if (condition(mid)) { right = mid; } else { left = mid + 1; } } // Có thể là left hoặc left - 1 tuỳ yêu cầu bài toán return left; } boolean condition(int num) { // Code check condition } Bạn có thể áp dụng template này vào tất cả các bài binary search, khi đó bạn cần thực hiện 3 việc:\nTìm giá trị left và right phù hợp. Bạn cần chắc chắn rằng 2 giá trị biên này đã bao gồm tất cả các giá trị có thể là kết quả của bài toán. Định nghĩa hàm condition chính xác. Đây thường là phần khó nhất trong các bài binary search phức tạp. Chọn giá trị trả về là left hay left - 1. Nhớ rằng khi kết thúc vòng lặp while, left là index của phần tử nhỏ nhất thoả mãn hàm condition trả về true. Hãy tưởng tượng, chúng ta có dãy số với index từ 0 đến n như sau:\n1 2 Index: 0, 1, ... left - 1, left, ... n - 1, n Condition return: False, False, ... False, True, True, True Vậy nếu bài toán yêu cầu tìm giá trị nhỏ nhất thoả mãn condition return true thì bạn return left, còn nếu yêu cầu tìm giá trị lớn nhất thoả mãn condition return false thì bạn return left - 1.\nÁp dụng vào problem đơn giản Bắt đầu với bài toán tìm căn bậc 2 của số X: Sqrt(x)\nCho một số nguyên không âm x, tìm căn bậc 2 của x, làm tròn xuống số nguyên không âm gần x nhất.\nĐiều kiện: $0 \u0026lt;= x \u0026lt;= 2^{31} - 1$\nVí dụ 1:\n1 2 Input: 4 Output: 2 Ví dụ 2:\n1 2 Input: 8 Output: 2 Chúng ta dễ dàng nhận thấy rằng hàm condition có thể viết như sau:\n1 2 3 boolean condition(int num) { return x / num \u0026lt; num; } Và khi kết thúc vòng lặp while, giá trị cần tìm của chúng ta sẽ là left - 1.\nNhư vậy, đáp án của chúng ta như sau:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public int mySqrt(int x) { if (x \u0026lt; 2) return x; int left = 0; int right = x; while (left \u0026lt; right) { int mid = left + (right - left) / 2; if (x / mid \u0026lt; mid) { right = mid; } else { left = mid + 1; } } return left - 1; } Áp dụng vào problem phức tạp Chúng ta cùng tìm hiểu bài toán sau: Capacity To Ship Packages Within D Days\nMột băng chuyền gồm các gói hàng phải giao từ cổng này tới cổng khác trong vòng D ngày. Gói hàng thứ i có khối lượng là weights[i]. Mỗi ngày, chúng ta chất các gói hàng lên một khay hàng trên băng chuyền theo thứ tự lần lượt được cho bởi mảng weights. Chúng ta không thể chất quá tải trọng của khay hàng.\nTìm tải trọng nhỏ nhất có thể của khay hàng để đảm bảo tất cả các gói hàng được giao trong vòng D ngày.\nĐiều kiện:\n$1 \u0026lt;= D \u0026lt;= weights.length \u0026lt;= 5 * 10^4$\n$1 \u0026lt;= weights[i] \u0026lt;= 500$\nTrước tiên, chúng ta cùng phân tích một chút. Với các bài toán đơn giản như ví dụ trước thì đọc xong đề là chúng ta biết ngay cần phải giải bằng Binary Search rồi. Nhưng đôi khi chúng ta gặp những bài toán phức tạp hơn mà mình còn không biết là cần phải áp dụng Binary Search để giải. Thế là chúng ta đi áp dụng các phương pháp khác như DFS, BFS hay Quy hoạch động để giải, nhưng càng làm càng thấy bí. Như trong bài toán này, ý nghĩ thoáng qua trong đầu mình lúc mới đọc xong đề bài là áp dụng Quy hoạch động.\nVậy dấu hiệu để nhận biết một bài toán có thể giải bằng Binary Search là khi:\nChúng ta nhận thấy đáp án của bài toán có tính đơn điệu, nghĩa là khi condition(k) return true thì condition(k + 1) cũng sẽ return true.\nQuay trở lại với bài toán trên, chúng ta thấy rằng nếu có thể giao toàn bộ các gói hàng trong D ngày với khay hàng có tải trọng M, thì khi chúng ta sử dụng khay hàng có tải trọng lớn hơn M (ví dụ M + 1) thì hoàn toàn vẫn có thể giao trong tối đa D ngày.\nVới hàm condition, chúng ta sẽ sử dụng thuật toán tham lam, tham số là tải trọng của khay hàng được cho trước. Mỗi ngày chúng ta đặt lần lượt các gói hàng lên khay đến khi hết tải trọng, từ đó tính ra tổng số ngày cần thiết để giao toàn bộ hàng, sau đó chúng ta so sánh nó với D, nếu ít hơn hoặc bằng D ngày thì return true, vượt quá thì return false.\nVới hai giá trị biên, tải trọng tối thiểu của khay hàng bằng với khối lượng của gói hàng lớn nhất, để đảm bảo chúng ta có thể giao toàn bộ các gói hàng; còn tải trọng tối đa sẽ bằng tổng khối lượng của toàn bộ hàng, khi đó chúng ta chỉ mất 1 ngày để giao hàng.\nVà đáp án của chúng ta là:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 public int shipWithinDays(int[] weights, int days) { int left = 0; int right = 0; for (int w : weights) { left = Math.max(left, w); right += w; } while (left \u0026lt; maxCap) { int mid = left + (right - left) / 2; if (isValidTime(weights, days, mid)) { right = mid; } else { left = mid + 1; } } return left; } private boolean isValidTime(int[] weights, int days, int capacity) { int totalDay = 1; int curCap = 0; for (int w : weights) { curCap += w; if (curCap \u0026gt; capacity) { totalDay++; curCap = w; } } return totalDay \u0026lt;= days; } Kết luận Hy vọng qua bài viết này, các bạn có thêm tự tin chinh chiến trên đấu trường LeetCode. Kể cả khi gặp các bài khó, chỉ cần bạn nhận ra rằng bài này có thể áp dụng Binary Search, thì có thể copy paste template này vào, sau đó là để đôi bàn tay lướt nhẹ trên bàn phím. Mọi việc còn lại thật quá dễ dàng!\n","date":"2024-02-17T00:00:00+07:00","image":"https://namanh11611.github.io/p/binary-search/binary_search_hu_c5c97885d37535ce.webp","permalink":"https://namanh11611.github.io/p/binary-search/","title":"LeetCode: Binary Search template chinh phục mọi problem"},{"content":"What are Stack and Heap Memory? Memory management is an important factor in programming. Knowing how to optimize memory will help our applications run smoothly, without lag or crashes. The JVM (Java Virtual Machine) divides memory into two parts: Stack and Heap (do not confuse these with the Stack and Heap data structures). In this article, we will learn about the roles, functions, and how each type of memory works.\nStack Memory How it works Stack stores variables of primitive types (int, float, char, boolean\u0026hellip;), local variables, and information about called methods. It operates on a LIFO (Last In First Out) mechanism. This means that methods called last are allocated a frame in the Stack, containing information about parameters, local variables, and the Stack will release that frame when the method returns.\nFor example, with the following code:\n1 2 3 4 5 6 7 8 9 10 11 12 public static void main(String[] args) { doSomething(); } private static void doSomething() { long id = 123456789L; doSomethingElse(); } private static void doSomethingElse() { int age = 23; } The Stack will store information in the following structure:\nThe Stack is used to execute a thread, so the JVM will create a separate stack for each thread. By default, if we do not specify the Stack size, the JVM will create it with a size depending on the operating system and computer architecture (usually 1MB). However, we can use the -Xss flag to customize the Stack size (not exceeding the max size, usually 1GB).\n1 2 3 java -Xss1048576 // 1,048,576 bytes java -Xss1024k // 1,024 KB java -Xss1m // 1 MB StackOverflow A classic error related to the Stack is StackOverflow. It occurs when the amount of data stored in the Stack exceeds its limit.\nFor example, when we call recursion without a stopping condition:\n1 2 3 void callRecursion() { callRecursion(); } You can imagine methods continuously being loaded into the Stack, and at some point, it will exceed the small 1MB size. Therefore, the above code will throw a java.lang.StackOverflowError.\nSome ways to avoid StackOverflow error:\nEnsure recursive functions have a stopping condition or are not called too many times Manage threads carefully Avoid using large local variables Avoid circular dependencies Heap Memory How it works Heap stores variables of Object or array data types. It uses a mechanism of dynamic memory allocation and deallocation. Heap is quite flexible, able to expand or shrink as needed during program execution.\nFor example, when we use the new keyword to create a Student object:\n1 2 3 4 5 6 7 8 9 10 private static void doSomething() { long id = 123456789L; Student student = new Student(); doSomethingElse(); } private static void doSomethingElse() { int age = 23; String str = \u0026#34;Hello World\u0026#34;; } Memory will find a random empty region in the Heap to allocate and store the information of the student object. On the Stack side, there will be a reference variable pointing to the information of the student object in the Heap. For Strings, Heap has a special data structure called the String pool to store them.\nHeap is created when the JVM starts and is used as long as the application is running. Unlike Stack, Heap is shared among all threads.\nBy default, the initial size of the Heap is 256MB and the maximum size is 4068MB. We can also change these parameters using the -Xms (initial size) and -Xmx (maximum size) flags.\n1 2 // Initial heap size = 512MB, Maximum heap size = 1024MB java -Xms512m -Xmx1024m Garbage Collection In Java, Garbage Collection is responsible for reclaiming memory from variables in the Heap that are no longer referenced. This process is performed automatically. In the example above, when we no longer use the student object, Garbage Collection will automatically reclaim the memory previously allocated for it.\nThanks to this mechanism, Heap allows allocation and deallocation of memory for variables with large sizes and complex structures at runtime. If we create too many variables in the Heap but poor code prevents Garbage Collection from reclaiming memory efficiently, it will cause a memory leak.\nGarbage Collection works like a manager in a restaurant. When customers arrive, staff will invite them to an empty table, bring out bowls, chopsticks, and menus (allocate memory). The manager will regularly walk around to check, and if they see a table where customers have finished and left, they will call staff to clean up and prepare for new customers (free memory).\nOutOfMemory When the Heap is full and we cannot allocate memory for a new object, it will throw a java.lang.OutOfMemoryError.\nOur solution is to analyze the code, use profiling tools to detect where memory leaks occur, remove references to objects when they are no longer needed, and let Garbage Collection do its job. Some ways to optimize memory:\nAvoid creating unnecessary objects Reuse objects if possible Choose appropriate data structures Prefer using local variables over global variables Comparison Stack Memory Heap Memory Storage primitive, local variables, method Object, array Access speed Fast Slow Size Small, Fixed Large, Dynamic Usage scope Thread corresponding to Stack All threads Allocation order LIFO Random Variable lifetime From method call to return From creation to Garbage Collection Conclusion In this article, there are still many concepts related to memory that I have not been able to convey. I hope you have a basic understanding of how Stack and Heap memory work, so you can gain more experience in optimizing your application\u0026rsquo;s performance.\n","date":"2024-01-04T00:00:00+07:00","image":"https://namanh11611.github.io/p/stack-heap/stack-heap_hu_b09d382a0255f253.webp","permalink":"https://namanh11611.github.io/p/stack-heap/","title":"Stack and Heap Memory in Java"},{"content":"What is Pomodoro? Recently, my work has shifted a bit, and I find myself in an average of 4 meetings every day. Consequently, I often end up accomplishing very little throughout the day. So, I sought a time management method called Pomodoro to help me focus better on my tasks. It wasn\u0026rsquo;t until I applied it that I realized the actual coding time in a day is not as much as I thought.\nPomodoro is an Italian word, meaning tomato, because when Francesco Cirillo developed this method in the late 1980s, he used a tomato-shaped kitchen timer. In brief, this method consists of several steps:\nSet the tasks to be done. Set a timer for 25 minutes (this time is called a pomodoro). Work on the task. Finish the task and take a 5-minute break. After 4 pomodoros, take a 15-minute break. To apply Pomodoro, there are many apps, extensions, or even web applications available for you to use. You can find the one that suits you best. Personally, I am using the Focus To-Do app on the App Store, which is quite sufficient for my basic needs.\nNow, after applying it for 6 tháng, I want to share with you the benefits it brings, as well as the points I think it may not be suitable.\nImproving Focus Previously, there were days when I was extremely focused for 4-5 consecutive hours, which helped me accomplish a lot of tasks. However, after such days, I often felt quite tired.\nBut there were also days when I spent the whole hour reading news, scrolling through Facebook, and suddenly realized I hadn\u0026rsquo;t accomplished anything.\nThe human brain is truly effective when concentrated for a short period with reasonable breaks. Applying Pomodoro, knowing I only need to focus for 25 minutes, a not too long duration, allows me to fully concentrate on the task without worrying about getting tired at the end of the day. I also know that after these 25 minutes, I will have a break, so there\u0026rsquo;s no temptation to turn to Facebook during work.\nDuring one pomodoro, you should only focus on one task. For example, if you are working on task A, only work on task A. If you finish it before the pomodoro ends, spend the remaining time checking it again, but don\u0026rsquo;t jump to task B.\nImproving Health When it\u0026rsquo;s time for a 5-minute break, instead of continuing to stare at the computer, I usually take the time to go to the restroom, get more water, change my playlist, or simply stand up and move around. This helps relax my body, avoiding health issues from sitting for too long.\nHowever, I find the 5-minute duration a bit short; sometimes, I haven\u0026rsquo;t done anything, and it\u0026rsquo;s already over in 5 minutes. Therefore, in the future, I may consider adjusting it to 7 or 8 minutes and see how it goes.\nIgnoring the World According to the rule, during the 25-minute focused period, you should turn off all app notifications to avoid distraction. However, I haven\u0026rsquo;t reached the point of being able to ignore the whole world because I still need to receive chat notifications to respond to customers and colleagues promptly.\nHowever, this often disrupts my Pomodoro because I have to spend additional time checking code or documents to be able to respond to people.\nConclusion This method may be suitable for me but may not necessarily be suitable for you. Adhering to Pomodoro has helped me increase work efficiency, but sometimes it makes me feel like I\u0026rsquo;m working like a machine. Try applying it and see the results it brings for you.\n","date":"2023-12-23T00:00:00+07:00","image":"https://namanh11611.github.io/p/pomodoro/pomodoro_hu_989b0ee64f04137a.webp","permalink":"https://namanh11611.github.io/p/pomodoro/","title":"6-Month Journey Applying the Pomodoro Technique"},{"content":"Besides learning through tutorials and videos, technical blogs are a great resource. By reading blogs from software engineers at major companies, you can see how they solve the problems they\u0026rsquo;ve encountered. In the age of AI, with tools like Copilot or Tabnine ready to generate code to support you, engineers are no longer distinguished by their ability to remember the syntax of a language or framework, but by their problem-solving skills. So, in this article, I will introduce you to the blogs of major companies, hoping you will gain some interesting perspectives.\nYou can click on the title of each section to go to the blog.\nMeta Meta (formerly known as Facebook) has many products like Facebook, Instagram, Whatsapp\u0026hellip; On this blog, they share about everything from Android, iOS, Web to more challenging topics like VR/AR or AI.\nGoogle On this homepage, you can choose one of four areas you are interested in: Mobile, Web, AI, or Cloud. Google will then introduce you to detailed articles in that field.\nGoogle also creates many courses about their technologies. Each course includes videos, detailed explanatory articles, and example exercises for you to follow. When you finish, you can earn a small badge. Quite fun!\nNetflix In recent years, Netflix has become a household name as a platform for movies and TV shows. Instead of just Netflix and chill, try reading their blog to see how they build a system that serves millions of users.\nDropbox Similar to Google Drive, Dropbox is a cloud storage service that helps you store files online and sync them across devices.\nThrough their blog, you can learn how to optimize memory and bandwidth when sharing files.\nTwitter \u0026ldquo;Design a system like Twitter\u0026rdquo; is a classic question in System Design interviews. So, Twitter\u0026rsquo;s blog is a useful reference when preparing for interviews. You can see if your ideas match how Twitter actually does things.\nRecently, after being acquired by Elon Musk, Twitter even open-sourced their Recommendation Algorithm.\nUber Although Uber has left the Vietnamese market after merging with Grab, it is still the largest taxi company in the world. Therefore, their blog is very suitable for those working in companies with similar business areas in Vietnam.\nSpotify I remember when Spotify first launched in Vietnam, everyone was amazed by its recommendation capabilities.\nSpotify\u0026rsquo;s recommender system is a complex system, combining many algorithms and Machine Learning models. Through this blog, hopefully you will discover part of that system.\nLINE LINE is one of my former companies. Although it may not be as top-tier as the others above, the sharing culture is very strong. So, through this article, I want to introduce you to the technical blog of engineers at LINE.\n","date":"2023-05-24T00:42:00+07:00","image":"https://namanh11611.github.io/p/technical-blog/blog_hu_f0070cee8374b8e7.webp","permalink":"https://namanh11611.github.io/p/technical-blog/","title":"Technical Blogs of Engineers at Major Companies"},{"content":"Who am I? Hello everyone!\nI\u0026rsquo;m Nam Anh, an Android developer with 5 years of experience. During those 5 years, I\u0026rsquo;ve wandered through quite a few tech companies in Hanoi.\nThis is probably the first time I\u0026rsquo;ve written an article from such a personal perspective. So you might wonder: \u0026ldquo;Who is this guy to be giving life advice?\u0026rdquo;\nOops, I\u0026rsquo;m not here to lecture anyone, just to share things that I found true for myself. Maybe for you, they\u0026rsquo;re right or wrong. But who knows, maybe some Juniors will gain a new perspective to improve their career path.\nThe Lucky Things There are things that, when they happened, I didn\u0026rsquo;t realize were right until I looked back later and thought: \u0026ldquo;Oh, turns out I did the right thing back then.\u0026rdquo; And I feel those were real strokes of luck for me.\nReading Clean Code right after graduation I have to admit, I used to love reading books and read quite a lot, all kinds of genres. But I read very few tech books, probably because my English was limited 😢😢\nBut the tech book I value the most is Clean Code. As the name suggests, it teaches you how to write \u0026ldquo;clean code\u0026rdquo;, a fundamental book highly recommended by many. I don\u0026rsquo;t know who convinced me to read it right after graduation, but I read it and took notes summarizing the book. I still keep those notes to this day. Learning from the book, plus a bit of OCD, I think I\u0026rsquo;ve applied quite a bit of it to the projects I\u0026rsquo;ve worked on.\nSome people advise reading Clean Code once when you just graduate, and again after a few years of working, so you can really absorb its content. So I highly, highly recommend everyone read it, whether you\u0026rsquo;re a junior or a seasoned senior.\nWorking at product companies with strict processes There are already many articles comparing product and outsourcing companies, so I won\u0026rsquo;t repeat that. I\u0026rsquo;ve worked at both types. In this article, I just want to mention code review processes and product mindset.\nFrom my experience, big product companies have more time for thorough code reviews, not as rushed by deadlines as outsourcing companies. I\u0026rsquo;m only talking about big product companies, because I\u0026rsquo;ve also worked at small startups where the only goal was to get the code running, clean or dirty didn\u0026rsquo;t matter.\nThe knowledge I learned from Clean Code was just theory until I joined big product companies and had seniors carefully review my code. That\u0026rsquo;s when I really matured in every line I wrote.\nAnother thing I learned is the product mindset—always thinking about the product, wanting it to be better and have more users. When I had an idea for a feature, I was ready to propose it to the leader or Product Manager. The feeling when you finish a feature and see users leaving positive comments on the App Store or Play Store is amazing 😍😍\nDaring to step out of my comfort zone In 5 years, I\u0026rsquo;ve switched jobs many times like many others. I don\u0026rsquo;t know about you, but I fear staying at one company too long, getting too comfortable, and then struggling to catch up with the market\u0026rsquo;s demands when I want to switch.\nSo moving through many companies helped me adapt to different projects, understand what the market needs, and of course, get a better income.\nThings I Wish I Knew Sooner Stay at a company long enough Contrary to what I said above, here I want to advise young people to stay at a company long enough. In my opinion, at least 1-2 years. It gives you enough time to understand the project and be properly recognized.\nUsually, when you join a project, it takes a few months to understand it. For complex projects, it can take years. Understanding here means not just the technologies used in the source code, but also the business domain, how your app makes money, or even its competitive advantage over others. Some seniors, even when switching companies, only work in banking or fintech, for example. So besides technical skills, they\u0026rsquo;re valued for their business domain knowledge.\nCompanies often give out Best Employee awards at Year End Parties, but to be recognized, you have to stay long enough to make an impact. It\u0026rsquo;s rare for a company to give such an award to someone who just finished their probation, unless you\u0026rsquo;re a superstar. Achieving these things proves your ability and makes your profile shine.\nThere were times I only stayed at a company for a few months before leaving, and I felt that was a bit of a waste.\nTake English seriously, sooner Everyone knows how important English is for a developer\u0026rsquo;s career. If you can communicate well in English, you have more options: working for foreign companies in Vietnam, working remotely from home, or even going abroad. And a dev with good English communication skills will definitely earn more than one who can only read and understand.\nI graduated with a TOEIC 460—just enough for basic reading. In recent years, I\u0026rsquo;ve started learning English seriously, and now I can communicate well with foreign colleagues. This has brought me many new opportunities.\nI swear this post isn\u0026rsquo;t an ad for the Elsa app, but it\u0026rsquo;s really good so I\u0026rsquo;m recommending it. Here\u0026rsquo;s my 88-day learning streak (I missed a day before and lost my streak 🥲).\nMy English still isn\u0026rsquo;t great, so I\u0026rsquo;m learning every day. I\u0026rsquo;ve tried several apps—Duolingo, Memrise, Cake\u0026hellip; and now I use Elsa along with others. But Elsa has helped me improve the most.\nThe difference comes after 8pm There are two devs, A and B, working at the same company from 8am to 6pm. So what makes the difference between them?\nIt comes after 8pm. Dev A spends that time learning new technologies, working on pet projects, or contributing to open source projects. Dev B spends it playing games or drinking. Maybe in the first few years, the difference isn\u0026rsquo;t clear, but after 3 or 5 years, the gap in knowledge and skills will be huge.\nWork at the company is sometimes easy, so you can only learn harder things or new technologies in your free time. For example, if your job is just UI work, you won\u0026rsquo;t need to understand systems or memory deeply. If you don\u0026rsquo;t spend time learning, how can you stand out from your colleagues?\nIn my early years, I also spent a lot of time drinking. I can\u0026rsquo;t deny the importance of building relationships through those gatherings. But if I could choose again, I\u0026rsquo;d spend more time at home learning.\nFinal Words On my journey, there were times I made the right decisions, but also plenty of times I chose wrong. But the important thing is I don\u0026rsquo;t regret or dwell on the past—I keep learning and moving forward. I think that\u0026rsquo;s enough.\nThank you for taking the time to read my article!\n","date":"2023-05-18T18:44:00+07:00","image":"https://namanh11611.github.io/p/junior/junior_hu_cdd359dc0d6e369b.webp","permalink":"https://namanh11611.github.io/p/junior/","title":"Things I Wish I Knew When I Was a Junior"},{"content":"Concept First, we need to understand the purpose of DataStore.\nCurrently, in Android apps, there are 5 ways to store data, with SharedPreferences being the simplest for storing data. It only consists of key and value, where the value can be an integer, string, etc.\nWhen the app is opened for the first time, it reads all values from the SharedPreferences XML file and loads them into RAM. This file reading process happens on the UI Thread. If there are too many values and the task takes more than 5 seconds, it will cause an ANR (Application Not Responding) error.\nAnd DataStore was created to replace SharedPreferences.\nDataStore is a solution for storing data as key-value pairs or typed objects with protocol buffers.\nOf course, DataStore is still only for storing simple structured data. It uses Coroutines and Flow to store data asynchronously and consistently.\nDataStore has 2 types: Preferences DataStore and Proto DataStore. Let\u0026rsquo;s look at the comparison table:\nPreferences DataStore Proto DataStore Store and access data by key Store instances of a custom data type No need to define data type in advance Must define data type in advance with protocol buffers No type safety Has type safety Preferences DataStore Create To use Preferences DataStore, we need to create an instance of DataStore\u0026lt;Preferences\u0026gt; using a property delegate with the preferencesDataStore keyword.\n1 2 3 // At the top level of your kotlin file val Context.dataStore: DataStore\u0026lt;Preferences\u0026gt; by preferencesDataStore(name = \u0026#34;settings\u0026#34;) Read First, there are 7 functions corresponding to 7 data types:\nintPreferencesKey() longPreferencesKey() doublePreferencesKey() floatPreferencesKey() booleanPreferencesKey() stringPreferencesKey() stringSetPreferencesKey() When reading data, use the function corresponding to the value you want to store. For example, to store a counter variable as an integer to count how many times the user opens the app:\n1 2 3 4 5 6 val OPEN_APP_COUNTER = intPreferencesKey(\u0026#34;open_app_counter\u0026#34;) val openAppCounterFlow: Flow\u0026lt;Int\u0026gt; = context.dataStore.data .map { preferences -\u0026gt; // No type safety. preferences[OPEN_APP_COUNTER] ?: 0 } The difference from SharedPreferences is that here, data is returned as a Flow. Now, upper layers like Repository can observe data consistently, regardless of whether it comes from DataStore, Room database, or Server, because everything is returned as a Flow.\nWrite To write data, use the edit function, which is quite similar to SharedPreferences.\n1 2 3 4 context.dataStore.edit { settings -\u0026gt; val openAppCounterValue = settings[OPEN_APP_COUNTER] ?: 0 settings[OPEN_APP_COUNTER] = openAppCounterValue + 1 } Proto DataStore Before learning about Proto DataStore, let\u0026rsquo;s take a look at protocol buffers.\nProtocol buffers This is a data format that is independent of programming language or platform. It\u0026rsquo;s like JSON but much smaller and faster. Protocol buffers are also said to be the most widely used data format at Google.\nUsed to store compact data Fast parsing Supports many programming languages like C++, C#, Dart, Go, Java, Kotlin, Python Optimizes functionality through auto-generated classes For example, a message about user info with name, id, and email:\n1 2 3 4 5 message UserProfile { optional string name = 1; optional int32 id = 2; optional string email = 3; } To compare the performance of Protocol buffers and JSON, let\u0026rsquo;s make 500 GET requests from one Spring Boot app to another, with and without data compression. Here are the results:\nWe can see Protocol buffer is 5 to 6 times faster than JSON.\nCreate To use Proto DataStore, you must define the data type with a proto file settings.pb in the folder app/src/main/proto/ like this:\n1 2 3 4 5 6 syntax = \u0026#34;proto3\u0026#34;; option java_package = \u0026#34;com.example.application\u0026#34;; option java_multiple_files = true; message Settings { int32 open_app_counter = 1; } Next, declare an object implementing the Serializer\u0026lt;T\u0026gt; class, where T is the data type defined in the proto file.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 object SettingsSerializer : Serializer\u0026lt;Settings\u0026gt; { override val defaultValue: Settings = Settings.getDefaultInstance() override suspend fun readFrom(input: InputStream): Settings { try { return Settings.parseFrom(input) } catch (exception: InvalidProtocolBufferException) { throw CorruptionException(\u0026#34;Cannot read proto.\u0026#34;, exception) } } override suspend fun writeTo( t: Settings, output: OutputStream ) = t.writeTo(output) } Finally, use the property delegate with the dataStore keyword to create an instance of DataStore\u0026lt;T\u0026gt;.\n1 2 3 4 val Context.settingsDataStore: DataStore\u0026lt;Settings\u0026gt; by dataStore( fileName = \u0026#34;settings.pb\u0026#34;, serializer = SettingsSerializer ) Read Similar to Preferences DataStore, use DataStore.data to return a Flow.\n1 2 3 4 5 val openAppCounterFlow: Flow\u0026lt;Int\u0026gt; = context.settingDataStore.data .map { settings -\u0026gt; // The openAppCounter is generated from the proto schema. settings.openAppCounter } Write To write data to Proto DataStore, use the updateData() function.\n1 2 3 4 5 context.settingsDataStore.updateData { currentSettings -\u0026gt; currentSettings.toBuilder() .setExampleCounter(currentSettings.exampleCounter + 1) .build() } Comparison with SharedPreferences Migrate from SharedPreferences to Preferences DataStore To migrate, pass SharedPreferencesMigration to the produceMigrations parameter. DataStore will automatically migrate for you.\n1 2 3 4 5 6 7 8 9 val Context.dataStore: DataStore\u0026lt;Preferences\u0026gt; by preferencesDataStore( name = DATA_STORE_NAME produceMigrations = { context -\u0026gt; listOf(SharedPreferencesMigration( context, SHARED_PREFERENCES_NAME )) } ) Migrate from SharedPreferences to Proto DataStore First, declare UserProfile and UserProfileSerializer as above. Then write a mapping function to migrate from key-value pairs in SharedPreferences to the data type in Proto DataStore.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 val Context.dataStore: DataStore\u0026lt;UserProfile\u0026gt; by dataStore( fileName = \u0026#34;settings.pb\u0026#34;, serializer = UserProfileSerializer, produceMigrations = { context -\u0026gt; listOf( SharedPreferencesMigration( context, \u0026#34;settings_pref\u0026#34; ) { prefs: SharedPreferencesView, user: UserProfile -\u0026gt; user.toBuilder() .setName(prefs.getString(NAME_KEY)) .setId(prefs.getInt(ID_KEY)) .setEmail(prefs.getString(EMAIL_KEY)) .build() } ) } ) References https://developer.android.com/topic/libraries/architecture/datastore https://protobuf.dev/programming-guides/proto3 https://android-developers.googleblog.com/2020/09/prefer-storing-data-with-jetpack.html https://stackoverflow.com/questions/9986734/which-android-data-storage-technique-to-use https://auth0.com/blog/beating-json-performance-with-protobuf https://proandroiddev.com/is-jetpack-datastore-a-replacement-for-sharedpreferences-efe92d02fcb3 https://kinya.hashnode.dev/migrating-sharedpreferences-to-datastore-ckxzlvda101by8rs1c8bg4wdx https://amitshekhar.me/blog/jetpack-datastore-preferences ","date":"2023-05-14T15:41:00+07:00","image":"https://namanh11611.github.io/p/data-store/datastore_hu_c94a00668dbd6712.webp","permalink":"https://namanh11611.github.io/p/data-store/","title":"DataStore - The Perfect Piece for the Kotlin Coroutines Puzzle"},{"content":"Concept I didn\u0026rsquo;t know about the Delegation Pattern until I learned Kotlin and saw people using the by keyword when declaring a variable. So I tried to learn more and discovered a whole new world of this pattern.\n~~ A bit dramatic, isn\u0026rsquo;t it? 😅😅 ~~\nTo make it easy to understand, Delegation means assigning tasks to someone else. But let\u0026rsquo;s just use the terms \u0026ldquo;delegation\u0026rdquo; and \u0026ldquo;delegate\u0026rdquo; to keep things clear and professional, especially in work or interviews.\nThe Delegation Pattern is an object-oriented design pattern that allows object composition to achieve the same code reuse as inheritance.\nIn short: Delegation Pattern allows objects to reuse code similarly to inheritance.\nIn delegation, there are two components:\nReceiving object Delegate object When a request needs to be handled, the receiving object doesn\u0026rsquo;t handle it directly but delegates the task to the delegate object. It\u0026rsquo;s like having an older brother or sister who\u0026rsquo;s really good at math, and every time the teacher gives you homework, you ask them to do it for you.\nSo how is this different from Inheritance? In inheritance, you can also call methods from the parent class, right?\nThat\u0026rsquo;s true, but inheritance should only be used when the child class is truly related to the parent class. For example, a Cat class can inherit from Animal, but shouldn\u0026rsquo;t inherit from Transportation. Also, the child class must override all abstract methods of the parent, which is sometimes unnecessary. Delegation gives us more flexibility.\nExample Illustration Back to the earlier example, suppose you have a brother who\u0026rsquo;s an engineer and a sister who\u0026rsquo;s a doctor. They\u0026rsquo;re both very talented.\n1 2 3 4 5 6 7 8 9 10 11 interface TalentPerson { fun doHomework() } class Engineer : TalentPerson { override fun doHomework() {} } class Doctor : TalentPerson { override fun doHomework() {} } You\u0026rsquo;re a bit of a lazy student, so you need a helper class, with a parameter being a kind person who\u0026rsquo;s always ready to help you out.\n1 2 3 4 5 class LazyStudentHelper(private val kindPerson: TalentPerson) { fun doHomeworkByMyself() { kindPerson.doHomework() } } Now, every time the teacher gives homework, you can ask your brother or sister to do it for you.\n1 2 3 4 5 6 7 8 9 fun main() { val brother = Engineer() val lazyBoy = LazyStudentHelper(brother) lazyBoy.doHomeworkByMyself() val sister = Doctor() val lazyGirl = LazyStudentHelper(sister) lazyGirl.doHomeworkByMyself() } Delegation Pattern in Kotlin The by Keyword in Kotlin Kotlin supports the Delegation Pattern through the by keyword, which helps reduce boilerplate code.\n1 2 3 4 5 6 7 8 9 10 11 12 13 class LazyStudentHelper( private val kindPerson: TalentPerson ): TalentPerson by kindPerson fun main() { val brother = Engineer() val lazyBoy = LazyStudentHelper(brother) lazyBoy.doHomework() val sister = Doctor() val lazyGirl = LazyStudentHelper(sister) lazyGirl.doHomework() } Now, the LazyStudentHelper class must implement the TalentPerson interface, so it can delegate the doHomework method to the kindPerson instance.\nDelegated Properties There are several ways to use Delegation when declaring variables in Kotlin:\nLazy properties: the value is computed the first time it is accessed. Observable properties: listeners are notified when the property changes. Lazy properties lazy is a function that takes a lambda and returns an instance of the Lazy\u0026lt;T\u0026gt; class.\n1 2 3 4 5 6 7 8 9 val lazyValue: String by lazy { println(\u0026#34;computed!\u0026#34;) \u0026#34;Hello\u0026#34; } fun main() { println(lazyValue) println(lazyValue) } The first time lazyValue is called, the result is computed and stored. Subsequent calls just return the stored value. So the output will be:\n1 2 3 computed! Hello Hello Observable properties 1 2 3 4 5 6 7 8 9 10 11 12 13 import kotlin.properties.Delegates class User { var name: String by Delegates.observable(\u0026#34;\u0026lt;no name\u0026gt;\u0026#34;) { prop, old, new -\u0026gt; println(\u0026#34;$old -\u0026gt; $new\u0026#34;) } } fun main() { val user = User() user.name = \u0026#34;first\u0026#34; user.name = \u0026#34;second\u0026#34; } Delegates.observable() takes two arguments:\nThe initial value A function to handle changes to the name variable. It\u0026rsquo;s called every time you assign a value to the variable. The result will be:\n1 2 \u0026lt;no name\u0026gt; -\u0026gt; first first -\u0026gt; second Reference https://en.wikipedia.org/wiki/Delegation_pattern https://kotlinlang.org/docs/delegation.html https://kotlinlang.org/docs/delegated-properties.html ","date":"2023-05-12T16:50:00+07:00","image":"https://namanh11611.github.io/p/design-pattern-delegation/delegation_hu_19215d2224056735.webp","permalink":"https://namanh11611.github.io/p/design-pattern-delegation/","title":"Design Pattern: Delegation in Kotlin - how to get someone else to do your homework"},{"content":"Hoàn cảnh Hôm vừa rồi một người em bên Nhật chia sẻ với mình rằng muốn mở công ty ở Việt Nam, nhưng chưa hiểu về thị trường hiện tại ở Việt Nam lắm. Mình đành dốc hết những kiến thức nông cạn của mình ra chia sẻ với em về môi trường, công việc cũng như lương thưởng của anh em dev ở Hà Nội, thành phố Hồ Chí Minh và Đà Nẵng\u0026hellip;\nDẫu biết rằng thị trường đang ảm đạm, làn sóng sa thải cũng đã lan đến Việt Nam từ cuối năm 2022 đến thời điểm hiện tại là tháng 5/2023, nhưng thật sự chưa có một báo cáo đáng tin cậy để đánh giá về tình hình năm 2023 này. Vậy nên mình sẽ dựa vào báo cáo gần nhất của 2 bên TopDev và ITViec trong năm 2022 để đưa ra góc nhìn về mức lương thưởng của anh em.\nTrong báo cáo của TopDev có đưa ra cả đánh giá về tình hình tuyển dụng, nhưng mình nghĩ rằng gió đã đổi chiều nên những đánh giá đó không còn chính xác trong năm 2023 này. Còn về lương thưởng, khác với tình hình năm 2020 khi các công ty giảm lương nhân viên để vượt qua giai đoạn khó khăn, trong năm 2023 này, hầu hết các công ty chỉ đưa ra lựa chọn giữ người hoặc sa thải, vậy nên mức lương của những người ở lại sẽ ít bị ảnh hưởng.\nITViec khảo sát 1.257 chuyên gia IT còn TopDev thì dựa trên 48.179 ứng viên IT, 100.000 dữ liệu việc làm được phân tích và thông tin của 2.500 nhà tuyển dụng. Bởi vì khảo sát với một volumn nhỏ thì sẽ có sự sai lệch nhất định so với thị trường, vậy nên mình mới dùng báo cáo của cả 2 bên để mong rằng giảm tối đa sự sai lệch đó và giúp chúng ta có một góc nhìn khách quan nhất.\nMức lương theo công nghệ Trong biểu đồ trên, TopDev thể hiện mức lương của các dev từ 3 năm kinh nghiệm trở xuống. Vậy nên mình thấy nó hơi thấp và không phản ánh được mức lương của senior dev có từ 4-5 năm kinh nghiệm trở lên.\nTop công nghệ được trả lương cao nhất gồm các công nghệ theo xu hướng như AI (Kubernetes, TensorFlows, Python), Cloud Computing (AWS, GCP, Azure). Unity cũng lọt top nhờ trend play-to-earn nổi đình nổi đám trong năm 2022.\nBảng số liệu của ITViec thể hiện chi tiết hơn mức lương cho từng ngôn ngữ lập trình theo số năm kinh nghiệm. Python vẫn là một trong những ngôn ngữ được trả lương cao, nhưng Go - một ngôn ngữ đang trở thành trending - mới là vũ khí giúp anh em dev được trả lương cao nhất.\nMức lương theo vị trí Biểu đồ này của TopDev vẫn thể hiện mức lương của các dev từ 3 năm kinh nghiệm trở xuống.\nCác vị trí CTO, CIO hoặc Tech Management vốn vẫn được coi là mục tiêu nghề nghiệp cao nhất, họ phải nắm các kỹ năng cơ bản vững chắc, xử lý các công việc quản lý, tối ưu hóa công nghệ / sản phẩm và điều chỉnh kịp thời.\nCác vị trí được trả lương cao tiếp theo yêu cầu các kỹ năng đặc biệt như Data, Cloud, DevOps hoặc AI.\nTrong bảng số liệu của ITViec, các vị trí trên vẫn được trả mức lương rất tốt. Nhưng đối với các dev từ 5 năm kinh nghiệm trở lên trong lĩnh vực khác (Front-end, Mobile), họ cũng được trả mức lương không hề kém cạnh.\nĐiều này chứng minh rằng bạn không cần phải luôn chạy theo những công nghệ hot, chỉ cần bạn đủ giỏi, thì với vị trí nào, bạn cũng được trả mức lương tương xứng.\nMức lương theo trình độ TopDev chỉ đưa ra một biểu đồ chung về mức lương theo số năm kinh nghiệm. Trong 5 năm đầu tiên, lương của lập trình viên dao động từ $350 (Fresher) đến dưới $1.190 cho Mid-Senior. Đối với các lập trình viên từ 5 năm kinh nghiệm, mức lương chênh lệch chủ yếu dựa trên vị trí và trách nhiệm đối với hoạt động kinh doanh. Giám đốc hoặc cấp cao hơn sẽ có mức lương ít nhất là $2.300. Mức lương của cấp quản lý kỹ thuật sẽ cao hơn so với cấp quản lý/giám đốc theo định hướng kinh doanh.\nMức lương theo thành phố Có lẽ nhiều anh em cũng đã biết trước kết quả về bảng số liệu này của ITViec. Nhìn chung thì mức lương ở thành phố Hồ Chí Minh cao hơn Hà Nội, và Hà Nội thì lại cao hơn Đà Nẵng.\nTheo mình có lẽ vì thành phố Hồ Chí Minh gồm nhiều công ty product và outsource làm với thị trường nói tiếng Anh hơn. Còn ở Hà Nội vẫn gồm nhiều các công ty làm cho thị trường Nhật. Tuy nhiên trong giai đoạn gần đây, đã có nhiều công ty từ thành phố Hồ Chí Minh Bắc tiến ra Hà Nội, điều đó cũng đã giúp thị trường ở Hà Nội nhộn nhịp hơn rất nhiều.\nLời kết Cũng phải nhìn nhận rằng, những anh em không may bị sa thải trong giai đoạn này sẽ phải tìm một công việc mới và có thể phải chấp nhận một mức lương thấp hơn mức cũ. Điều đó cũng góp phần làm cho mức lương của thị trường hiện tại thấp hơn mức trong khảo sát.\nNhưng mình hy vọng rằng dựa vào báo cáo này, anh em có thêm một góc nhìn khác về thị trường, để biết cách trau dồi bản thân, rèn luyện kỹ năng. Và sau cơn mưa trời lại sáng, khi thị trường sôi động trở lại, với những kỹ năng đã được nâng cấp, anh em sẽ nhận được một mức lương xứng đáng với năng lực.\nReference https://topdev.vn/page/bao-cao-it-viet-nam https://itviec.com/blog/bao-cao-luong-it ","date":"2023-05-10T01:40:00+07:00","image":"https://namanh11611.github.io/p/salary/salary_hu_2ea7738ba86cd07e.webp","permalink":"https://namanh11611.github.io/p/salary/","title":"Tình hình lương thưởng của anh em IT"},{"content":"Introduction When I first heard about Kotlin Multiplatform (hereafter KM), I thought, “What kind of technology only shares logic code? If you want to code fast, just use Flutter, the performance isn’t bad at all.” But then, life pushed me into a project using KM, and I was truly enlightened about its pros and cons. So, over a drink under the moon, let me share a few words with you.\nWhat is Kotlin Multiplatform? KM makes developing cross-platform projects as light as a feather. It helps reduce the time spent writing and maintaining code while keeping the advantages of native for each platform. Kotlin apps can run on Android, iOS, macOS, Windows, Linux, watchOS\u0026hellip;\nAlthough KM is still in Beta, it’s quite stable and has been adopted by companies like 9gag, Netflix, Philips, Baidu, VMWare, Quizlet, Memrise\u0026hellip;\nBack to the question: what advantages does KM have over other cross-platform frameworks?\nKM is really suitable for projects with complex logic code. We all know that the more code you write, the more bugs you create. The only way to avoid bugs is No Code. So instead of Android devs writing logic for Android and iOS devs writing logic for iOS, now you only need to write logic once in KM, which already cuts bugs in half.\nFor example, if a project needs 10 Android devs and 10 iOS devs, with KM you only need 5 Android devs, 5 iOS devs, and 5 KM devs (who can also be Android devs). That means the project reduces resources by 25%. Compared to Flutter, of course, you still need more resources, but in return you get native performance.\nUse Cases Android and iOS apps You can share business logic code between platforms to build a cross-platform mobile app. This is currently the main use case for KM. For example, you can write code from ViewModel to Data layer in KM, while the Android and iOS apps just build UI with Jetpack Compose and SwiftUI.\nFull-stack web app You might not know, but Kotlin can now be used to write front-end web apps. So you can build a full-stack web app with the server using Kotlin/JVM and the web client using Kotlin/JS. Therefore, you can use KM to reuse logic code for both server and client.\nMultiplatform libraries If Kotlin can build for Android, iOS, and web, why not write a library usable on all three? For projects that need both app and web, try using KM to write common code, publish it as a library, and import it as a dependency in your app or web project.\nCommon code for mobile and web apps You don’t even need to create a library; you can write code directly to share between Android, iOS, desktop, and web apps. This reduces the workload for mobile and front-end web devs, since you only write logic code once. It also reduces bugs and testing time.\nHow it works So how does KM share code across all platforms?\nCommon Kotlin is the code that includes core libraries and can run on all platforms. With KM libraries, you can reuse multiplatform logic in common and platform-specific code. Platform-specific code (Kotlin/JVM, Kotlin/JS, Kotlin/Native) includes extensions for Kotlin, platform-specific libraries, and tools. For each platform, you can leverage platform native code (JVM, JS, and Native). For example, to write a function to generate a UUID for both Android and iOS, you can declare a function with the expect keyword in the common module:\n1 2 // Common expect fun randomUUID(): String Then, for each platform, you implement the function with the actual keyword:\n1 2 3 4 // Android import java.util.* actual fun randomUUID() = UUID.randomUUID().toString() 1 2 3 4 // iOS import platform.Foundation.NSUUID actual fun randomUUID(): String = NSUUID().UUIDString() Under the Hood My project applies KM for Android and iOS apps. I wondered how Kotlin could integrate with iOS apps written in Swift.\nJetBrains’ answer is that they use Kotlin/Native to compile Kotlin code to native binaries, so you can run Kotlin code without a virtual machine. It includes an LLVM-based backend for the Kotlin compiler and a native implementation of the Kotlin standard library.\nKotlin/Native is designed to compile for platforms that can’t run a virtual machine, like embedded devices or iOS.\nOn Android, Kotlin code is compiled to JVM bytecode using Kotlin/JVM.\nConclusion In the future, JetBrains isn’t stopping at Kotlin Multiplatform—they’re planning to develop Compose Multiplatform, which means you’ll be able to share UI as well as logic code, just like other cross-platform frameworks (Flutter, React Native). That’s a long journey ahead, so let’s sit down, have a big meal and a big drink, and see what the future holds.\nReference https://kotlinlang.org/docs/multiplatform.html https://kotlinlang.org/docs/multiplatform-mobile-faq.html#what-is-kotlin-native-and-how-does-it-relate-to-kotlin-multiplatform ","date":"2023-05-07T13:37:00+07:00","image":"https://namanh11611.github.io/p/kotlin-multiplatform/kotlin_hu_3d14c000b6f92553.webp","permalink":"https://namanh11611.github.io/p/kotlin-multiplatform/","title":"Kotlin Multiplatform – A Challenger to Flutter, React Native?"},{"content":"Case study The first story At my previous company (let\u0026rsquo;s call it company A), the project source code was huge—just cloning it was 40GB, and after compiling and building, it reached nearly 100GB. Every time someone coded a feature, they would usually checkout a new branch like feature_x. For small features, it was fine, but for big features that changed dozens or even hundreds of files, merging into the main branch was a nightmare because you had to resolve conflicts from other feature branches that had been merged earlier.\nThe second story At another company (company B), due to the nature of the project, it was split into 5 small teams, each with about 3 developers. Each team was responsible for a few features in a sprint. At the start of the sprint, the dev lead would create a branch for each team, and after the sprint, all 5 branches would be merged. The same problem occurred: merging code resulted in a lot of conflicts, and teams had to spend time retesting their features to ensure no bugs appeared after merging.\nSo what is Trunk Based Development? In short, Trunk Based Development (from now on, TBD) is a source-control branching model where all developers work on a single branch called the trunk (like the trunk of a tree), avoiding the creation of huge feature branches. The trunk branch must always be ready for release at any time. In projects, people usually name the trunk branch master or dev.\nTBD is divided into two smaller models, suitable for different team sizes. Let\u0026rsquo;s explore them.\nTBD for small teams In this model, the whole dev team pushes code directly to the trunk branch. However, this model carries a big risk for code quality, since code is pushed directly without review. To use this model, devs must have strong technical skills to ensure every line they push doesn\u0026rsquo;t introduce bugs for the team.\nPersonally, I think this model is only suitable for teams of 5 or fewer.\nTBD for large teams With TBD for a large team, feature branches are still created, but the difference is they only exist for a short time—just a few commits before merging back to the trunk branch.\nFor example, when assigned to code the Onboarding feature, with the usual Git flow, you might:\nCreate a feature/onboarding branch Code the Welcome screen and commit Code the Register screen and commit Code the Login screen and commit After finishing, create a merge request and wait for review After review, merge feature/onboarding into dev With this process, a merge request can contain dozens of changed files, and reviewing that much code is a nightmare. Sometimes, when you create the merge request, there are conflicts with another feature that was merged into dev earlier, and you have to spend time resolving conflicts.\nFor reviewers, sometimes the only way out of the nightmare is to stop dreaming—meaning the senior dev quickly leaves a short comment LGTM (Look good to me), and the junior dev easily merges code into dev. Or, even if the senior dev tries to review carefully, with so many changes, some bugs still slip through. In short, this process still risks letting bugs through.\nWith TBD, the process is adjusted a bit:\nCreate feature/welcome_screen branch Code the Welcome screen, commit, and create a merge request immediately While waiting for review, code the Register screen When the Welcome screen merge request is approved, checkout feature/register_screen and create a new merge request Do the same for the Login screen Now, each merge request only contains a few changed files, making it much easier for the senior dev to review.\nAnd even if the release branch has a bug and needs a hotfix, devs don\u0026rsquo;t merge directly into the release branch as in other models—everything must be merged into the trunk branch.\nFeature flag You might wonder: doesn\u0026rsquo;t this mean the dev branch will be full of unfinished feature code? For example, the app will show the new Welcome screen UI, while Register and Login screens still have the old UI. So how can you ensure the trunk branch is always ready for release?\nThe key is the Feature flag. For each unfinished feature, you add a flag so that when it\u0026rsquo;s on, all the new feature code is active, and when it\u0026rsquo;s off, the app works as before. For example:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 if (ONBOARDING_FLAG == FLAG_ON) { displayNewWelcomeScreen() } else { displayOldWelcomeScreen() } if (ONBOARDING_FLAG == FLAG_ON) { displayNewRegisterScreen() } else { displayOldRegisterScreen() } if (ONBOARDING_FLAG == FLAG_ON) { displayNewLoginScreen() } else { displayOldLoginScreen() } Sometimes, if you want to revert a feature, just turn off its flag. Quick and easy, right?\nAdvantages Fewer conflicts, less code review time As mentioned above, TBD requires everyone to quickly merge their code into the trunk branch, which helps reduce conflicts and code review time.\nIn company B\u0026rsquo;s case study, after seeing the current model wasn\u0026rsquo;t effective, I suggested the dev lead try TBD. As expected, in each sprint, our team hardly had to spend time resolving conflicts anymore.\nCI/CD TBD is very useful for CI/CD. Now you only need to set up and run CI/CD on a single branch. Every commit is quickly checked for coding conventions and unit tests, making it easy for the team to spot and fix errors in time.\nA/B Testing With feature flags, it\u0026rsquo;s easy to turn features on and off, making it convenient for Product Managers to set up A/B Testing. This helps measure and accurately evaluate the effectiveness of new features.\nIn company A\u0026rsquo;s first case study, we actually applied feature flags to many important features for A/B testing.\nFast product delivery Since the code in the trunk branch is always ready for release, I think it\u0026rsquo;s quite suitable for startups. Whenever you want to release a new version, just checkout from the trunk branch, turn on the completed feature flags, turn off the unfinished ones, and build.\nDisadvantages Too much leftover code On the flip side, using feature flags and too many if-else statements can make your code more complex. Sometimes, unclear if-else logic can make it even harder for reviewers to understand.\nAnd when a feature is released, you have to go back and remove the old code flow, like the displayOldWelcomeScreen, displayOldRegisterScreen, and displayOldLoginScreen functions in the example above.\nNot suitable for teams with many juniors Constantly creating merge requests requires devs to be careful, ensuring every commit passes all coding convention checks and unit tests locally, and especially that there are no critical bugs. If a bug on the trunk branch prevents the app from opening, it blocks everyone else.\nIf using feature flags, devs also need to test both the old and new flows to ensure both work correctly.\nSo I think a team mostly made up of seniors is more suitable for this model.\nConclusion TBD is a workflow I\u0026rsquo;ve applied at several companies and found it quite effective for my team\u0026rsquo;s situation. You can consider the pros and cons and try it with your team.\nReference https://trunkbaseddevelopment.com/ ","date":"2023-05-03T02:07:00+07:00","image":"https://namanh11611.github.io/p/trunk-based-development/tbd_hu_b887986eeacb649e.webp","permalink":"https://namanh11611.github.io/p/trunk-based-development/","title":"Trunk Based Development – a Git workflow to reduce the headache of resolving conflicts"},{"content":"What is a Dispatcher? Simply put, a Dispatcher decides which thread a Coroutine will run on. It could be the main thread, a background thread, or it could push the Coroutine into a thread pool.\nThere are 4 types of Dispatchers:\nDispatchers.Default Dispatchers.Main Dispatchers.IO Dispatchers.Unconfined Or you can create your own Dispatcher using newSingleThreadContext() or newFixedThreadPoolContext().\nCoroutine builder functions like launch and async have a CoroutinesContext parameter so you can pass in a Dispatcher, since all the above Dispatchers extend from CoroutinesContext.\n1 2 3 launch(Dispatchers.Default) { println(\u0026#34;I\u0026#39;m working in thread ${Thread.currentThread().name}\u0026#34;) } If you call launch or async without passing a CoroutinesContext, it will inherit the context of the CoroutineScope it was launched in.\n1 2 3 4 5 fun main() = runBlocking\u0026lt;Unit\u0026gt; { launch { println(\u0026#34;I\u0026#39;m working in thread ${Thread.currentThread().name}\u0026#34;) } } In this example, it inherits the context of runBlocking, so it runs on the main thread.\nNow, let\u0026rsquo;s look at each Dispatcher in detail.\nDispatchers.Default Dispatchers.Default is used by default by builder functions like launch and async if you don\u0026rsquo;t assign another Dispatcher. Default uses a shared background threads pool. So you can use Dispatchers.Default for CPU-intensive work. For example:\nHeavy tasks like matrix calculations Sorting, filtering, or searching a huge list in memory Bitmap operations in memory Parsing JSON in memory By default, the maximum number of threads used by Dispatchers.Default is equal to the number of CPU cores, but at least 2.\nDispatchers.Main You can guess from the name, right? Exactly, Dispatchers.Main runs on the main thread, suitable for UI-related tasks.\nUsually, Dispatchers.Main is a single thread.\nDispatchers.IO Again, the name says it all. Dispatchers.IO uses a shared pool of threads created as needed. It helps offload blocking IO tasks. So it\u0026rsquo;s suitable for disk and network operations. For example:\nCalling APIs Downloading files from a server Moving files between folders on disk Reading and writing files Querying databases Loading Shared Preferences The number of threads used by Dispatchers.IO is limited to 64 or the number of cores (whichever is greater).\nDispatchers.Unconfined I call Dispatchers.Unconfined the wild horse, because you never know which thread it will run on.\nInitially, when launched, the Coroutine runs on the thread that called it. But after being suspended and resumed, it may run on a different thread, depending on the suspend functions called. Dispatchers.Unconfined is suitable for work that doesn\u0026rsquo;t consume CPU and doesn\u0026rsquo;t update the UI. But the Kotlin documentation emphasizes:\nThe Unconfined dispatcher should not normally be used in code.\nnewSingleThreadContext This function creates a new thread for you to play with. But creating a new thread is resource-intensive, and you have to call close to release it when done. So in practice, I don\u0026rsquo;t recommend using this.\nThere\u0026rsquo;s also newFixedThreadPoolContext to create a thread pool with a fixed size.\nComparison with RxJava, RxAndroid You can see that Dispatchers are similar to Schedulers in RxJava.\nCoroutines RxJava/RxAndroid Dispatchers.Default Schedulers.computation() Dispatchers.Main AndroidSchedulers.mainThread() Dispatchers.IO Schedulers.io() Conclusion In summary, Dispatchers are an important concept in Coroutines, so you need to understand them well to choose the right Dispatcher for each function.\nReference https://kotlinlang.org/docs/coroutine-context-and-dispatchers.html https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-default.html https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-main.html https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-i-o.html https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-unconfined.html https://amitshekhar.me/blog/dispatchers-in-kotlin-coroutines ","date":"2023-05-01T00:22:00+07:00","image":"https://namanh11611.github.io/p/kotlin-coroutines-dispatchers/dispatchers_hu_d874d366d9a52c.webp","permalink":"https://namanh11611.github.io/p/kotlin-coroutines-dispatchers/","title":"Dispatchers in Kotlin Coroutines"},{"content":"Searching for a Satisfying Bottom Navigation Bar Recently, while working on a project at my company, I got to explore Flutter. It\u0026rsquo;s truly a framework that helps build cross-platform mobile apps very quickly. According to some benchmarks, Flutter even has performance close to native (Kotlin and Swift), and of course, it outperforms React Native.\nIn this project, I had full control over the app\u0026rsquo;s UI/UX. So, I wanted to improve the Bottom Navigation Bar, making it more colorful instead of using Flutter\u0026rsquo;s default Bottom Navigation Bar. After some Googling, I found the curved_navigation_bar package, but it only allows displaying icons in the Bottom Navigation Bar items like this:\nExample code:\n1 2 3 4 5 6 7 8 9 bottomNavigationBar: CurvedNavigationBar( items: \u0026lt;Widget\u0026gt;[ Icon(Icons.add, size: 30), Icon(Icons.list, size: 30), Icon(Icons.compare_arrows, size: 30), Icon(Icons.call_split, size: 30), Icon(Icons.perm_identity, size: 30), ], ) If I wanted to add a label for each item, I could only do so by changing each item to a Column widget:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 bottomNavigationBar: CurvedNavigationBar( items: \u0026lt;Widget\u0026gt;[ Column( children: [Icon(Icons.add, size: 30), Text(\u0026#34;Add\u0026#34;)], ), Column( children: [Icon(Icons.list, size: 30), Text(\u0026#34;List\u0026#34;)], ), Column( children: [Icon(Icons.compare_arrows, size: 30), Text(\u0026#34;Compare\u0026#34;)], ), Column( children: [Icon(Icons.call_split, size: 30), Text(\u0026#34;Split\u0026#34;)], ), Column( children: [Icon(Icons.perm_identity, size: 30), Text(\u0026#34;Person\u0026#34;)], ), ], ) And the result looks like this:\nIt doesn\u0026rsquo;t look very nice, does it? 🤔\nI wanted the label of the selected item to appear below the white background area, and when I select another Bottom Navigation Bar item, the label should stay there. So, the only way was to customize this package. That\u0026rsquo;s when we move to step 2 of this article.\nCustom Curved Navigation Bar I decided to create a new, more flexible package that can support both types: items with labels and items without labels.\nTadaa\u0026hellip; Here is my package: curved_labeled_navigation_bar\nBelow, I\u0026rsquo;ll show you how to implement both types.\nNavigation Bar with label I created a new Widget called CurvedNavigationBarItem to wrap both the Icon and the label.\nExample code:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 bottomNavigationBar: CurvedNavigationBar( items: [ CurvedNavigationBarItem( child: Icon(Icons.home_outlined), label: \u0026#39;Home\u0026#39;, ), CurvedNavigationBarItem( child: Icon(Icons.search), label: \u0026#39;Search\u0026#39;, ), CurvedNavigationBarItem( child: Icon(Icons.chat_bubble_outline), label: \u0026#39;Chat\u0026#39;, ), CurvedNavigationBarItem( child: Icon(Icons.newspaper), label: \u0026#39;Feed\u0026#39;, ), CurvedNavigationBarItem( child: Icon(Icons.perm_identity), label: \u0026#39;Personal\u0026#39;, ), ], ) UI demo:\nNavigation Bar without label Example code:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 bottomNavigationBar: CurvedNavigationBar( items: [ CurvedNavigationBarItem( child: Icon(Icons.home_outlined), ), CurvedNavigationBarItem( child: Icon(Icons.search), ), CurvedNavigationBarItem( child: Icon(Icons.chat_bubble_outline), ), CurvedNavigationBarItem( child: Icon(Icons.newspaper), ), CurvedNavigationBarItem( child: Icon(Icons.perm_identity), ), ], ) UI demo:\nConclusion I hope this little package of mine is helpful for those who want a unique Bottom Navigation Bar. You can support me by giving a like or sharing. If you have any ideas for improvements, don\u0026rsquo;t hesitate to share them with me.\nPackage link: https://pub.dev/packages/curved_labeled_navigation_bar GitHub: https://github.com/namanh11611/curved_labeled_navigation_bar Thank you very much!\n","date":"2022-10-17T22:36:00+07:00","image":"https://namanh11611.github.io/p/curved-bottom-navigation-bar/navigation_hu_4e204c32bc1121ac.webp","permalink":"https://namanh11611.github.io/p/curved-bottom-navigation-bar/","title":"Custom Curved Bottom Navigation Bar in Flutter"},{"content":"The Problem When you want to charge your iPhone with a type C cable =\u0026gt; use an Adapter with a type C port and a lightning connector.\nWhen you have data in XML format but want to use a third-party library function that only accepts JSON =\u0026gt; use an Adapter to convert XML to JSON.\nIn Android, if you have a list of items and want to display them in a RecyclerView =\u0026gt; use an Adapter to convert data into each item_view.\nConcept The Adapter pattern allows the interface of an existing class to be used as another interface. It helps the existing class work with others without changing its source code.\nStill sounds a bit abstract, right? Let\u0026rsquo;s break it down step by step.\nThere are two ways to use adapters: Object Adapter and Class Adapter. Let\u0026rsquo;s look at each in detail.\nObject Adapter Pattern Class Diagram We implement the interface by delegating to the adaptee object at run-time.\nLet me explain a bit more:\nClient is the existing class mentioned in the concept. Client Interface is now the parent interface of Client. Others wanting to interact with Client must follow this parent interface. Service is a third-party class that only accepts JSON, as in the problem statement. Adapter implements the Client Interface and contains an instance of the Service class (object adaptee). Whenever a method of Adapter is called, it calls the corresponding method of Service. This way, we can work with Service without modifying Client\u0026rsquo;s code. Code sample 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 // Client Interface interface TypeCPhone { void chargeByTypeC(); } // Service Interface interface LightningPhone { void chargeByLightning(); } // Service class IPhone implements LightningPhone { @Override public void chargeByLightning() {} } // Adapter class TypeCToLightningPhoneAdapter implements TypeCPhone { private LightningPhone lightningPhone; public TypeCToLightningPhoneAdapter(LightningPhone lightningPhone) { this.lightningPhone = lightningPhone; } @Override public void chargeByTypeC() { lightningPhone.chargeByLightning(); } } public class Demo { static void chargeMyXiaomiPhone(TypeCPhone phone) { phone.chargeByTypeC(); } public static void main(String[] args) { IPhone iPhone = new IPhone(); TypeCToLightningPhoneAdapter adapter = new TypeCToLightningPhoneAdapter(iPhone); chargeMyXiaomiPhone(adapter); } } Class Adapter pattern The Class Adapter doesn\u0026rsquo;t need to wrap any object because it inherits from both Client and Service.\nUnfortunately, Java doesn\u0026rsquo;t support multiple inheritance, so we don\u0026rsquo;t have a Java code sample for this part.\nConclusion Adapter is a fairly familiar design pattern. Through the explanation and a bit of sample code, I hope everyone understands it better.\nReference\nhttps://en.wikipedia.org/wiki/Adapter_pattern https://refactoring.guru/design-patterns/adapter ","date":"2022-10-04T22:50:00+07:00","image":"https://namanh11611.github.io/p/design-pattern-adapter/adapter_hu_bc10558291a16695.webp","permalink":"https://namanh11611.github.io/p/design-pattern-adapter/","title":"Design Pattern: Adapter – how to charge an iPhone with a type C cable"},{"content":"This article will go straight to explaining how to use the @Inject, @Provides, and @Binds annotations. So I\u0026rsquo;ll skip the explanation of Dependency Injection or an introduction to Hilt. Let\u0026rsquo;s assume you already know how to use it. Let\u0026rsquo;s go!\nOverview There are 3 commonly used annotations to inject objects in Hilt:\n@Inject: annotation used on the class constructor @Provides: annotation used in a Module @Binds: another annotation also used in a Module So, when should you use each of these?\nInject We use the @Inject annotation on any constructor where we want to inject an object, from ViewModel, Repository to DataSource. For example:\n1 2 3 4 5 class ProfileRepository @Inject constructor( private val profileDataSource: ProfileDataSource ) { fun doSomething() {} } This makes it easy to inject ProfileRepository into other classes, such as a ViewModel or UseCase. However, you can only use this annotation on constructors of classes you define yourself.\nProvides To overcome the above limitation—injecting objects of classes you don\u0026rsquo;t define (such as Retrofit, OkHttpClient, or a Room database)—we use @Provides. First, you need to create a @Module to hold dependencies with the @Provides annotation. For example:\n1 2 3 4 5 6 7 8 9 10 @Module class NetworkModule { @Provides fun providesApiService(): ApiService = Retrofit.Builder() .addConverterFactory(GsonConverterFactory.create()) .baseUrl(BASE_URL) .build() .create(ApiService::class.java) } Since Retrofit objects are not defined by your code and are created using the Builder pattern, you can\u0026rsquo;t use the @Inject annotation and must use @Provides. Now, you can inject the ApiService interface object anywhere.\nBinds For interfaces, you can\u0026rsquo;t use the @Inject annotation because they don\u0026rsquo;t have constructors. However, if you have an interface with only one implementation (a class that implements that interface), you can use @Binds to inject that interface. Injecting interfaces instead of classes is a good practice and makes testing easier.\nBack to the ProfileRepository in the @Inject section, let\u0026rsquo;s turn it into an interface and create a class that implements it. For example:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 interface ProfileRepository { } class ProfileRepositoryImpl @Inject constructor( private val profileDataSource: ProfileDataSource ) : ProfileRepository { } @Module @InstallIn(SingletonComponent::class) abstract class RepositoryModule { @Singleton @Binds abstract fun bindProfileRepository(profileRepository: ProfileRepositoryImpl): ProfileRepository } class RegisterUseCase @Inject constructor( private val profileRepository: ProfileRepository ) The advantage of using @Binds instead of @Provides is that it reduces the amount of generated code, such as Module Factory classes. Here, you can see I still use @Inject because the constructor of ProfileRepositoryImpl still needs some parameters.\nSummary So, to summarize:\nUse @Inject for your own code Use @Provides for third-party code Use @Binds to inject interfaces, reducing unnecessary code Reference\nhttps://developer.android.com/training/dependency-injection/hilt-android https://dagger.dev/hilt https://www.valueof.io/blog/inject-provides-binds-dependencies-dagger-hilt ","date":"2022-10-02T01:33:00+07:00","image":"https://namanh11611.github.io/p/hilt/hilt_hu_f1e8df134dddd7f.webp","permalink":"https://namanh11611.github.io/p/hilt/","title":"When to use Inject, Provides, Binds in Hilt"},{"content":"Introduction Recently, my team has been running a program called \u0026ldquo;one lesson per week,\u0026rdquo; where each week, a team member gives a seminar on a particular technique or technology. We just finished several weeks on Kotlin. Last week, my team lead gave a seminar about Flask. Oh, I found this framework builds APIs quickly and simply, true to the spirit of Python. I’ve always worked on Front-end and Mobile, never really touched Back-end (well, I did some PHP in college, but I’ve forgotten it all :joy::joy:). So I decided to give it a try and see how it goes.\nSetup Basic For IDE, PyCharm is probably the best, but it’s a bit heavy, so I just used Visual Studio Code with the Python extension, which is more than enough.\nFirst, install Python.\nIf you’re on Windows, download it here: Download Python.\nOn Ubuntu, just run:\n1 2 $ sudo apt-get update $ sudo apt-get install python3.9 Option You can set up Virtual environments or skip this step. Virtual environments help manage your project’s dependencies. For example, you can install different versions of a library for different projects, or even use different Python versions. Each project will have its own set of Python libraries, isolated from others.\nPython 3 uses the venv module to create virtual environments. You can run the following commands to create a project folder and a venv folder:\n1 2 3 $ mkdir myproject $ cd myproject $ python3 -m venv venv On Windows:\n1 $ py -3 -m venv venv Activate your environment:\n1 $ . venv/bin/activate Flask Next, install Flask:\n1 $ pip install Flask Let’s Code Hello World Let’s start by coding a simple Flask app. Create a file called hello.py (any name is fine, just avoid flask.py to prevent conflicts) and write the following:\n1 2 3 4 5 6 from flask import Flask app = Flask(__name__) @app.route(\u0026#39;/\u0026#39;) def hello_world(): return \u0026#39;Hello, World!\u0026#39; A quick explanation:\nFlask(__name__) creates an instance of the Flask class. route() defines the URL for the API. Run the app right away:\n1 2 $ export FLASK_APP=hello.py $ flask run Check http://127.0.0.1:5000/ to see if your app is running.\nBut now, every time you change the code and refresh the browser, you don’t see the changes applied. Why? That’s because you need to enable Debug mode.\n1 2 $ export FLASK_ENV=development $ flask run Now try editing the code and see your results.\nYou can also view your results on another device (I wanted to check on my Android phone) by changing the host (set the host address to your laptop/PC’s IP) and connecting both devices to the same Wi-Fi network:\n1 $ flask run --host=192.168.xxx.xxx JSON JSON is the data format I often use for APIs. Let’s do a quick JSON demo. First, import jsonify:\n1 from flask import Flask, jsonify Instead of returning Hello, World!, let’s return a JSON response:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 @app.route(\u0026#39;/\u0026#39;) def hello_world(): return jsonify([ { \u0026#34;id\u0026#34;: 1, \u0026#34;title\u0026#34;: \u0026#34;First Memory\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;This is first Memory\u0026#34; }, { \u0026#34;id\u0026#34;: 2, \u0026#34;title\u0026#34;: \u0026#34;Second Memory\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;This is second Memory\u0026#34; }, { \u0026#34;id\u0026#34;: 3, \u0026#34;title\u0026#34;: \u0026#34;Third Memory\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;This is third Memory\u0026#34; } ]) But I noticed the fields are all jumbled up, so let’s add a bit of config:\n1 app.config[\u0026#39;JSON_SORT_KEYS\u0026#39;] = False Okay, that looks better!\nNgrok - Demo Your App Without Deploying I’m an Android developer, so I wanted to see if Flask could be used as an API for Retrofit in Android. With the above config, my device could receive the API, but when I tried it with Retrofit, it still didn’t work. Not sure if it’s because of HTTP? If anyone knows, please help clarify this part.\nSo, let me introduce you to Ngrok, a tool that helps you quickly demo your Flask app without deploying it to a server.\nInstall ngrok:\n1 $ pip install pyngrok Run $ ngrok --help to make sure it’s installed successfully. Modify your code a bit to create a Ngrok Tunnel:\n1 2 3 4 from pyngrok import ngrok ... url = ngrok.connect(5000).public_url print(\u0026#39;Henzy Tunnel URL:\u0026#39;, url) Continue by running $ flask run to see the result. Check the printed URL and access it on your Android device. Try using it as the Retrofit URL (remember to use https), and it works pretty well.\nConclusion This is just a Quickstart guide. If you’re interested, I’ll write more articles in the future.\nThank you for reading!\nReferences:\nhttps://flask.palletsprojects.com/en/1.1.x/quickstart/#quickstart https://blog.miguelgrinberg.com/post/access-localhost-from-your-phone-or-from-anywhere-in-the-world ","date":"2021-01-14T01:03:00+07:00","image":"https://namanh11611.github.io/p/flask/flask_hu_915f21afe5077a24.webp","permalink":"https://namanh11611.github.io/p/flask/","title":"Building a Simple API with Flask, Demo with Ngrok"},{"content":"Introduction The Singleton pattern is probably the simplest design pattern that almost everyone knows. It helps create a single instance of a class, often used for classes like Database, Manager, etc. Today, while reading code in my current project, I discovered a really neat way to implement Singleton, called the Bill Pugh Singleton, named after its creator. So I wrote this article to share this approach to Singleton.\nLazy Initialization First, let\u0026rsquo;s look at the Singleton initialization method most people use. The Singleton pattern is implemented by creating an instance in a public method. The downside is that when running in multiple threads, multiple instances can be created. In that case, Singleton is no longer a Singleton.\n1 2 3 4 5 6 7 8 9 10 11 12 13 public class LazyInitializedSingleton { private static LazyInitializedSingleton instance; private LazyInitializedSingleton() { } public static LazyInitializedSingleton getInstance() { if (instance == null) { instance = new LazyInitializedSingleton(); } return instance; } } Thread Safe Singleton To fix the drawback of Lazy Initialization, we add synchronized to the public method. This way, only one instance is created by one thread at a time.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 public class ThreadSafeSingleton { private static ThreadSafeSingleton instance; private ThreadSafeSingleton() { } public static synchronized ThreadSafeSingleton getInstance() { if (instance == null) { instance = new ThreadSafeSingleton(); } return instance; } } However, this approach still has the drawback of reducing app performance because getInstance() is a synchronized method. So, we have another improved approach:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 public class ThreadSafeSingleton { private static ThreadSafeSingleton instance; private ThreadSafeSingleton() { } public static ThreadSafeSingleton getInstance() { if (instance == null) { synchronized (ThreadSafeSingleton.class) { if (instance == null) { instance = new ThreadSafeSingleton(); } } } return instance; } } This way, we only pay the cost on the first call to getInstance().\nBill Pugh Singleton Implementation Before Java 5, Java memory had many issues and the above methods could fail when too many threads called the Singleton class\u0026rsquo;s getInstance() method simultaneously. So, Bill Pugh introduced a new way to implement Singleton using an inner static helper class.\n1 2 3 4 5 6 7 8 9 10 11 12 13 public class BillPughSingleton { private static class SingletonHelper { static final BillPughSingleton INSTANCE = new BillPughSingleton(); } private BillPughSingleton() { } public static BillPughSingleton getInstance() { return SingletonHelper.INSTANCE; } } What do you think of this method? It\u0026rsquo;s fast, concise, and still safe. When the Singleton class is loaded, the SingletonHelper class is not loaded into memory yet. Only when the getInstance() method is called is the helper class loaded and the singleton instance created. This method also doesn\u0026rsquo;t require synchronization or multiple null checks.\nConclusion Within the scope of this article, there are a few more methods I haven\u0026rsquo;t listed, but I hope this gives you a new perspective on the Singleton pattern. Thank you for reading!\nReference\nhttps://www.journaldev.com/1377/java-singleton-design-pattern-best-practices-examples\n","date":"2020-12-29T15:00:00+07:00","image":"https://namanh11611.github.io/p/design-pattern-singleton/singleton_hu_8d6ad988cb8b7136.webp","permalink":"https://namanh11611.github.io/p/design-pattern-singleton/","title":"Design Pattern: Bill Pugh Singleton in Java – surprisingly simple"},{"content":"Introduction After some time working and moving through a few companies, I realized that each place has a different workflow with Git. This article introduces the Git workflow that I think is proper and is also being used at my current company. So, I won\u0026rsquo;t introduce all Git commands, just the ones I think are enough for your daily work.\nWorkflow First day at work Simple, right? On your first day, the only command you need is git clone. When you want to get the team\u0026rsquo;s source code, just open the terminal and type:\n1 git clone \u0026lt;url\u0026gt; A small tip: if you want the folder name after cloning to be different from the project name on remote, just add the folder name at the end:\n1 git clone \u0026lt;url\u0026gt; folder_name Normal days Working alone The boss assigns a new feature, let\u0026rsquo;s get started. But wait, if you\u0026rsquo;re on another branch, don\u0026rsquo;t forget to checkout the team\u0026rsquo;s main branch (usually called master):\n1 git checkout master Then pull the latest code:\n1 git pull To check if your local code is up to date, try using git log. I usually use this for a concise view:\n1 git log --oneline Then, checkout a new branch to start your feature. Adding the -b param will create and switch to the new branch:\n1 git checkout -b feature_branch \u0026hellip;\nCode\u0026hellip; code\u0026hellip; code\u0026hellip;\u0026hellip;\n\u0026hellip;\nDone! Now add the files you changed to the stage. Most IDEs support quick add and commit, but if you want to do it manually:\n1 git add . This adds all changed files to the stage. Then commit:\n1 git commit -m \u0026#34;Fix all bugs\u0026#34; Note: Branch and commit names should be clear, indicating what feature or bug fix they relate to. This depends on your team\u0026rsquo;s rules. Some teams use the task ID as a prefix, others use the purpose, like feature/fixbug/\u0026hellip;\nFinally, push your code to the repository:\n1 git push origin feature_branch Now go to the repository and create a merge request for your boss to review. While waiting, grab a coffee.\nFeature with multiple contributors If your branch has multiple people working on it, and someone else pushed before you, before pushing, pull like this:\n1 git pull --rebase Your commit will be placed on top of your colleague\u0026rsquo;s in the log.\nIf you want to fetch code but not merge yet, use:\n1 git fetch In my opinion, pull = fetch + merge.\nMerging code After review, your boss agrees to merge, but during review you added, changed, or deleted some files. You want to rebase those commits into one, or just edit or delete a commit. Suppose you have 3 commits to combine:\n1 git rebase -i HEAD~3 The terminal gives you options like edit, reword, squash\u0026hellip; Change \u0026lsquo;pick\u0026rsquo; to the option you want. Press Ctrl + O to save, then Ctrl + X to exit.\nAnother issue: someone else pushed to master. You can still merge, but it will create a merge commit. I usually rebase and merge fast forward.\nFirst:\n1 git fetch Then rebase. You must be on feature_branch:\n1 git rebase origin/master Simply put, rebase gets the latest code from master, then \u0026ldquo;rewrites\u0026rdquo; your feature branch to put your commits on top.\nFinally, force push to your feature branch. Force push applies your local log to the repo branch, regardless of differences:\n1 git push -f origin feature_branch If you\u0026rsquo;re the only one on the branch, force push is fine. But be careful when force pushing to a branch with multiple contributors, as it can cause conflicts for others. Only do this when you\u0026rsquo;re sure your feature is done.\nThen, merge code via the merge request on the repo. Task complete!\nCrisis days Reset Sometimes you make a mistake and need to revert code. Git reset has 3 options for you.\nReset commit but keep code in stage, ready to recommit:\n1 git reset --soft commit_id Reset commit and remove code from stage. You need to use git add before recommitting:\n1 git reset --mixed commit_id Reset commit and delete all code you did:\n1 git reset --hard commit_id Stash You can use this as a lifesaver to temporarily save code before rebasing or checking out another branch that has conflicts. Think of it as a stack-structured scratchpad.\nTo stash all current changes:\n1 git stash To apply the last stash:\n1 git stash pop I mainly use Android Studio now, which has Shelf with similar functionality, so I don\u0026rsquo;t use git stash much anymore.\nYou can read more here.\nConclusion Honestly, the title is just clickbait—there\u0026rsquo;s no such thing as a \u0026ldquo;proper\u0026rdquo; workflow. Every company and project is different. If your project is small and speed is a priority, you might skip some steps and push straight to master. If your project is big and strict, you might not allow force pushes to remote. So, what\u0026rsquo;s your company\u0026rsquo;s workflow? Share it with me!\nThanks for reading!\n","date":"2020-11-10T17:19:00+07:00","image":"https://namanh11611.github.io/p/git-process/git_hu_221b8a3eb732f07f.webp","permalink":"https://namanh11611.github.io/p/git-process/","title":"A Proper Workflow with Git"},{"content":"The Unfortunate Situation JavaScript developers are surely familiar with Date, the object used to calculate days, months, and years. On a beautiful day, March 29, 2019, while happily and enthusiastically working overtime, I suddenly discovered a bug related to date display on the Front-end. Wait, when I pass 1 as a parameter, it returns Mar (March), passing 0 returns Jan (January), but what I wanted was Feb (February). What\u0026rsquo;s going on???\nI calmly opened F12 and debugged, only to find that the Date.getMonth() function returns such a weird result.\nIt was already 9pm, and I didn\u0026rsquo;t trust my alertness anymore, so I switched to the Console tab to try it out. Maybe someone had customized the getMonth() function in the project?\nAnd the result was as follows (reproduced on the morning of March 30):\nYou can try this in your own console to verify:\n1 2 3 4 5 var date = new Date(); date.setMonth(1); date.getMonth(); date.setMonth(0); date.getMonth(); This Mouse Trap is Huge It turns out that after calling setMonth(1), date is not set to February (index = 1), but is just moved back 28 days (from March 30 to March 2).\nYou can read more about the setMonth() function here.\nReading the Description carefully, we see that setMonth() uses the current day of the old month to set the day for the new month. If it exceeds the number of days in the new month, it rolls over to the next month. For example, if the current day is 30 or 31, setMonth(1) will definitely move to March, because February has at most 29 days. Here, our current date is March 30, so when setting to February 2019 (which has 28 days), it adds 2 days and becomes March 2.\nIndeed, this mouse trap has at least caught one fat mouse—me.\nSolution From this, we learn that to use setMonth() and getMonth() comfortably, it\u0026rsquo;s best to use the 1st day of the month.\n1 var date = new Date(\u0026#39;March 1, 2019 00:00:01\u0026#39;); Then you can freely use setMonth() and getMonth() as you wish.\nHope you always read the documentation carefully and write fewer bugs. Don\u0026rsquo;t get caught in the trap like I did.\n","date":"2019-03-30T01:33:00+07:00","image":"https://namanh11611.github.io/p/date-set-month/month_hu_603b1b93208a1ea7.webp","permalink":"https://namanh11611.github.io/p/date-set-month/","title":"The Mouse Trap in Javascript's Date.setMonth()"}]